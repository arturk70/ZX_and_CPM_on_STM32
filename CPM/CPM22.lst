# File CPM22.Z80
0000			;************************************************************** 
0000			;* 
0000			;*             C P / M   version   2 . 2 
0000			;* 
0000			;*   Reconstructed from memory image on February 27, 1981 
0000			;* 
0000			;*                by Clark A. Calkins 
0000			;* 
0000			;************************************************************** 
0000			; 
0000			;   Set memory limit here. This is the amount of contigeous 
0000			; ram starting from 0000. CP/M will reside at the end of this space. 
0000			; 
0000			MEM:	EQU	54		;total amount of memory. 
0000			; 
0000			IOBYTE:	EQU	3		;i/o definition byte. 
0000			TDRIVE:	EQU	4		;current drive name and user number. 
0000			ENTRY:	EQU	5		;entry point for the cp/m bdos. 
0000			TFCB:	EQU	5CH		;default file control block. 
0000			TBUFF:	EQU	80H		;i/o buffer and command line storage. 
0000			TBASE:	EQU	100H		;transiant program storage area. 
0000			; 
0000			;   Set control character equates. 
0000			; 
0000			CNTRLC:	EQU	3		;control-c 
0000			CNTRLE:	EQU	05H		;control-e 
0000			BS:	EQU	08H		;backspace 
0000			TAB:	EQU	09H		;tab 
0000			LF:	EQU	0AH		;line feed 
0000			FF:	EQU	0CH		;form feed 
0000			CR:	EQU	0DH		;carriage return 
0000			CNTRLP:	EQU	10H		;control-p 
0000			CNTRLR:	EQU	12H		;control-r 
0000			CNTRLS:	EQU	13H		;control-s 
0000			CNTRLU:	EQU	15H		;control-u 
0000			CNTRLX:	EQU	18H		;control-x 
0000			CNTRLZ:	EQU	1AH		;control-z (end-of-file mark) 
0000			DEL:	EQU	7FH		;rubout 
0000			; 
0000			;   Set origin for CP/M 
0000			; 
0000				ORG	(MEM-7)*1024 
bc00			; 
bc00 c3 5c bf		CBASE:	JP	COMMAND		;execute command processor (ccp). 
bc03 c3 58 bf			JP	CLEARBUF	;entry to empty input buffer before starting ccp. 
bc06			 
bc06			; 
bc06			;   Standard cp/m ccp input buffer. Format is (max length), 
bc06			; (actual length), (char #1), (char #2), (char #3), etc. 
bc06			; 
bc06 7f			INBUFF:	DEFB	127		;length of input buffer. 
bc07 00				DEFB	0		;current length of contents. 
bc08 ..				DEFB	'Copyright' 
bc11 ..				DEFB	' 1979 (c) by Digital Research      ' 
bc34 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 
bc4b 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 
bc62 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 
bc79 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 
bc88 08 bc		INPOINT:DEFW	INBUFF+2	;input line pointer 
bc8a 00 00		NAMEPNT:DEFW	0		;input line pointer used for error message. Points to 
bc8c			;			;start of name in error. 
bc8c			; 
bc8c			;   Routine to print (A) on the console. All registers used. 
bc8c			; 
bc8c 5f			PRINT:	LD	E,A		;setup bdos call. 
bc8d 0e 02			LD	C,2 
bc8f c3 05 00			JP	ENTRY 
bc92			; 
bc92			;   Routine to print (A) on the console and to save (BC). 
bc92			; 
bc92 c5			PRINTB:	PUSH	BC 
bc93 cd 8c bc			CALL	PRINT 
bc96 c1				POP	BC 
bc97 c9				RET	 
bc98			; 
bc98			;   Routine to send a carriage return, line feed combination 
bc98			; to the console. 
bc98			; 
bc98 3e 0d		CRLF:	LD	A,CR 
bc9a cd 92 bc			CALL	PRINTB 
bc9d 3e 0a			LD	A,LF 
bc9f c3 92 bc			JP	PRINTB 
bca2			; 
bca2			;   Routine to send one space to the console and save (BC). 
bca2			; 
bca2 3e 20		SPACE:	LD	A,' ' 
bca4 c3 92 bc			JP	PRINTB 
bca7			; 
bca7			;   Routine to print character string pointed to be (BC) on the 
bca7			; console. It must terminate with a null byte. 
bca7			; 
bca7 c5			PLINE:	PUSH	BC 
bca8 cd 98 bc			CALL	CRLF 
bcab e1				POP	HL 
bcac 7e			PLINE2:	LD	A,(HL) 
bcad b7				OR	A 
bcae c8				RET	Z 
bcaf 23				INC	HL 
bcb0 e5				PUSH	HL 
bcb1 cd 8c bc			CALL	PRINT 
bcb4 e1				POP	HL 
bcb5 c3 ac bc			JP	PLINE2 
bcb8			; 
bcb8			;   Routine to reset the disk system. 
bcb8			; 
bcb8 0e 0d		RESDSK:	LD	C,13 
bcba c3 05 00			JP	ENTRY 
bcbd			; 
bcbd			;   Routine to select disk (A). 
bcbd			; 
bcbd 5f			DSKSEL:	LD	E,A 
bcbe 0e 0e			LD	C,14 
bcc0 c3 05 00			JP	ENTRY 
bcc3			; 
bcc3			;   Routine to call bdos and save the return code. The zero 
bcc3			; flag is set on a return of 0ffh. 
bcc3			; 
bcc3 cd 05 00		ENTRY1:	CALL	ENTRY 
bcc6 32 f3 c3			LD	(RTNCODE),A	;save return code. 
bcc9 3c				INC	A		;set zero if 0ffh returned. 
bcca c9				RET	 
bccb			; 
bccb			;   Routine to open a file. (DE) must point to the FCB. 
bccb			; 
bccb 0e 0f		OPEN:	LD	C,15 
bccd c3 c3 bc			JP	ENTRY1 
bcd0			; 
bcd0			;   Routine to open file at (FCB). 
bcd0			; 
bcd0 af			OPENFCB:XOR	A		;clear the record number byte at fcb+32 
bcd1 32 f2 c3			LD	(FCB+32),A 
bcd4 11 d2 c3			LD	DE,FCB 
bcd7 c3 cb bc			JP	OPEN 
bcda			; 
bcda			;   Routine to close a file. (DE) points to FCB. 
bcda			; 
bcda 0e 10		CLOSE:	LD	C,16 
bcdc c3 c3 bc			JP	ENTRY1 
bcdf			; 
bcdf			;   Routine to search for the first file with ambigueous name 
bcdf			; (DE). 
bcdf			; 
bcdf 0e 11		SRCHFST:LD	C,17 
bce1 c3 c3 bc			JP	ENTRY1 
bce4			; 
bce4			;   Search for the next ambigeous file name. 
bce4			; 
bce4 0e 12		SRCHNXT:LD	C,18 
bce6 c3 c3 bc			JP	ENTRY1 
bce9			; 
bce9			;   Search for file at (FCB). 
bce9			; 
bce9 11 d2 c3		SRCHFCB:LD	DE,FCB 
bcec c3 df bc			JP	SRCHFST 
bcef			; 
bcef			;   Routine to delete a file pointed to by (DE). 
bcef			; 
bcef 0e 13		DELETE:	LD	C,19 
bcf1 c3 05 00			JP	ENTRY 
bcf4			; 
bcf4			;   Routine to call the bdos and set the zero flag if a zero 
bcf4			; status is returned. 
bcf4			; 
bcf4 cd 05 00		ENTRY2:	CALL	ENTRY 
bcf7 b7				OR	A		;set zero flag if appropriate. 
bcf8 c9				RET	 
bcf9			; 
bcf9			;   Routine to read the next record from a sequential file. 
bcf9			; (DE) points to the FCB. 
bcf9			; 
bcf9 0e 14		RDREC:	LD	C,20 
bcfb c3 f4 bc			JP	ENTRY2 
bcfe			; 
bcfe			;   Routine to read file at (FCB). 
bcfe			; 
bcfe 11 d2 c3		READFCB:LD	DE,FCB 
bd01 c3 f9 bc			JP	RDREC 
bd04			; 
bd04			;   Routine to write the next record of a sequential file. 
bd04			; (DE) points to the FCB. 
bd04			; 
bd04 0e 15		WRTREC:	LD	C,21 
bd06 c3 f4 bc			JP	ENTRY2 
bd09			; 
bd09			;   Routine to create the file pointed to by (DE). 
bd09			; 
bd09 0e 16		CREATE:	LD	C,22 
bd0b c3 c3 bc			JP	ENTRY1 
bd0e			; 
bd0e			;   Routine to rename the file pointed to by (DE). Note that 
bd0e			; the new name starts at (DE+16). 
bd0e			; 
bd0e 0e 17		RENAM:	LD	C,23 
bd10 c3 05 00			JP	ENTRY 
bd13			; 
bd13			;   Get the current user code. 
bd13			; 
bd13 1e ff		GETUSR:	LD	E,0FFH 
bd15			; 
bd15			;   Routne to get or set the current user code. 
bd15			; If (E) is FF then this is a GET, else it is a SET. 
bd15			; 
bd15 0e 20		GETSETUC: LD	C,32 
bd17 c3 05 00			JP	ENTRY 
bd1a			; 
bd1a			;   Routine to set the current drive byte at (TDRIVE). 
bd1a			; 
bd1a cd 13 bd		SETCDRV:CALL	GETUSR		;get user number 
bd1d 87				ADD	A,A		;and shift into the upper 4 bits. 
bd1e 87				ADD	A,A 
bd1f 87				ADD	A,A 
bd20 87				ADD	A,A 
bd21 21 f4 c3			LD	HL,CDRIVE	;now add in the current drive number. 
bd24 b6				OR	(HL) 
bd25 32 04 00			LD	(TDRIVE),A	;and save. 
bd28 c9				RET	 
bd29			; 
bd29			;   Move currently active drive down to (TDRIVE). 
bd29			; 
bd29 3a f4 c3		MOVECD:	LD	A,(CDRIVE) 
bd2c 32 04 00			LD	(TDRIVE),A 
bd2f c9				RET	 
bd30			; 
bd30			;   Routine to convert (A) into upper case ascii. Only letters 
bd30			; are affected. 
bd30			; 
bd30 fe 61		UPPER:	CP	'a'		;check for letters in the range of 'a' to 'z'. 
bd32 d8				RET	C 
bd33 fe 7b			CP	'{' 
bd35 d0				RET	NC 
bd36 e6 5f			AND	5FH		;convert it if found. 
bd38 c9				RET	 
bd39			; 
bd39			;   Routine to get a line of input. We must check to see if the 
bd39			; user is in (BATCH) mode. If so, then read the input from file 
bd39			; ($$$.SUB). At the end, reset to console input. 
bd39			; 
bd39 3a b0 c3		GETINP:	LD	A,(BATCH)	;if =0, then use console input. 
bd3c b7				OR	A 
bd3d ca 96 bd			JP	Z,GETINP1 
bd40			; 
bd40			;   Use the submit file ($$$.sub) which is prepared by a 
bd40			; SUBMIT run. It must be on drive (A) and it will be deleted 
bd40			; if and error occures (like eof). 
bd40			; 
bd40 3a f4 c3			LD	A,(CDRIVE)	;select drive 0 if need be. 
bd43 b7				OR	A 
bd44 3e 00			LD	A,0		;always use drive A for submit. 
bd46 c4 bd bc			CALL	NZ,DSKSEL	;select it if required. 
bd49 11 b1 c3			LD	DE,BATCHFCB 
bd4c cd cb bc			CALL	OPEN		;look for it. 
bd4f ca 96 bd			JP	Z,GETINP1	;if not there, use normal input. 
bd52 3a c0 c3			LD	A,(BATCHFCB+15)	;get last record number+1. 
bd55 3d				DEC	A 
bd56 32 d1 c3			LD	(BATCHFCB+32),A 
bd59 11 b1 c3			LD	DE,BATCHFCB 
bd5c cd f9 bc			CALL	RDREC		;read last record. 
bd5f c2 96 bd			JP	NZ,GETINP1	;quit on end of file. 
bd62			; 
bd62			;   Move this record into input buffer. 
bd62			; 
bd62 11 07 bc			LD	DE,INBUFF+1 
bd65 21 80 00			LD	HL,TBUFF	;data was read into buffer here. 
bd68 06 80			LD	B,128		;all 128 characters may be used. 
bd6a cd 42 c0			CALL	HL2DE		;(HL) to (DE), (B) bytes. 
bd6d 21 bf c3			LD	HL,BATCHFCB+14 
bd70 36 00			LD	(HL),0		;zero out the 's2' byte. 
bd72 23				INC	HL		;and decrement the record count. 
bd73 35				DEC	(HL) 
bd74 11 b1 c3			LD	DE,BATCHFCB	;close the batch file now. 
bd77 cd da bc			CALL	CLOSE 
bd7a ca 96 bd			JP	Z,GETINP1	;quit on an error. 
bd7d 3a f4 c3			LD	A,(CDRIVE)	;re-select previous drive if need be. 
bd80 b7				OR	A 
bd81 c4 bd bc			CALL	NZ,DSKSEL	;don't do needless selects. 
bd84			; 
bd84			;   Print line just read on console. 
bd84			; 
bd84 21 08 bc			LD	HL,INBUFF+2 
bd87 cd ac bc			CALL	PLINE2 
bd8a cd c2 bd			CALL	CHKCON		;check console, quit on a key. 
bd8d ca a7 bd			JP	Z,GETINP2	;jump if no key is pressed. 
bd90			; 
bd90			;   Terminate the submit job on any keyboard input. Delete this 
bd90			; file such that it is not re-started and jump to normal keyboard 
bd90			; input section. 
bd90			; 
bd90 cd dd bd			CALL	DELBATCH	;delete the batch file. 
bd93 c3 82 bf			JP	CMMND1		;and restart command input. 
bd96			; 
bd96			;   Get here for normal keyboard input. Delete the submit file 
bd96			; incase there was one. 
bd96			; 
bd96 cd dd bd		GETINP1:CALL	DELBATCH	;delete file ($$$.sub). 
bd99 cd 1a bd			CALL	SETCDRV		;reset active disk. 
bd9c 0e 0a			LD	C,10		;get line from console device. 
bd9e 11 06 bc			LD	DE,INBUFF 
bda1 cd 05 00			CALL	ENTRY 
bda4 cd 29 bd			CALL	MOVECD		;reset current drive (again). 
bda7			; 
bda7			;   Convert input line to upper case. 
bda7			; 
bda7 21 07 bc		GETINP2:LD	HL,INBUFF+1 
bdaa 46				LD	B,(HL)		;(B)=character counter. 
bdab 23			GETINP3:INC	HL 
bdac 78				LD	A,B		;end of the line? 
bdad b7				OR	A 
bdae ca ba bd			JP	Z,GETINP4 
bdb1 7e				LD	A,(HL)		;convert to upper case. 
bdb2 cd 30 bd			CALL	UPPER 
bdb5 77				LD	(HL),A 
bdb6 05				DEC	B		;adjust character count. 
bdb7 c3 ab bd			JP	GETINP3 
bdba 77			GETINP4:LD	(HL),A		;add trailing null. 
bdbb 21 08 bc			LD	HL,INBUFF+2 
bdbe 22 88 bc			LD	(INPOINT),HL	;reset input line pointer. 
bdc1 c9				RET	 
bdc2			; 
bdc2			;   Routine to check the console for a key pressed. The zero 
bdc2			; flag is set is none, else the character is returned in (A). 
bdc2			; 
bdc2 0e 0b		CHKCON:	LD	C,11		;check console. 
bdc4 cd 05 00			CALL	ENTRY 
bdc7 b7				OR	A 
bdc8 c8				RET	Z		;return if nothing. 
bdc9 0e 01			LD	C,1		;else get character. 
bdcb cd 05 00			CALL	ENTRY 
bdce b7				OR	A		;clear zero flag and return. 
bdcf c9				RET	 
bdd0			; 
bdd0			;   Routine to get the currently active drive number. 
bdd0			; 
bdd0 0e 19		GETDSK:	LD	C,25 
bdd2 c3 05 00			JP	ENTRY 
bdd5			; 
bdd5			;   Set the stabdard dma address. 
bdd5			; 
bdd5 11 80 00		STDDMA:	LD	DE,TBUFF 
bdd8			; 
bdd8			;   Routine to set the dma address to (DE). 
bdd8			; 
bdd8 0e 1a		DMASET:	LD	C,26 
bdda c3 05 00			JP	ENTRY 
bddd			; 
bddd			;  Delete the batch file created by SUBMIT. 
bddd			; 
bddd 21 b0 c3		DELBATCH: LD	HL,BATCH	;is batch active? 
bde0 7e				LD	A,(HL) 
bde1 b7				OR	A 
bde2 c8				RET	Z 
bde3 36 00			LD	(HL),0		;yes, de-activate it. 
bde5 af				XOR	A 
bde6 cd bd bc			CALL	DSKSEL		;select drive 0 for sure. 
bde9 11 b1 c3			LD	DE,BATCHFCB	;and delete this file. 
bdec cd ef bc			CALL	DELETE 
bdef 3a f4 c3			LD	A,(CDRIVE)	;reset current drive. 
bdf2 c3 bd bc			JP	DSKSEL 
bdf5			; 
bdf5			;   Check to two strings at (PATTRN1) and (PATTRN2). They must be 
bdf5			; the same or we halt.... 
bdf5			; 
bdf5 11 28 bf		VERIFY:	LD	DE,PATTRN1	;these are the serial number bytes. 
bdf8 21 00 c4			LD	HL,PATTRN2	;ditto, but how could they be different? 
bdfb 06 06			LD	B,6		;6 bytes each. 
bdfd 1a			VERIFY1:LD	A,(DE) 
bdfe be				CP	(HL) 
bdff c2 cf bf			JP	NZ,HALT		;jump to halt routine. 
be02 13				INC	DE 
be03 23				INC	HL 
be04 05				DEC	B 
be05 c2 fd bd			JP	NZ,VERIFY1 
be08 c9				RET	 
be09			; 
be09			;   Print back file name with a '?' to indicate a syntax error. 
be09			; 
be09 cd 98 bc		SYNERR:	CALL	CRLF		;end current line. 
be0c 2a 8a bc			LD	HL,(NAMEPNT)	;this points to name in error. 
be0f 7e			SYNERR1:LD	A,(HL)		;print it until a space or null is found. 
be10 fe 20			CP	' ' 
be12 ca 22 be			JP	Z,SYNERR2 
be15 b7				OR	A 
be16 ca 22 be			JP	Z,SYNERR2 
be19 e5				PUSH	HL 
be1a cd 8c bc			CALL	PRINT 
be1d e1				POP	HL 
be1e 23				INC	HL 
be1f c3 0f be			JP	SYNERR1 
be22 3e 3f		SYNERR2:LD	A,'?'		;add trailing '?'. 
be24 cd 8c bc			CALL	PRINT 
be27 cd 98 bc			CALL	CRLF 
be2a cd dd bd			CALL	DELBATCH	;delete any batch file. 
be2d c3 82 bf			JP	CMMND1		;and restart from console input. 
be30			; 
be30			;   Check character at (DE) for legal command input. Note that the 
be30			; zero flag is set if the character is a delimiter. 
be30			; 
be30 1a			CHECK:	LD	A,(DE) 
be31 b7				OR	A 
be32 c8				RET	Z 
be33 fe 20			CP	' '		;control characters are not legal here. 
be35 da 09 be			JP	C,SYNERR 
be38 c8				RET	Z		;check for valid delimiter. 
be39 fe 3d			CP	'=' 
be3b c8				RET	Z 
be3c fe 5f			CP	'_' 
be3e c8				RET	Z 
be3f fe 2e			CP	'.' 
be41 c8				RET	Z 
be42 fe 3a			CP	':' 
be44 c8				RET	Z 
be45 fe 3b			CP	';' 
be47 c8				RET	Z 
be48 fe 3c			CP	'<' 
be4a c8				RET	Z 
be4b fe 3e			CP	'>' 
be4d c8				RET	Z 
be4e c9				RET	 
be4f			; 
be4f			;   Get the next non-blank character from (DE). 
be4f			; 
be4f 1a			NONBLANK: LD	A,(DE) 
be50 b7				OR	A		;string ends with a null. 
be51 c8				RET	Z 
be52 fe 20			CP	' ' 
be54 c0				RET	NZ 
be55 13				INC	DE 
be56 c3 4f be			JP	NONBLANK 
be59			; 
be59			;   Add (HL)=(HL)+(A) 
be59			; 
be59 85			ADDHL:	ADD	A,L 
be5a 6f				LD	L,A 
be5b d0				RET	NC		;take care of any carry. 
be5c 24				INC	H 
be5d c9				RET	 
be5e			; 
be5e			;   Convert the first name in (FCB). 
be5e			; 
be5e 3e 00		CONVFST:LD	A,0 
be60			; 
be60			;   Format a file name (convert * to '?', etc.). On return, 
be60			; (A)=0 is an unambigeous name was specified. Enter with (A) equal to 
be60			; the position within the fcb for the name (either 0 or 16). 
be60			; 
be60 21 d2 c3		CONVERT:LD	HL,FCB 
be63 cd 59 be			CALL	ADDHL 
be66 e5				PUSH	HL 
be67 e5				PUSH	HL 
be68 af				XOR	A 
be69 32 f5 c3			LD	(CHGDRV),A	;initialize drive change flag. 
be6c 2a 88 bc			LD	HL,(INPOINT)	;set (HL) as pointer into input line. 
be6f eb				EX	DE,HL 
be70 cd 4f be			CALL	NONBLANK	;get next non-blank character. 
be73 eb				EX	DE,HL 
be74 22 8a bc			LD	(NAMEPNT),HL	;save pointer here for any error message. 
be77 eb				EX	DE,HL 
be78 e1				POP	HL 
be79 1a				LD	A,(DE)		;get first character. 
be7a b7				OR	A 
be7b ca 89 be			JP	Z,CONVRT1 
be7e de 40			SBC	A,'A'-1		;might be a drive name, convert to binary. 
be80 47				LD	B,A		;and save. 
be81 13				INC	DE		;check next character for a ':'. 
be82 1a				LD	A,(DE) 
be83 fe 3a			CP	':' 
be85 ca 90 be			JP	Z,CONVRT2 
be88 1b				DEC	DE		;nope, move pointer back to the start of the line. 
be89 3a f4 c3		CONVRT1:LD	A,(CDRIVE) 
be8c 77				LD	(HL),A 
be8d c3 96 be			JP	CONVRT3 
be90 78			CONVRT2:LD	A,B 
be91 32 f5 c3			LD	(CHGDRV),A	;set change in drives flag. 
be94 70				LD	(HL),B 
be95 13				INC	DE 
be96			; 
be96			;   Convert the basic file name. 
be96			; 
be96 06 08		CONVRT3:LD	B,08H 
be98 cd 30 be		CONVRT4:CALL	CHECK 
be9b ca b9 be			JP	Z,CONVRT8 
be9e 23				INC	HL 
be9f fe 2a			CP	'*'		;note that an '*' will fill the remaining 
bea1 c2 a9 be			JP	NZ,CONVRT5	;field with '?'. 
bea4 36 3f			LD	(HL),'?' 
bea6 c3 ab be			JP	CONVRT6 
bea9 77			CONVRT5:LD	(HL),A 
beaa 13				INC	DE 
beab 05			CONVRT6:DEC	B 
beac c2 98 be			JP	NZ,CONVRT4 
beaf cd 30 be		CONVRT7:CALL	CHECK		;get next delimiter. 
beb2 ca c0 be			JP	Z,GETEXT 
beb5 13				INC	DE 
beb6 c3 af be			JP	CONVRT7 
beb9 23			CONVRT8:INC	HL		;blank fill the file name. 
beba 36 20			LD	(HL),' ' 
bebc 05				DEC	B 
bebd c2 b9 be			JP	NZ,CONVRT8 
bec0			; 
bec0			;   Get the extension and convert it. 
bec0			; 
bec0 06 03		GETEXT:	LD	B,03H 
bec2 fe 2e			CP	'.' 
bec4 c2 e9 be			JP	NZ,GETEXT5 
bec7 13				INC	DE 
bec8 cd 30 be		GETEXT1:CALL	CHECK 
becb ca e9 be			JP	Z,GETEXT5 
bece 23				INC	HL 
becf fe 2a			CP	'*' 
bed1 c2 d9 be			JP	NZ,GETEXT2 
bed4 36 3f			LD	(HL),'?' 
bed6 c3 db be			JP	GETEXT3 
bed9 77			GETEXT2:LD	(HL),A 
beda 13				INC	DE 
bedb 05			GETEXT3:DEC	B 
bedc c2 c8 be			JP	NZ,GETEXT1 
bedf cd 30 be		GETEXT4:CALL	CHECK 
bee2 ca f0 be			JP	Z,GETEXT6 
bee5 13				INC	DE 
bee6 c3 df be			JP	GETEXT4 
bee9 23			GETEXT5:INC	HL 
beea 36 20			LD	(HL),' ' 
beec 05				DEC	B 
beed c2 e9 be			JP	NZ,GETEXT5 
bef0 06 03		GETEXT6:LD	B,3 
bef2 23			GETEXT7:INC	HL 
bef3 36 00			LD	(HL),0 
bef5 05				DEC	B 
bef6 c2 f2 be			JP	NZ,GETEXT7 
bef9 eb				EX	DE,HL 
befa 22 88 bc			LD	(INPOINT),HL	;save input line pointer. 
befd e1				POP	HL 
befe			; 
befe			;   Check to see if this is an ambigeous file name specification. 
befe			; Set the (A) register to non zero if it is. 
befe			; 
befe 01 0b 00			LD	BC,11		;set name length. 
bf01 23			GETEXT8:INC	HL 
bf02 7e				LD	A,(HL) 
bf03 fe 3f			CP	'?'		;any question marks? 
bf05 c2 09 bf			JP	NZ,GETEXT9 
bf08 04				INC	B		;count them. 
bf09 0d			GETEXT9:DEC	C 
bf0a c2 01 bf			JP	NZ,GETEXT8 
bf0d 78				LD	A,B 
bf0e b7				OR	A 
bf0f c9				RET	 
bf10			; 
bf10			;   CP/M command table. Note commands can be either 3 or 4 characters long. 
bf10			; 
bf10			NUMCMDS:EQU	6		;number of commands 
bf10 ..			CMDTBL:	DEFB	'DIR ' 
bf14 ..				DEFB	'ERA ' 
bf18 ..				DEFB	'TYPE' 
bf1c ..				DEFB	'SAVE' 
bf20 ..				DEFB	'REN ' 
bf24 ..				DEFB	'USER' 
bf28			; 
bf28			;   The following six bytes must agree with those at (PATTRN2) 
bf28			; or cp/m will HALT. Why? 
bf28			; 
bf28 00 16 00 00 00 00	PATTRN1:DEFB	0,22,0,0,0,0	;(* serial number bytes *). 
bf2e			; 
bf2e			;   Search the command table for a match with what has just 
bf2e			; been entered. If a match is found, then we jump to the 
bf2e			; proper section. Else jump to (UNKNOWN). 
bf2e			; On return, the (C) register is set to the command number 
bf2e			; that matched (or NUMCMDS+1 if no match). 
bf2e			; 
bf2e 21 10 bf		SEARCH:	LD	HL,CMDTBL 
bf31 0e 00			LD	C,0 
bf33 79			SEARCH1:LD	A,C 
bf34 fe 06			CP	NUMCMDS		;this commands exists. 
bf36 d0				RET	NC 
bf37 11 d3 c3			LD	DE,FCB+1	;check this one. 
bf3a 06 04			LD	B,4		;max command length. 
bf3c 1a			SEARCH2:LD	A,(DE) 
bf3d be				CP	(HL) 
bf3e c2 4f bf			JP	NZ,SEARCH3	;not a match. 
bf41 13				INC	DE 
bf42 23				INC	HL 
bf43 05				DEC	B 
bf44 c2 3c bf			JP	NZ,SEARCH2 
bf47 1a				LD	A,(DE)		;allow a 3 character command to match. 
bf48 fe 20			CP	' ' 
bf4a c2 54 bf			JP	NZ,SEARCH4 
bf4d 79				LD	A,C		;set return register for this command. 
bf4e c9				RET	 
bf4f 23			SEARCH3:INC	HL 
bf50 05				DEC	B 
bf51 c2 4f bf			JP	NZ,SEARCH3 
bf54 0c			SEARCH4:INC	C 
bf55 c3 33 bf			JP	SEARCH1 
bf58			; 
bf58			;   Set the input buffer to empty and then start the command 
bf58			; processor (ccp). 
bf58			; 
bf58 af			CLEARBUF: XOR	A 
bf59 32 07 bc			LD	(INBUFF+1),A	;second byte is actual length. 
bf5c			; 
bf5c			;************************************************************** 
bf5c			;* 
bf5c			;* 
bf5c			;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r 
bf5c			;* 
bf5c			;************************************************************** 
bf5c			;* 
bf5c 31 b0 c3		COMMAND:LD	SP,CCPSTACK	;setup stack area. 
bf5f c5				PUSH	BC		;note that (C) should be equal to: 
bf60 79				LD	A,C		;(uuuudddd) where 'uuuu' is the user number 
bf61 1f				RRA			;and 'dddd' is the drive number. 
bf62 1f				RRA	 
bf63 1f				RRA	 
bf64 1f				RRA	 
bf65 e6 0f			AND	0FH		;isolate the user number. 
bf67 5f				LD	E,A 
bf68 cd 15 bd			CALL	GETSETUC	;and set it. 
bf6b cd b8 bc			CALL	RESDSK		;reset the disk system. 
bf6e 32 b0 c3			LD	(BATCH),A	;clear batch mode flag. 
bf71 c1				POP	BC 
bf72 79				LD	A,C 
bf73 e6 0f			AND	0FH		;isolate the drive number. 
bf75 32 f4 c3			LD	(CDRIVE),A	;and save. 
bf78 cd bd bc			CALL	DSKSEL		;...and select. 
bf7b 3a 07 bc			LD	A,(INBUFF+1) 
bf7e b7				OR	A		;anything in input buffer already? 
bf7f c2 98 bf			JP	NZ,CMMND2	;yes, we just process it. 
bf82			; 
bf82			;   Entry point to get a command line from the console. 
bf82			; 
bf82 31 b0 c3		CMMND1:	LD	SP,CCPSTACK	;set stack straight. 
bf85 cd 98 bc			CALL	CRLF		;start a new line on the screen. 
bf88 cd d0 bd			CALL	GETDSK		;get current drive. 
bf8b c6 61			ADD	A,'a' 
bf8d cd 8c bc			CALL	PRINT		;print current drive. 
bf90 3e 3e			LD	A,'>' 
bf92 cd 8c bc			CALL	PRINT		;and add prompt. 
bf95 cd 39 bd			CALL	GETINP		;get line from user. 
bf98			; 
bf98			;   Process command line here. 
bf98			; 
bf98 11 80 00		CMMND2:	LD	DE,TBUFF 
bf9b cd d8 bd			CALL	DMASET		;set standard dma address. 
bf9e cd d0 bd			CALL	GETDSK 
bfa1 32 f4 c3			LD	(CDRIVE),A	;set current drive. 
bfa4 cd 5e be			CALL	CONVFST		;convert name typed in. 
bfa7 c4 09 be			CALL	NZ,SYNERR	;wild cards are not allowed. 
bfaa 3a f5 c3			LD	A,(CHGDRV)	;if a change in drives was indicated, 
bfad b7				OR	A		;then treat this as an unknown command 
bfae c2 aa c2			JP	NZ,UNKNOWN	;which gets executed. 
bfb1 cd 2e bf			CALL	SEARCH		;else search command table for a match. 
bfb4			; 
bfb4			;   Note that an unknown command returns 
bfb4			; with (A) pointing to the last address 
bfb4			; in our table which is (UNKNOWN). 
bfb4			; 
bfb4 21 c1 bf			LD	HL,CMDADR	;now, look thru our address table for command (A). 
bfb7 5f				LD	E,A		;set (DE) to command number. 
bfb8 16 00			LD	D,0 
bfba 19				ADD	HL,DE 
bfbb 19				ADD	HL,DE		;(HL)=(CMDADR)+2*(command number). 
bfbc 7e				LD	A,(HL)		;now pick out this address. 
bfbd 23				INC	HL 
bfbe 66				LD	H,(HL) 
bfbf 6f				LD	L,A 
bfc0 e9				JP	(HL)		;now execute it. 
bfc1			; 
bfc1			;   CP/M command address table. 
bfc1			; 
bfc1 77 c0 24 c1 62 c1 b2 c1	CMDADR:	DEFW	DIRECT,ERASE,TYPE,SAVE 
bfc9 15 c2 93 c2 aa c2		DEFW	RENAME,USER,UNKNOWN 
bfcf			; 
bfcf			;   Halt the system. Reason for this is unknown at present. 
bfcf			; 
bfcf 21 f3 76		HALT:	LD	HL,76F3H	;'DI HLT' instructions. 
bfd2 22 00 bc			LD	(CBASE),HL 
bfd5 21 00 bc			LD	HL,CBASE 
bfd8 e9				JP	(HL) 
bfd9			; 
bfd9			;   Read error while TYPEing a file. 
bfd9			; 
bfd9 01 df bf		RDERROR:LD	BC,RDERR 
bfdc c3 a7 bc			JP	PLINE 
bfdf .. 00		RDERR:	DEFB	'Read error',0 
bfea			; 
bfea			;   Required file was not located. 
bfea			; 
bfea 01 f0 bf		NONE:	LD	BC,NOFILE 
bfed c3 a7 bc			JP	PLINE 
bff0 .. 00		NOFILE:	DEFB	'No file',0 
bff8			; 
bff8			;   Decode a command of the form 'A>filename number{ filename}. 
bff8			; Note that a drive specifier is not allowed on the first file 
bff8			; name. On return, the number is in register (A). Any error 
bff8			; causes 'filename?' to be printed and the command is aborted. 
bff8			; 
bff8 cd 5e be		DECODE:	CALL	CONVFST		;convert filename. 
bffb 3a f5 c3			LD	A,(CHGDRV)	;do not allow a drive to be specified. 
bffe b7				OR	A 
bfff c2 09 be			JP	NZ,SYNERR 
c002 21 d3 c3			LD	HL,FCB+1	;convert number now. 
c005 01 0b 00			LD	BC,11		;(B)=sum register, (C)=max digit count. 
c008 7e			DECODE1:LD	A,(HL) 
c009 fe 20			CP	' '		;a space terminates the numeral. 
c00b ca 33 c0			JP	Z,DECODE3 
c00e 23				INC	HL 
c00f d6 30			SUB	'0'		;make binary from ascii. 
c011 fe 0a			CP	10		;legal digit? 
c013 d2 09 be			JP	NC,SYNERR 
c016 57				LD	D,A		;yes, save it in (D). 
c017 78				LD	A,B		;compute (B)=(B)*10 and check for overflow. 
c018 e6 e0			AND	0E0H 
c01a c2 09 be			JP	NZ,SYNERR 
c01d 78				LD	A,B 
c01e 07				RLCA	 
c01f 07				RLCA	 
c020 07				RLCA			;(A)=(B)*8 
c021 80				ADD	A,B		;.......*9 
c022 da 09 be			JP	C,SYNERR 
c025 80				ADD	A,B		;.......*10 
c026 da 09 be			JP	C,SYNERR 
c029 82				ADD	A,D		;add in new digit now. 
c02a da 09 be		DECODE2:JP	C,SYNERR 
c02d 47				LD	B,A		;and save result. 
c02e 0d				DEC	C		;only look at 11 digits. 
c02f c2 08 c0			JP	NZ,DECODE1 
c032 c9				RET	 
c033 7e			DECODE3:LD	A,(HL)		;spaces must follow (why?). 
c034 fe 20			CP	' ' 
c036 c2 09 be			JP	NZ,SYNERR 
c039 23				INC	HL 
c03a 0d			DECODE4:DEC	C 
c03b c2 33 c0			JP	NZ,DECODE3 
c03e 78				LD	A,B		;set (A)=the numeric value entered. 
c03f c9				RET	 
c040			; 
c040			;   Move 3 bytes from (HL) to (DE). Note that there is only 
c040			; one reference to this at (A2D5h). 
c040			; 
c040 06 03		MOVE3:	LD	B,3 
c042			; 
c042			;   Move (B) bytes from (HL) to (DE). 
c042			; 
c042 7e			HL2DE:	LD	A,(HL) 
c043 12				LD	(DE),A 
c044 23				INC	HL 
c045 13				INC	DE 
c046 05				DEC	B 
c047 c2 42 c0			JP	NZ,HL2DE 
c04a c9				RET	 
c04b			; 
c04b			;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here. 
c04b			; 
c04b 21 80 00		EXTRACT:LD	HL,TBUFF 
c04e 81				ADD	A,C 
c04f cd 59 be			CALL	ADDHL 
c052 7e				LD	A,(HL) 
c053 c9				RET	 
c054			; 
c054			;  Check drive specified. If it means a change, then the new 
c054			; drive will be selected. In any case, the drive byte of the 
c054			; fcb will be set to null (means use current drive). 
c054			; 
c054 af			DSELECT:XOR	A		;null out first byte of fcb. 
c055 32 d2 c3			LD	(FCB),A 
c058 3a f5 c3			LD	A,(CHGDRV)	;a drive change indicated? 
c05b b7				OR	A 
c05c c8				RET	Z 
c05d 3d				DEC	A		;yes, is it the same as the current drive? 
c05e 21 f4 c3			LD	HL,CDRIVE 
c061 be				CP	(HL) 
c062 c8				RET	Z 
c063 c3 bd bc			JP	DSKSEL		;no. Select it then. 
c066			; 
c066			;   Check the drive selection and reset it to the previous 
c066			; drive if it was changed for the preceeding command. 
c066			; 
c066 3a f5 c3		RESETDR:LD	A,(CHGDRV)	;drive change indicated? 
c069 b7				OR	A 
c06a c8				RET	Z 
c06b 3d				DEC	A		;yes, was it a different drive? 
c06c 21 f4 c3			LD	HL,CDRIVE 
c06f be				CP	(HL) 
c070 c8				RET	Z 
c071 3a f4 c3			LD	A,(CDRIVE)	;yes, re-select our old drive. 
c074 c3 bd bc			JP	DSKSEL 
c077			; 
c077			;************************************************************** 
c077			;* 
c077			;*           D I R E C T O R Y   C O M M A N D 
c077			;* 
c077			;************************************************************** 
c077			; 
c077 cd 5e be		DIRECT:	CALL	CONVFST		;convert file name. 
c07a cd 54 c0			CALL	DSELECT		;select indicated drive. 
c07d 21 d3 c3			LD	HL,FCB+1	;was any file indicated? 
c080 7e				LD	A,(HL) 
c081 fe 20			CP	' ' 
c083 c2 8f c0			JP	NZ,DIRECT2 
c086 06 0b			LD	B,11		;no. Fill field with '?' - same as *.*. 
c088 36 3f		DIRECT1:LD	(HL),'?' 
c08a 23				INC	HL 
c08b 05				DEC	B 
c08c c2 88 c0			JP	NZ,DIRECT1 
c08f 1e 00		DIRECT2:LD	E,0		;set initial cursor position. 
c091 d5				PUSH	DE 
c092 cd e9 bc			CALL	SRCHFCB		;get first file name. 
c095 cc ea bf			CALL	Z,NONE		;none found at all? 
c098 ca 20 c1		DIRECT3:JP	Z,DIRECT9	;terminate if no more names. 
c09b 3a f3 c3			LD	A,(RTNCODE)	;get file's position in segment (0-3). 
c09e 0f				RRCA	 
c09f 0f				RRCA	 
c0a0 0f				RRCA	 
c0a1 e6 60			AND	60H		;(A)=position*32 
c0a3 4f				LD	C,A 
c0a4 3e 0a			LD	A,10 
c0a6 cd 4b c0			CALL	EXTRACT		;extract the tenth entry in fcb. 
c0a9 17				RLA			;check system file status bit. 
c0aa da 14 c1			JP	C,DIRECT8	;we don't list them. 
c0ad d1				POP	DE 
c0ae 7b				LD	A,E		;bump name count. 
c0af 1c				INC	E 
c0b0 d5				PUSH	DE 
c0b1			;_______patch for STM32ZXCPM 3 column dir 
c0b1			DRECT32: 
c0b1 d6 03			SUB	03H 
c0b3 d2 b1 c0			JP	NC, DRECT32 
c0b6 c6 03			ADD	03H 
c0b8			;	AND	03H 
c0b8			;_______end of patch 
c0b8 f5				PUSH	AF 
c0b9 c2 d1 c0			JP	NZ,DIRECT4		;at end of line? 
c0bc cd 98 bc			CALL	CRLF		;yes, end this line and start another. 
c0bf c5				PUSH	BC 
c0c0 cd d0 bd			CALL	GETDSK		;start line with ('A:'). 
c0c3 c1				POP	BC 
c0c4 c6 41			ADD	A,'A' 
c0c6 cd 92 bc			CALL	PRINTB 
c0c9 3e 3a			LD	A,':' 
c0cb cd 92 bc			CALL	PRINTB 
c0ce c3 d9 c0			JP	DIRECT5 
c0d1 cd a2 bc		DIRECT4:CALL	SPACE		;add seperator between file names. 
c0d4 3e 3a			LD	A,':' 
c0d6 cd 92 bc			CALL	PRINTB 
c0d9 cd a2 bc		DIRECT5:CALL	SPACE 
c0dc 06 01			LD	B,1		;'extract' each file name character at a time. 
c0de 78			DIRECT6:LD	A,B 
c0df cd 4b c0			CALL	EXTRACT 
c0e2 e6 7f			AND	7FH		;strip bit 7 (status bit). 
c0e4 fe 20			CP	' '		;are we at the end of the name? 
c0e6 c2 fe c0			JP	NZ,DRECT65 
c0e9 f1				POP	AF		;yes, don't print spaces at the end of a line. 
c0ea f5				PUSH	AF 
c0eb fe 02			CP	2 
c0ed c2 fc c0			JP	NZ,DRECT63 
c0f0 3e 09			LD	A,9		;first check for no extension. 
c0f2 cd 4b c0			CALL	EXTRACT 
c0f5 e6 7f			AND	7FH 
c0f7 fe 20			CP	' ' 
c0f9 ca 13 c1			JP	Z,DIRECT7	;don't print spaces. 
c0fc 3e 20		DRECT63:LD	A,' '		;else print them. 
c0fe cd 92 bc		DRECT65:CALL	PRINTB 
c101 04				INC	B		;bump to next character psoition. 
c102 78				LD	A,B 
c103 fe 0c			CP	12		;end of the name? 
c105 d2 13 c1			JP	NC,DIRECT7 
c108 fe 09			CP	9		;nope, starting extension? 
c10a c2 de c0			JP	NZ,DIRECT6 
c10d cd a2 bc			CALL	SPACE		;yes, add seperating space. 
c110 c3 de c0			JP	DIRECT6 
c113 f1			DIRECT7:POP	AF		;get the next file name. 
c114 cd c2 bd		DIRECT8:CALL	CHKCON		;first check console, quit on anything. 
c117 c2 20 c1			JP	NZ,DIRECT9 
c11a cd e4 bc			CALL	SRCHNXT		;get next name. 
c11d c3 98 c0			JP	DIRECT3		;and continue with our list. 
c120 d1			DIRECT9:POP	DE		;restore the stack and return to command level. 
c121 c3 8b c3			JP	GETBACK 
c124			; 
c124			;************************************************************** 
c124			;* 
c124			;*                E R A S E   C O M M A N D 
c124			;* 
c124			;************************************************************** 
c124			; 
c124 cd 5e be		ERASE:	CALL	CONVFST		;convert file name. 
c127 fe 0b			CP	11		;was '*.*' entered? 
c129 c2 47 c1			JP	NZ,ERASE1 
c12c 01 57 c1			LD	BC,YESNO	;yes, ask for confirmation. 
c12f cd a7 bc			CALL	PLINE 
c132 cd 39 bd			CALL	GETINP 
c135 21 07 bc			LD	HL,INBUFF+1 
c138 35				DEC	(HL)		;must be exactly 'y'. 
c139 c2 82 bf			JP	NZ,CMMND1 
c13c 23				INC	HL 
c13d 7e				LD	A,(HL) 
c13e fe 59			CP	'Y' 
c140 c2 82 bf			JP	NZ,CMMND1 
c143 23				INC	HL 
c144 22 88 bc			LD	(INPOINT),HL	;save input line pointer. 
c147 cd 54 c0		ERASE1:	CALL	DSELECT		;select desired disk. 
c14a 11 d2 c3			LD	DE,FCB 
c14d cd ef bc			CALL	DELETE		;delete the file. 
c150 3c				INC	A 
c151 cc ea bf			CALL	Z,NONE		;not there? 
c154 c3 8b c3			JP	GETBACK		;return to command level now. 
c157 .. 00		YESNO:	DEFB	'All (y/n)?',0 
c162			; 
c162			;************************************************************** 
c162			;* 
c162			;*            T Y P E   C O M M A N D 
c162			;* 
c162			;************************************************************** 
c162			; 
c162 cd 5e be		TYPE:	CALL	CONVFST		;convert file name. 
c165 c2 09 be			JP	NZ,SYNERR	;wild cards not allowed. 
c168 cd 54 c0			CALL	DSELECT		;select indicated drive. 
c16b cd d0 bc			CALL	OPENFCB		;open the file. 
c16e ca ac c1			JP	Z,TYPE5		;not there? 
c171 cd 98 bc			CALL	CRLF		;ok, start a new line on the screen. 
c174 21 f6 c3			LD	HL,NBYTES	;initialize byte counter. 
c177 36 ff			LD	(HL),0FFH	;set to read first sector. 
c179 21 f6 c3		TYPE1:	LD	HL,NBYTES 
c17c 7e			TYPE2:	LD	A,(HL)		;have we written the entire sector? 
c17d fe 80			CP	128 
c17f da 8c c1			JP	C,TYPE3 
c182 e5				PUSH	HL		;yes, read in the next one. 
c183 cd fe bc			CALL	READFCB 
c186 e1				POP	HL 
c187 c2 a5 c1			JP	NZ,TYPE4	;end or error? 
c18a af				XOR	A		;ok, clear byte counter. 
c18b 77				LD	(HL),A 
c18c 34			TYPE3:	INC	(HL)		;count this byte. 
c18d 21 80 00			LD	HL,TBUFF	;and get the (A)th one from the buffer (TBUFF). 
c190 cd 59 be			CALL	ADDHL 
c193 7e				LD	A,(HL) 
c194 fe 1a			CP	CNTRLZ		;end of file mark? 
c196 ca 8b c3			JP	Z,GETBACK 
c199 cd 8c bc			CALL	PRINT		;no, print it. 
c19c cd c2 bd			CALL	CHKCON		;check console, quit if anything ready. 
c19f c2 8b c3			JP	NZ,GETBACK 
c1a2 c3 79 c1			JP	TYPE1 
c1a5			; 
c1a5			;   Get here on an end of file or read error. 
c1a5			; 
c1a5 3d			TYPE4:	DEC	A		;read error? 
c1a6 ca 8b c3			JP	Z,GETBACK 
c1a9 cd d9 bf			CALL	RDERROR		;yes, print message. 
c1ac cd 66 c0		TYPE5:	CALL	RESETDR		;and reset proper drive 
c1af c3 09 be			JP	SYNERR		;now print file name with problem. 
c1b2			; 
c1b2			;************************************************************** 
c1b2			;* 
c1b2			;*            S A V E   C O M M A N D 
c1b2			;* 
c1b2			;************************************************************** 
c1b2			; 
c1b2 cd f8 bf		SAVE:	CALL	DECODE		;get numeric number that follows SAVE. 
c1b5 f5				PUSH	AF		;save number of pages to write. 
c1b6 cd 5e be			CALL	CONVFST		;convert file name. 
c1b9 c2 09 be			JP	NZ,SYNERR	;wild cards not allowed. 
c1bc cd 54 c0			CALL	DSELECT		;select specified drive. 
c1bf 11 d2 c3			LD	DE,FCB		;now delete this file. 
c1c2 d5				PUSH	DE 
c1c3 cd ef bc			CALL	DELETE 
c1c6 d1				POP	DE 
c1c7 cd 09 bd			CALL	CREATE		;and create it again. 
c1ca ca 00 c2			JP	Z,SAVE3		;can't create? 
c1cd af				XOR	A		;clear record number byte. 
c1ce 32 f2 c3			LD	(FCB+32),A 
c1d1 f1				POP	AF		;convert pages to sectors. 
c1d2 6f				LD	L,A 
c1d3 26 00			LD	H,0 
c1d5 29				ADD	HL,HL		;(HL)=number of sectors to write. 
c1d6 11 00 01			LD	DE,TBASE	;and we start from here. 
c1d9 7c			SAVE1:	LD	A,H		;done yet? 
c1da b5				OR	L 
c1db ca f6 c1			JP	Z,SAVE2 
c1de 2b				DEC	HL		;nope, count this and compute the start 
c1df e5				PUSH	HL		;of the next 128 byte sector. 
c1e0 21 80 00			LD	HL,128 
c1e3 19				ADD	HL,DE 
c1e4 e5				PUSH	HL		;save it and set the transfer address. 
c1e5 cd d8 bd			CALL	DMASET 
c1e8 11 d2 c3			LD	DE,FCB		;write out this sector now. 
c1eb cd 04 bd			CALL	WRTREC 
c1ee d1				POP	DE		;reset (DE) to the start of the last sector. 
c1ef e1				POP	HL		;restore sector count. 
c1f0 c2 00 c2			JP	NZ,SAVE3	;write error? 
c1f3 c3 d9 c1			JP	SAVE1 
c1f6			; 
c1f6			;   Get here after writing all of the file. 
c1f6			; 
c1f6 11 d2 c3		SAVE2:	LD	DE,FCB		;now close the file. 
c1f9 cd da bc			CALL	CLOSE 
c1fc 3c				INC	A		;did it close ok? 
c1fd c2 06 c2			JP	NZ,SAVE4 
c200			; 
c200			;   Print out error message (no space). 
c200			; 
c200 01 0c c2		SAVE3:	LD	BC,NOSPACE 
c203 cd a7 bc			CALL	PLINE 
c206 cd d5 bd		SAVE4:	CALL	STDDMA		;reset the standard dma address. 
c209 c3 8b c3			JP	GETBACK 
c20c .. 00		NOSPACE:DEFB	'No space',0 
c215			; 
c215			;************************************************************** 
c215			;* 
c215			;*           R E N A M E   C O M M A N D 
c215			;* 
c215			;************************************************************** 
c215			; 
c215 cd 5e be		RENAME:	CALL	CONVFST		;convert first file name. 
c218 c2 09 be			JP	NZ,SYNERR	;wild cards not allowed. 
c21b 3a f5 c3			LD	A,(CHGDRV)	;remember any change in drives specified. 
c21e f5				PUSH	AF 
c21f cd 54 c0			CALL	DSELECT		;and select this drive. 
c222 cd e9 bc			CALL	SRCHFCB		;is this file present? 
c225 c2 7e c2			JP	NZ,RENAME6	;yes, print error message. 
c228 21 d2 c3			LD	HL,FCB		;yes, move this name into second slot. 
c22b 11 e2 c3			LD	DE,FCB+16 
c22e 06 10			LD	B,16 
c230 cd 42 c0			CALL	HL2DE 
c233 2a 88 bc			LD	HL,(INPOINT)	;get input pointer. 
c236 eb				EX	DE,HL 
c237 cd 4f be			CALL	NONBLANK	;get next non blank character. 
c23a fe 3d			CP	'='		;only allow an '=' or '_' seperator. 
c23c ca 44 c2			JP	Z,RENAME1 
c23f fe 5f			CP	'_' 
c241 c2 78 c2			JP	NZ,RENAME5 
c244 eb			RENAME1:EX	DE,HL 
c245 23				INC	HL		;ok, skip seperator. 
c246 22 88 bc			LD	(INPOINT),HL	;save input line pointer. 
c249 cd 5e be			CALL	CONVFST		;convert this second file name now. 
c24c c2 78 c2			JP	NZ,RENAME5	;again, no wild cards. 
c24f f1				POP	AF		;if a drive was specified, then it 
c250 47				LD	B,A		;must be the same as before. 
c251 21 f5 c3			LD	HL,CHGDRV 
c254 7e				LD	A,(HL) 
c255 b7				OR	A 
c256 ca 5e c2			JP	Z,RENAME2 
c259 b8				CP	B 
c25a 70				LD	(HL),B 
c25b c2 78 c2			JP	NZ,RENAME5	;they were different, error. 
c25e 70			RENAME2:LD	(HL),B		;	reset as per the first file specification. 
c25f af				XOR	A 
c260 32 d2 c3			LD	(FCB),A		;clear the drive byte of the fcb. 
c263 cd e9 bc		RENAME3:CALL	SRCHFCB		;and go look for second file. 
c266 ca 72 c2			JP	Z,RENAME4	;doesn't exist? 
c269 11 d2 c3			LD	DE,FCB 
c26c cd 0e bd			CALL	RENAM		;ok, rename the file. 
c26f c3 8b c3			JP	GETBACK 
c272			; 
c272			;   Process rename errors here. 
c272			; 
c272 cd ea bf		RENAME4:CALL	NONE		;file not there. 
c275 c3 8b c3			JP	GETBACK 
c278 cd 66 c0		RENAME5:CALL	RESETDR		;bad command format. 
c27b c3 09 be			JP	SYNERR 
c27e 01 87 c2		RENAME6:LD	BC,EXISTS	;destination file already exists. 
c281 cd a7 bc			CALL	PLINE 
c284 c3 8b c3			JP	GETBACK 
c287 .. 00		EXISTS:	DEFB	'File exists',0 
c293			; 
c293			;************************************************************** 
c293			;* 
c293			;*             U S E R   C O M M A N D 
c293			;* 
c293			;************************************************************** 
c293			; 
c293 cd f8 bf		USER:	CALL	DECODE		;get numeric value following command. 
c296 fe 10			CP	16		;legal user number? 
c298 d2 09 be			JP	NC,SYNERR 
c29b 5f				LD	E,A		;yes but is there anything else? 
c29c 3a d3 c3			LD	A,(FCB+1) 
c29f fe 20			CP	' ' 
c2a1 ca 09 be			JP	Z,SYNERR	;yes, that is not allowed. 
c2a4 cd 15 bd			CALL	GETSETUC	;ok, set user code. 
c2a7 c3 8e c3			JP	GETBACK1 
c2aa			; 
c2aa			;************************************************************** 
c2aa			;* 
c2aa			;*        T R A N S I A N T   P R O G R A M   C O M M A N D 
c2aa			;* 
c2aa			;************************************************************** 
c2aa			; 
c2aa cd f5 bd		UNKNOWN:CALL	VERIFY		;check for valid system (why?). 
c2ad 3a d3 c3			LD	A,(FCB+1)	;anything to execute? 
c2b0 fe 20			CP	' ' 
c2b2 c2 c9 c2			JP	NZ,UNKWN1 
c2b5 3a f5 c3			LD	A,(CHGDRV)	;nope, only a drive change? 
c2b8 b7				OR	A 
c2b9 ca 8e c3			JP	Z,GETBACK1	;neither??? 
c2bc 3d				DEC	A 
c2bd 32 f4 c3			LD	(CDRIVE),A	;ok, store new drive. 
c2c0 cd 29 bd			CALL	MOVECD		;set (TDRIVE) also. 
c2c3 cd bd bc			CALL	DSKSEL		;and select this drive. 
c2c6 c3 8e c3			JP	GETBACK1	;then return. 
c2c9			; 
c2c9			;   Here a file name was typed. Prepare to execute it. 
c2c9			; 
c2c9 11 db c3		UNKWN1:	LD	DE,FCB+9	;an extension specified? 
c2cc 1a				LD	A,(DE) 
c2cd fe 20			CP	' ' 
c2cf c2 09 be			JP	NZ,SYNERR	;yes, not allowed. 
c2d2 d5			UNKWN2:	PUSH	DE 
c2d3 cd 54 c0			CALL	DSELECT		;select specified drive. 
c2d6 d1				POP	DE 
c2d7 21 88 c3			LD	HL,COMFILE	;set the extension to 'COM'. 
c2da cd 40 c0			CALL	MOVE3 
c2dd cd d0 bc			CALL	OPENFCB		;and open this file. 
c2e0 ca f5 d4			JP	Z,ptchda	;not present? 
c2e3			; 
c2e3			;   Load in the program. 
c2e3			; 
c2e3			UNKWN25: 
c2e3 21 00 01			LD	HL,TBASE	;store the program starting here. 
c2e6			UNKWN3: 
c2e6 e5				PUSH	HL 
c2e7 eb				EX	DE,HL 
c2e8 cd d8 bd			CALL	DMASET		;set transfer address. 
c2eb 11 d2 c3			LD	DE,FCB		;and read the next record. 
c2ee cd f9 bc			CALL	RDREC 
c2f1 c2 06 c3			JP	NZ,UNKWN4	;end of file or read error? 
c2f4 e1				POP	HL		;nope, bump pointer for next sector. 
c2f5 11 80 00			LD	DE,128 
c2f8 19				ADD	HL,DE 
c2f9 11 00 bc			LD	DE,CBASE	;enough room for the whole file? 
c2fc 7d				LD	A,L 
c2fd 93				SUB	E 
c2fe 7c				LD	A,H 
c2ff 9a				SBC	A,D 
c300 d2 76 c3			JP	NC,UNKWN0	;no, it can't fit. 
c303 c3 e6 c2			JP	UNKWN3 
c306			; 
c306			;   Get here after finished reading. 
c306			; 
c306 e1			UNKWN4:	POP	HL 
c307 3d				DEC	A		;normal end of file? 
c308 c2 76 c3			JP	NZ,UNKWN0 
c30b cd 66 c0			CALL	RESETDR		;yes, reset previous drive. 
c30e cd 5e be			CALL	CONVFST		;convert the first file name that follows 
c311 21 f5 c3			LD	HL,CHGDRV	;command name. 
c314 e5				PUSH	HL 
c315 7e				LD	A,(HL)		;set drive code in default fcb. 
c316 32 d2 c3			LD	(FCB),A 
c319 3e 10			LD	A,16		;put second name 16 bytes later. 
c31b cd 60 be			CALL	CONVERT		;convert second file name. 
c31e e1				POP	HL 
c31f 7e				LD	A,(HL)		;and set the drive for this second file. 
c320 32 e2 c3			LD	(FCB+16),A 
c323 af				XOR	A		;clear record byte in fcb. 
c324 32 f2 c3			LD	(FCB+32),A 
c327 11 5c 00			LD	DE,TFCB		;move it into place at(005Ch). 
c32a 21 d2 c3			LD	HL,FCB 
c32d 06 21			LD	B,33 
c32f cd 42 c0			CALL	HL2DE 
c332 21 08 bc			LD	HL,INBUFF+2	;now move the remainder of the input 
c335 7e			UNKWN5:	LD	A,(HL)		;line down to (0080h). Look for a non blank. 
c336 b7				OR	A		;or a null. 
c337 ca 43 c3			JP	Z,UNKWN6 
c33a fe 20			CP	' ' 
c33c ca 43 c3			JP	Z,UNKWN6 
c33f 23				INC	HL 
c340 c3 35 c3			JP	UNKWN5 
c343			; 
c343			;   Do the line move now. It ends in a null byte. 
c343			; 
c343 06 00		UNKWN6:	LD	B,0		;keep a character count. 
c345 11 81 00			LD	DE,TBUFF+1	;data gets put here. 
c348 7e			UNKWN7:	LD	A,(HL)		;move it now. 
c349 12				LD	(DE),A 
c34a b7				OR	A 
c34b ca 54 c3			JP	Z,UNKWN8 
c34e 04				INC	B 
c34f 23				INC	HL 
c350 13				INC	DE 
c351 c3 48 c3			JP	UNKWN7 
c354 78			UNKWN8:	LD	A,B		;now store the character count. 
c355 32 80 00			LD	(TBUFF),A 
c358 cd 98 bc			CALL	CRLF		;clean up the screen. 
c35b cd d5 bd			CALL	STDDMA		;set standard transfer address. 
c35e cd 1a bd			CALL	SETCDRV		;reset current drive. 
c361 cd 00 01			CALL	TBASE		;and execute the program. 
c364			; 
c364			;   Transiant programs return here (or reboot). 
c364			; 
c364 31 b0 c3			LD	SP,BATCH	;set stack first off. 
c367 cd 29 bd			CALL	MOVECD		;move current drive into place (TDRIVE). 
c36a cd bd bc			CALL	DSKSEL		;and reselect it. 
c36d c3 82 bf			JP	CMMND1		;back to comand mode. 
c370			; 
c370			;   Get here if some error occured. 
c370			; 
c370 cd 66 c0		UNKWN9:	CALL	RESETDR		;inproper format. 
c373 c3 09 be			JP	SYNERR 
c376 01 7f c3		UNKWN0:	LD	BC,BADLOAD	;read error or won't fit. 
c379 cd a7 bc			CALL	PLINE 
c37c c3 8b c3			JP	GETBACK 
c37f .. 00		BADLOAD:DEFB	'Bad load',0 
c388 ..			COMFILE:DEFB	'COM'		;command file extension. 
c38b			; 
c38b			;   Get here to return to command level. We will reset the 
c38b			; previous active drive and then either return to command 
c38b			; level directly or print error message and then return. 
c38b			; 
c38b cd 66 c0		GETBACK:CALL	RESETDR		;reset previous drive. 
c38e cd 5e be		GETBACK1: CALL	CONVFST		;convert first name in (FCB). 
c391 3a d3 c3			LD	A,(FCB+1)	;if this was just a drive change request, 
c394 d6 20			SUB	' '		;make sure it was valid. 
c396 21 f5 c3			LD	HL,CHGDRV 
c399 b6				OR	(HL) 
c39a c2 09 be			JP	NZ,SYNERR 
c39d c3 82 bf			JP	CMMND1		;ok, return to command level. 
c3a0			; 
c3a0			;   ccp stack area. 
c3a0			; 
c3a0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 
c3b0			CCPSTACK:EQU	$	;end of ccp stack area. 
c3b0			; 
c3b0			;   Batch (or SUBMIT) processing information storage. 
c3b0			; 
c3b0 00			BATCH:	DEFB	0		;batch mode flag (0=not active). 
c3b1 00 .. 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00	BATCHFCB: DEFB	0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 
c3d2			; 
c3d2			;   File control block setup by the CCP. 
c3d2			; 
c3d2 00 .. 00 00 00 00 00 .. 00 00 00 00 00	FCB:	DEFB	0,'           ',0,0,0,0,0,'           ',0,0,0,0,0 
c3f3 00			RTNCODE:DEFB	0		;status returned from bdos call. 
c3f4 00			CDRIVE:	DEFB	0		;currently active drive. 
c3f5 00			CHGDRV:	DEFB	0		;change in drives flag (0=no change). 
c3f6 00 00		NBYTES:	DEFW	0		;byte counter used by TYPE. 
c3f8			; 
c3f8			;   Room for expansion? 
c3f8			; 
c3f8 00 00 00 00 00 00 00 00		DEFB	0,0,0,0,0,0,0,0 
c400			; 
c400			;   Note that the following six bytes must match those at 
c400			; (PATTRN1) or cp/m will HALT. Why? 
c400			; 
c400 00 16 00 00 00 00	PATTRN2:DEFB	0,22,0,0,0,0	;(* serial number bytes *). 
c406			; 
c406			;************************************************************** 
c406			;* 
c406			;*                    B D O S   E N T R Y 
c406			;* 
c406			;************************************************************** 
c406			; 
c406 c3 11 c4		FBASE:	JP	FBASE1 
c409			; 
c409			;   Bdos error table. 
c409			; 
c409 99 c4		BADSCTR:DEFW	ERROR1		;bad sector on read or write. 
c40b a5 c4		BADSLCT:DEFW	ERROR2		;bad disk select. 
c40d ab c4		RODISK:	DEFW	ERROR3		;disk is read only. 
c40f b1 c4		ROFILE:	DEFW	ERROR4		;file is read only. 
c411			; 
c411			;   Entry into bdos. (DE) or (E) are the parameters passed. The 
c411			; function number desired is in register (C). 
c411			; 
c411 eb			FBASE1:	EX	DE,HL		;save the (DE) parameters. 
c412 22 43 c7			LD	(PARAMS),HL 
c415 eb				EX	DE,HL 
c416 7b				LD	A,E		;and save register (E) in particular. 
c417 32 d6 d1			LD	(EPARAM),A 
c41a 21 00 00			LD	HL,0 
c41d 22 45 c7			LD	(STATUS),HL	;clear return status. 
c420 39				ADD	HL,SP 
c421 22 0f c7			LD	(USRSTACK),HL	;save users stack pointer. 
c424 31 41 c7			LD	SP,STKAREA	;and set our own. 
c427 af				XOR	A		;clear auto select storage space. 
c428 32 e0 d1			LD	(AUTOFLAG),A 
c42b 32 de d1			LD	(AUTO),A 
c42e 21 74 d1			LD	HL,GOBACK	;set return address. 
c431 e5				PUSH	HL 
c432 79				LD	A,C		;get function number. 
c433 fe 29			CP	NFUNCTS		;valid function number? 
c435 d0				RET	NC 
c436 4b				LD	C,E		;keep single register function here. 
c437 21 47 c4			LD	HL,FUNCTNS	;now look thru the function table. 
c43a 5f				LD	E,A 
c43b 16 00			LD	D,0		;(DE)=function number. 
c43d 19				ADD	HL,DE 
c43e 19				ADD	HL,DE		;(HL)=(start of table)+2*(function number). 
c43f 5e				LD	E,(HL) 
c440 23				INC	HL 
c441 56				LD	D,(HL)		;now (DE)=address for this function. 
c442 2a 43 c7			LD	HL,(PARAMS)	;retrieve parameters. 
c445 eb				EX	DE,HL		;now (DE) has the original parameters. 
c446 e9				JP	(HL)		;execute desired function. 
c447			; 
c447			;   BDOS function jump table. 
c447			; 
c447			NFUNCTS:EQU	41		;number of functions in followin table. 
c447			; 
c447 cf d3 c8 c6 90 c5 ce c6 73 d4 6f d4 d4 c6 ed c6	FUNCTNS:DEFW	WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB 
c457 f3 c6 f8 c6 e1 c5 fe c6 7e d0 83 d0 45 d0 9c d0		DEFW	SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL 
c467 a5 d0 ab d0 c8 d0 d7 d0 e0 d0 e6 d0 ec d0		DEFW	CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE 
c475 f5 d0 fe d0 04 d1 0a d1 11 d1 2c c9 17 d1 1d d1		DEFW	RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR 
c485 26 d1 2d d1 41 d1 47 d1 4d d1 0e d0 53 d1 04 c7		DEFW	GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN 
c495 04 c7 9b d1		DEFW	RTN,WTSPECL 
c499			; 
c499			;   Bdos error message section. 
c499			; 
c499 21 ca c4		ERROR1:	LD	HL,BADSEC	;bad sector message. 
c49c cd e5 c4			CALL	PRTERR		;print it and get a 1 char responce. 
c49f fe 03			CP	CNTRLC		;re-boot request (control-c)? 
c4a1 ca 00 00			JP	Z,0		;yes. 
c4a4 c9				RET			;no, return to retry i/o function. 
c4a5			; 
c4a5 21 d5 c4		ERROR2:	LD	HL,BADSEL	;bad drive selected. 
c4a8 c3 b4 c4			JP	ERROR5 
c4ab			; 
c4ab 21 e1 c4		ERROR3:	LD	HL,DISKRO	;disk is read only. 
c4ae c3 b4 c4			JP	ERROR5 
c4b1			; 
c4b1 21 dc c4		ERROR4:	LD	HL,FILERO	;file is read only. 
c4b4			; 
c4b4 cd e5 c4		ERROR5:	CALL	PRTERR 
c4b7 c3 00 00			JP	0		;always reboot on these errors. 
c4ba			; 
c4ba ..			BDOSERR:DEFB	'Bdos Err On ' 
c4c6 ..			BDOSDRV:DEFB	' : $' 
c4ca ..			BADSEC:	DEFB	'Bad Sector$' 
c4d5 ..			BADSEL:	DEFB	'Select$' 
c4dc ..			FILERO:	DEFB	'File ' 
c4e1 ..			DISKRO:	DEFB	'R/O$' 
c4e5			; 
c4e5			;   Print bdos error message. 
c4e5			; 
c4e5 e5			PRTERR:	PUSH	HL		;save second message pointer. 
c4e6 cd c9 c5			CALL	OUTCRLF		;send (cr)(lf). 
c4e9 3a 42 c7			LD	A,(ACTIVE)	;get active drive. 
c4ec c6 41			ADD	A,'A'		;make ascii. 
c4ee 32 c6 c4			LD	(BDOSDRV),A	;and put in message. 
c4f1 01 ba c4			LD	BC,BDOSERR	;and print it. 
c4f4 cd d3 c5			CALL	PRTMESG 
c4f7 c1				POP	BC		;print second message line now. 
c4f8 cd d3 c5			CALL	PRTMESG 
c4fb			; 
c4fb			;   Get an input character. We will check our 1 character 
c4fb			; buffer first. This may be set by the console status routine. 
c4fb			; 
c4fb 21 0e c7		GETCHAR:LD	HL,CHARBUF	;check character buffer. 
c4fe 7e				LD	A,(HL)		;anything present already? 
c4ff 36 00			LD	(HL),0		;...either case clear it. 
c501 b7				OR	A 
c502 c0				RET	NZ		;yes, use it. 
c503 c3 5f d4			JP	CONIN		;nope, go get a character responce. 
c506			; 
c506			;   Input and echo a character. 
c506			; 
c506 cd fb c4		GETECHO:CALL	GETCHAR		;input a character. 
c509 cd 14 c5			CALL	CHKCHAR		;carriage control? 
c50c d8				RET	C		;no, a regular control char so don't echo. 
c50d f5				PUSH	AF		;ok, save character now. 
c50e 4f				LD	C,A 
c50f cd 90 c5			CALL	OUTCON		;and echo it. 
c512 f1				POP	AF		;get character and return. 
c513 c9				RET	 
c514			; 
c514			;   Check character in (A). Set the zero flag on a carriage 
c514			; control character and the carry flag on any other control 
c514			; character. 
c514			; 
c514 fe 0d		CHKCHAR:CP	CR		;check for carriage return, line feed, backspace, 
c516 c8				RET	Z		;or a tab. 
c517 fe 0a			CP	LF 
c519 c8				RET	Z 
c51a fe 09			CP	TAB 
c51c c8				RET	Z 
c51d fe 08			CP	BS 
c51f c8				RET	Z 
c520 fe 20			CP	' '		;other control char? Set carry flag. 
c522 c9				RET	 
c523			; 
c523			;   Check the console during output. Halt on a control-s, then 
c523			; reboot on a control-c. If anything else is ready, clear the 
c523			; zero flag and return (the calling routine may want to do 
c523			; something). 
c523			; 
c523 3a 0e c7		CKCONSOL: LD	A,(CHARBUF)	;check buffer. 
c526 b7				OR	A		;if anything, just return without checking. 
c527 c2 45 c5			JP	NZ,CKCON2 
c52a cd 5c d4			CALL	CONST		;nothing in buffer. Check console. 
c52d e6 01			AND	01H		;look at bit 0. 
c52f c8				RET	Z		;return if nothing. 
c530 cd 5f d4			CALL	CONIN		;ok, get it. 
c533 fe 13			CP	CNTRLS		;if not control-s, return with zero cleared. 
c535 c2 42 c5			JP	NZ,CKCON1 
c538 cd 5f d4			CALL	CONIN		;halt processing until another char 
c53b fe 03			CP	CNTRLC		;is typed. Control-c? 
c53d ca 00 00			JP	Z,0		;yes, reboot now. 
c540 af				XOR	A		;no, just pretend nothing was ever ready. 
c541 c9				RET	 
c542 32 0e c7		CKCON1:	LD	(CHARBUF),A	;save character in buffer for later processing. 
c545 3e 01		CKCON2:	LD	A,1		;set (A) to non zero to mean something is ready. 
c547 c9				RET	 
c548			; 
c548			;   Output (C) to the screen. If the printer flip-flop flag 
c548			; is set, we will send character to printer also. The console 
c548			; will be checked in the process. 
c548			; 
c548 3a 0a c7		OUTCHAR:LD	A,(OUTFLAG)	;check output flag. 
c54b b7				OR	A		;anything and we won't generate output. 
c54c c2 62 c5			JP	NZ,OUTCHR1 
c54f c5				PUSH	BC 
c550 cd 23 c5			CALL	CKCONSOL	;check console (we don't care whats there). 
c553 c1				POP	BC 
c554 c5				PUSH	BC 
c555 cd 6b d4			CALL	CONOUT		;output (C) to the screen. 
c558 c1				POP	BC 
c559 c5				PUSH	BC 
c55a 3a 0d c7			LD	A,(PRTFLAG)	;check printer flip-flop flag. 
c55d b7				OR	A 
c55e c4 6f d4			CALL	NZ,LIST		;print it also if non-zero. 
c561 c1				POP	BC 
c562 79			OUTCHR1:LD	A,C		;update cursors position. 
c563 21 0c c7			LD	HL,CURPOS 
c566 fe 7f			CP	DEL		;rubouts don't do anything here. 
c568 c8				RET	Z 
c569 34				INC	(HL)		;bump line pointer. 
c56a fe 20			CP	' '		;and return if a normal character. 
c56c d0				RET	NC 
c56d 35				DEC	(HL)		;restore and check for the start of the line. 
c56e 7e				LD	A,(HL) 
c56f b7				OR	A 
c570 c8				RET	Z		;ingnore control characters at the start of the line. 
c571 79				LD	A,C 
c572 fe 08			CP	BS		;is it a backspace? 
c574 c2 79 c5			JP	NZ,OUTCHR2 
c577 35				DEC	(HL)		;yes, backup pointer. 
c578 c9				RET	 
c579 fe 0a		OUTCHR2:CP	LF		;is it a line feed? 
c57b c0				RET	NZ		;ignore anything else. 
c57c 36 00			LD	(HL),0		;reset pointer to start of line. 
c57e c9				RET	 
c57f			; 
c57f			;   Output (A) to the screen. If it is a control character 
c57f			; (other than carriage control), use ^x format. 
c57f			; 
c57f 79			SHOWIT:	LD	A,C 
c580 cd 14 c5			CALL	CHKCHAR		;check character. 
c583 d2 90 c5			JP	NC,OUTCON	;not a control, use normal output. 
c586 f5				PUSH	AF 
c587 0e 5e			LD	C,'^'		;for a control character, preceed it with '^'. 
c589 cd 48 c5			CALL	OUTCHAR 
c58c f1				POP	AF 
c58d f6 40			OR	'@'		;and then use the letter equivelant. 
c58f 4f				LD	C,A 
c590			; 
c590			;   Function to output (C) to the console device and expand tabs 
c590			; if necessary. 
c590			; 
c590 79			OUTCON:	LD	A,C 
c591 fe 09			CP	TAB		;is it a tab? 
c593 c2 48 c5			JP	NZ,OUTCHAR	;use regular output. 
c596 0e 20		OUTCON1:LD	C,' '		;yes it is, use spaces instead. 
c598 cd 48 c5			CALL	OUTCHAR 
c59b 3a 0c c7			LD	A,(CURPOS)	;go until the cursor is at a multiple of 8 
c59e			 
c59e e6 07			AND	07H		;position. 
c5a0 c2 96 c5			JP	NZ,OUTCON1 
c5a3 c9				RET	 
c5a4			; 
c5a4			;   Echo a backspace character. Erase the prevoius character 
c5a4			; on the screen. 
c5a4			; 
c5a4 cd ac c5		BACKUP:	CALL	BACKUP1		;backup the screen 1 place. 
c5a7 0e 20			LD	C,' '		;then blank that character. 
c5a9 cd 6b d4			CALL	CONOUT 
c5ac 0e 08		BACKUP1:LD	C,BS		;then back space once more. 
c5ae c3 6b d4			JP	CONOUT 
c5b1			; 
c5b1			;   Signal a deleted line. Print a '#' at the end and start 
c5b1			; over. 
c5b1			; 
c5b1 0e 23		NEWLINE:LD	C,'#' 
c5b3 cd 48 c5			CALL	OUTCHAR		;print this. 
c5b6 cd c9 c5			CALL	OUTCRLF		;start new line. 
c5b9 3a 0c c7		NEWLN1:	LD	A,(CURPOS)	;move the cursor to the starting position. 
c5bc 21 0b c7			LD	HL,STARTING 
c5bf be				CP	(HL) 
c5c0 d0				RET	NC		;there yet? 
c5c1 0e 20			LD	C,' ' 
c5c3 cd 48 c5			CALL	OUTCHAR		;nope, keep going. 
c5c6 c3 b9 c5			JP	NEWLN1 
c5c9			; 
c5c9			;   Output a (cr) (lf) to the console device (screen). 
c5c9			; 
c5c9 0e 0d		OUTCRLF:LD	C,CR 
c5cb cd 48 c5			CALL	OUTCHAR 
c5ce 0e 0a			LD	C,LF 
c5d0 c3 48 c5			JP	OUTCHAR 
c5d3			; 
c5d3			;   Print message pointed to by (BC). It will end with a '$'. 
c5d3			; 
c5d3 0a			PRTMESG:LD	A,(BC)		;check for terminating character. 
c5d4 fe 24			CP	'$' 
c5d6 c8				RET	Z 
c5d7 03				INC	BC 
c5d8 c5				PUSH	BC		;otherwise, bump pointer and print it. 
c5d9 4f				LD	C,A 
c5da cd 90 c5			CALL	OUTCON 
c5dd c1				POP	BC 
c5de c3 d3 c5			JP	PRTMESG 
c5e1			; 
c5e1			;   Function to execute a buffered read. 
c5e1			; 
c5e1 3a 0c c7		RDBUFF:	LD	A,(CURPOS)	;use present location as starting one. 
c5e4 32 0b c7			LD	(STARTING),A 
c5e7 2a 43 c7			LD	HL,(PARAMS)	;get the maximum buffer space. 
c5ea 4e				LD	C,(HL) 
c5eb 23				INC	HL		;point to first available space. 
c5ec e5				PUSH	HL		;and save. 
c5ed 06 00			LD	B,0		;keep a character count. 
c5ef c5			RDBUF1:	PUSH	BC 
c5f0 e5				PUSH	HL 
c5f1 cd fb c4		RDBUF2:	CALL	GETCHAR		;get the next input character. 
c5f4 e6 7f			AND	7FH		;strip bit 7. 
c5f6 e1				POP	HL		;reset registers. 
c5f7 c1				POP	BC 
c5f8 fe 0d			CP	CR		;en of the line? 
c5fa ca c1 c6			JP	Z,RDBUF17 
c5fd fe 0a			CP	LF 
c5ff ca c1 c6			JP	Z,RDBUF17 
c602 fe 08			CP	BS		;how about a backspace? 
c604 c2 16 c6			JP	NZ,RDBUF3 
c607 78				LD	A,B		;yes, but ignore at the beginning of the line. 
c608 b7				OR	A 
c609 ca ef c5			JP	Z,RDBUF1 
c60c 05				DEC	B		;ok, update counter. 
c60d 3a 0c c7			LD	A,(CURPOS)	;if we backspace to the start of the line, 
c610 32 0a c7			LD	(OUTFLAG),A	;treat as a cancel (control-x). 
c613 c3 70 c6			JP	RDBUF10 
c616 fe 7f		RDBUF3:	CP	DEL		;user typed a rubout? 
c618 c2 26 c6			JP	NZ,RDBUF4 
c61b 78				LD	A,B		;ignore at the start of the line. 
c61c b7				OR	A 
c61d ca ef c5			JP	Z,RDBUF1 
c620 7e				LD	A,(HL)		;ok, echo the prevoius character. 
c621 05				DEC	B		;and reset pointers (counters). 
c622 2b				DEC	HL 
c623 c3 a9 c6			JP	RDBUF15 
c626 fe 05		RDBUF4:	CP	CNTRLE		;physical end of line? 
c628 c2 37 c6			JP	NZ,RDBUF5 
c62b c5				PUSH	BC		;yes, do it. 
c62c e5				PUSH	HL 
c62d cd c9 c5			CALL	OUTCRLF 
c630 af				XOR	A		;and update starting position. 
c631 32 0b c7			LD	(STARTING),A 
c634 c3 f1 c5			JP	RDBUF2 
c637 fe 10		RDBUF5:	CP	CNTRLP		;control-p? 
c639 c2 48 c6			JP	NZ,RDBUF6 
c63c e5				PUSH	HL		;yes, flip the print flag filp-flop byte. 
c63d 21 0d c7			LD	HL,PRTFLAG 
c640 3e 01			LD	A,1		;PRTFLAG=1-PRTFLAG 
c642 96				SUB	(HL) 
c643 77				LD	(HL),A 
c644 e1				POP	HL 
c645 c3 ef c5			JP	RDBUF1 
c648 fe 18		RDBUF6:	CP	CNTRLX		;control-x (cancel)? 
c64a c2 5f c6			JP	NZ,RDBUF8 
c64d e1				POP	HL 
c64e 3a 0b c7		RDBUF7:	LD	A,(STARTING)	;yes, backup the cursor to here. 
c651 21 0c c7			LD	HL,CURPOS 
c654 be				CP	(HL) 
c655 d2 e1 c5			JP	NC,RDBUFF	;done yet? 
c658 35				DEC	(HL)		;no, decrement pointer and output back up one space. 
c659 cd a4 c5			CALL	BACKUP 
c65c c3 4e c6			JP	RDBUF7 
c65f fe 15		RDBUF8:	CP	CNTRLU		;cntrol-u (cancel line)? 
c661 c2 6b c6			JP	NZ,RDBUF9 
c664 cd b1 c5			CALL	NEWLINE		;start a new line. 
c667 e1				POP	HL 
c668 c3 e1 c5			JP	RDBUFF 
c66b fe 12		RDBUF9:	CP	CNTRLR		;control-r? 
c66d c2 a6 c6			JP	NZ,RDBUF14 
c670 c5			RDBUF10:PUSH	BC		;yes, start a new line and retype the old one. 
c671 cd b1 c5			CALL	NEWLINE 
c674 c1				POP	BC 
c675 e1				POP	HL 
c676 e5				PUSH	HL 
c677 c5				PUSH	BC 
c678 78			RDBUF11:LD	A,B		;done whole line yet? 
c679 b7				OR	A 
c67a ca 8a c6			JP	Z,RDBUF12 
c67d 23				INC	HL		;nope, get next character. 
c67e 4e				LD	C,(HL) 
c67f 05				DEC	B		;count it. 
c680 c5				PUSH	BC 
c681 e5				PUSH	HL 
c682 cd 7f c5			CALL	SHOWIT		;and display it. 
c685 e1				POP	HL 
c686 c1				POP	BC 
c687 c3 78 c6			JP	RDBUF11 
c68a e5			RDBUF12:PUSH	HL		;done with line. If we were displaying 
c68b 3a 0a c7			LD	A,(OUTFLAG)	;then update cursor position. 
c68e b7				OR	A 
c68f ca f1 c5			JP	Z,RDBUF2 
c692 21 0c c7			LD	HL,CURPOS	;because this line is shorter, we must 
c695 96				SUB	(HL)		;back up the cursor (not the screen however) 
c696 32 0a c7			LD	(OUTFLAG),A	;some number of positions. 
c699 cd a4 c5		RDBUF13:CALL	BACKUP		;note that as long as (OUTFLAG) is non 
c69c 21 0a c7			LD	HL,OUTFLAG	;zero, the screen will not be changed. 
c69f 35				DEC	(HL) 
c6a0 c2 99 c6			JP	NZ,RDBUF13 
c6a3 c3 f1 c5			JP	RDBUF2		;now just get the next character. 
c6a6			; 
c6a6			;   Just a normal character, put this in our buffer and echo. 
c6a6			; 
c6a6 23			RDBUF14:INC	HL 
c6a7 77				LD	(HL),A		;store character. 
c6a8 04				INC	B		;and count it. 
c6a9 c5			RDBUF15:PUSH	BC 
c6aa e5				PUSH	HL 
c6ab 4f				LD	C,A		;echo it now. 
c6ac cd 7f c5			CALL	SHOWIT 
c6af e1				POP	HL 
c6b0 c1				POP	BC 
c6b1 7e				LD	A,(HL)		;was it an abort request? 
c6b2 fe 03			CP	CNTRLC		;control-c abort? 
c6b4 78				LD	A,B 
c6b5 c2 bd c6			JP	NZ,RDBUF16 
c6b8 fe 01			CP	1		;only if at start of line. 
c6ba ca 00 00			JP	Z,0 
c6bd b9			RDBUF16:CP	C		;nope, have we filled the buffer? 
c6be da ef c5			JP	C,RDBUF1 
c6c1 e1			RDBUF17:POP	HL		;yes end the line and return. 
c6c2 70				LD	(HL),B 
c6c3 0e 0d			LD	C,CR 
c6c5 c3 48 c5			JP	OUTCHAR		;output (cr) and return. 
c6c8			; 
c6c8			;   Function to get a character from the console device. 
c6c8			; 
c6c8 cd 06 c5		GETCON:	CALL	GETECHO		;get and echo. 
c6cb c3 01 c7			JP	SETSTAT		;save status and return. 
c6ce			; 
c6ce			;   Function to get a character from the tape reader device. 
c6ce			; 
c6ce cd 7e d4		GETRDR:	CALL	READER		;get a character from reader, set status and return. 
c6d1 c3 01 c7			JP	SETSTAT 
c6d4			; 
c6d4			;  Function to perform direct console i/o. If (C) contains (FF) 
c6d4			; then this is an input request. If (C) contains (FE) then 
c6d4			; this is a status request. Otherwise we are to output (C). 
c6d4			; 
c6d4 79			DIRCIO:	LD	A,C		;test for (FF). 
c6d5 3c				INC	A 
c6d6 ca e0 c6			JP	Z,DIRC1 
c6d9 3c				INC	A		;test for (FE). 
c6da ca 5c d4			JP	Z,CONST 
c6dd c3 6b d4			JP	CONOUT		;just output (C). 
c6e0 cd 5c d4		DIRC1:	CALL	CONST		;this is an input request. 
c6e3 b7				OR	A 
c6e4 ca 91 d1			JP	Z,GOBACK1	;not ready? Just return (directly). 
c6e7 cd 5f d4			CALL	CONIN		;yes, get character. 
c6ea c3 01 c7			JP	SETSTAT		;set status and return. 
c6ed			; 
c6ed			;   Function to return the i/o byte. 
c6ed			; 
c6ed 3a 03 00		GETIOB:	LD	A,(IOBYTE) 
c6f0 c3 01 c7			JP	SETSTAT 
c6f3			; 
c6f3			;   Function to set the i/o byte. 
c6f3			; 
c6f3 21 03 00		SETIOB:	LD	HL,IOBYTE 
c6f6 71				LD	(HL),C 
c6f7 c9				RET	 
c6f8			; 
c6f8			;   Function to print the character string pointed to by (DE) 
c6f8			; on the console device. The string ends with a '$'. 
c6f8			; 
c6f8 eb			PRTSTR:	EX	DE,HL 
c6f9 4d				LD	C,L 
c6fa 44				LD	B,H		;now (BC) points to it. 
c6fb c3 d3 c5			JP	PRTMESG 
c6fe			; 
c6fe			;   Function to interigate the console device. 
c6fe			; 
c6fe cd 23 c5		GETCSTS:CALL	CKCONSOL 
c701			; 
c701			;   Get here to set the status and return to the cleanup 
c701			; section. Then back to the user. 
c701			; 
c701 32 45 c7		SETSTAT:LD	(STATUS),A 
c704 c9			RTN:	RET	 
c705			; 
c705			;   Set the status to 1 (read or write error code). 
c705			; 
c705 3e 01		IOERR1:	LD	A,1 
c707 c3 01 c7			JP	SETSTAT 
c70a			; 
c70a 00			OUTFLAG:DEFB	0		;output flag (non zero means no output). 
c70b 02			STARTING: DEFB	2		;starting position for cursor. 
c70c 00			CURPOS:	DEFB	0		;cursor position (0=start of line). 
c70d 00			PRTFLAG:DEFB	0		;printer flag (control-p toggle). List if non zero. 
c70e 00			CHARBUF:DEFB	0		;single input character buffer. 
c70f			; 
c70f			;   Stack area for BDOS calls. 
c70f			; 
c70f 00 00		USRSTACK: DEFW	0		;save users stack pointer here. 
c711			; 
c711 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 
c729 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 
c741			STKAREA:EQU	$		;end of stack area. 
c741			; 
c741 00			USERNO:	DEFB	0		;current user number. 
c742 00			ACTIVE:	DEFB	0		;currently active drive. 
c743 00 00		PARAMS:	DEFW	0		;save (DE) parameters here on entry. 
c745 00 00		STATUS:	DEFW	0		;status returned from bdos function. 
c747			; 
c747			;   Select error occured, jump to error routine. 
c747			; 
c747 21 0b c4		SLCTERR:LD	HL,BADSLCT 
c74a			; 
c74a			;   Jump to (HL) indirectly. 
c74a			; 
c74a 5e			JUMPHL:	LD	E,(HL) 
c74b 23				INC	HL 
c74c 56				LD	D,(HL)		;now (DE) contain the desired address. 
c74d eb				EX	DE,HL 
c74e e9				JP	(HL) 
c74f			; 
c74f			;   Block move. (DE) to (HL), (C) bytes total. 
c74f			; 
c74f 0c			DE2HL:	INC	C		;is count down to zero? 
c750 0d			DE2HL1:	DEC	C 
c751 c8				RET	Z		;yes, we are done. 
c752 1a				LD	A,(DE)		;no, move one more byte. 
c753 77				LD	(HL),A 
c754 13				INC	DE 
c755 23				INC	HL 
c756 c3 50 c7			JP	DE2HL1		;and repeat. 
c759			; 
c759			;   Select the desired drive. 
c759			; 
c759 3a 42 c7		SELECT:	LD	A,(ACTIVE)	;get active disk. 
c75c 4f				LD	C,A 
c75d cd 91 d4			CALL	SELDSK		;select it. 
c760 7c				LD	A,H		;valid drive? 
c761 b5				OR	L		;valid drive? 
c762 c8				RET	Z		;return if not. 
c763			; 
c763			;   Here, the BIOS returned the address of the parameter block 
c763			; in (HL). We will extract the necessary pointers and save them. 
c763			; 
c763 5e				LD	E,(HL)		;yes, get address of translation table into (DE). 
c764 23				INC	HL 
c765 56				LD	D,(HL) 
c766 23				INC	HL 
c767 22 b3 d1			LD	(SCRATCH1),HL	;save pointers to scratch areas. 
c76a 23				INC	HL 
c76b 23				INC	HL 
c76c 22 b5 d1			LD	(SCRATCH2),HL	;ditto. 
c76f 23				INC	HL 
c770 23				INC	HL 
c771 22 b7 d1			LD	(SCRATCH3),HL	;ditto. 
c774 23				INC	HL 
c775 23				INC	HL 
c776 eb				EX	DE,HL		;now save the translation table address. 
c777 22 d0 d1			LD	(XLATE),HL 
c77a 21 b9 d1			LD	HL,DIRBUF	;put the next 8 bytes here. 
c77d 0e 08			LD	C,8		;they consist of the directory buffer 
c77f cd 4f c7			CALL	DE2HL		;pointer, parameter block pointer, 
c782 2a bb d1			LD	HL,(DISKPB)	;check and allocation vectors. 
c785 eb				EX	DE,HL 
c786 21 c1 d1			LD	HL,SECTORS	;move parameter block into our ram. 
c789 0e 0f			LD	C,15		;it is 15 bytes long. 
c78b cd 4f c7			CALL	DE2HL 
c78e 2a c6 d1			LD	HL,(DSKSIZE)	;check disk size. 
c791 7c				LD	A,H		;more than 256 blocks on this? 
c792 21 dd d1			LD	HL,BIGDISK 
c795 36 ff			LD	(HL),0FFH	;set to samll. 
c797 b7				OR	A 
c798 ca 9d c7			JP	Z,SELECT1 
c79b 36 00			LD	(HL),0		;wrong, set to large. 
c79d 3e ff		SELECT1:LD	A,0FFH		;clear the zero flag. 
c79f b7				OR	A 
c7a0 c9				RET	 
c7a1			; 
c7a1			;   Routine to home the disk track head and clear pointers. 
c7a1			; 
c7a1 cd 8a d4		HOMEDRV:CALL	HOME		;home the head. 
c7a4 af				XOR	A 
c7a5 2a b5 d1			LD	HL,(SCRATCH2)	;set our track pointer also. 
c7a8 77				LD	(HL),A 
c7a9 23				INC	HL 
c7aa 77				LD	(HL),A 
c7ab 2a b7 d1			LD	HL,(SCRATCH3)	;and our sector pointer. 
c7ae 77				LD	(HL),A 
c7af 23				INC	HL 
c7b0 77				LD	(HL),A 
c7b1 c9				RET	 
c7b2			; 
c7b2			;   Do the actual disk read and check the error return status. 
c7b2			; 
c7b2 cd dd d4		DOREAD:	CALL	READ 
c7b5 c3 bb c7			JP	IORET 
c7b8			; 
c7b8			;   Do the actual disk write and handle any bios error. 
c7b8			; 
c7b8 cd e9 d4		DOWRITE:CALL	WRITE 
c7bb b7			IORET:	OR	A 
c7bc c8				RET	Z		;return unless an error occured. 
c7bd 21 09 c4			LD	HL,BADSCTR	;bad read/write on this sector. 
c7c0 c3 4a c7			JP	JUMPHL 
c7c3			; 
c7c3			;   Routine to select the track and sector that the desired 
c7c3			; block number falls in. 
c7c3			; 
c7c3 2a ea d1		TRKSEC:	LD	HL,(FILEPOS)	;get position of last accessed file 
c7c6 0e 02			LD	C,2		;in directory and compute sector #. 
c7c8 cd ea c8			CALL	SHIFTR		;sector #=file-position/4. 
c7cb 22 e5 d1			LD	(BLKNMBR),HL	;save this as the block number of interest. 
c7ce 22 ec d1			LD	(CKSUMTBL),HL	;what's it doing here too? 
c7d1			; 
c7d1			;   if the sector number has already been set (BLKNMBR), enter 
c7d1			; at this point. 
c7d1			; 
c7d1 21 e5 d1		TRKSEC1:LD	HL,BLKNMBR 
c7d4 4e				LD	C,(HL)		;move sector number into (BC). 
c7d5 23				INC	HL 
c7d6 46				LD	B,(HL) 
c7d7 2a b7 d1			LD	HL,(SCRATCH3)	;get current sector number and 
c7da 5e				LD	E,(HL)		;move this into (DE). 
c7db 23				INC	HL 
c7dc 56				LD	D,(HL) 
c7dd 2a b5 d1			LD	HL,(SCRATCH2)	;get current track number. 
c7e0 7e				LD	A,(HL)		;and this into (HL). 
c7e1 23				INC	HL 
c7e2 66				LD	H,(HL) 
c7e3 6f				LD	L,A 
c7e4 79			TRKSEC2:LD	A,C		;is desired sector before current one? 
c7e5 93				SUB	E 
c7e6 78				LD	A,B 
c7e7 9a				SBC	A,D 
c7e8 d2 fa c7			JP	NC,TRKSEC3 
c7eb e5				PUSH	HL		;yes, decrement sectors by one track. 
c7ec 2a c1 d1			LD	HL,(SECTORS)	;get sectors per track. 
c7ef 7b				LD	A,E 
c7f0 95				SUB	L 
c7f1 5f				LD	E,A 
c7f2 7a				LD	A,D 
c7f3 9c				SBC	A,H 
c7f4 57				LD	D,A		;now we have backed up one full track. 
c7f5 e1				POP	HL 
c7f6 2b				DEC	HL		;adjust track counter. 
c7f7 c3 e4 c7			JP	TRKSEC2 
c7fa e5			TRKSEC3:PUSH	HL		;desired sector is after current one. 
c7fb 2a c1 d1			LD	HL,(SECTORS)	;get sectors per track. 
c7fe 19				ADD	HL,DE		;bump sector pointer to next track. 
c7ff da 0f c8			JP	C,TRKSEC4 
c802 79				LD	A,C		;is desired sector now before current one? 
c803 95				SUB	L 
c804 78				LD	A,B 
c805 9c				SBC	A,H 
c806 da 0f c8			JP	C,TRKSEC4 
c809 eb				EX	DE,HL		;not yes, increment track counter 
c80a e1				POP	HL		;and continue until it is. 
c80b 23				INC	HL 
c80c c3 fa c7			JP	TRKSEC3 
c80f			; 
c80f			;   here we have determined the track number that contains the 
c80f			; desired sector. 
c80f			; 
c80f e1			TRKSEC4:POP	HL		;get track number (HL). 
c810 c5				PUSH	BC 
c811 d5				PUSH	DE 
c812 e5				PUSH	HL 
c813 eb				EX	DE,HL 
c814 2a ce d1			LD	HL,(OFFSET)	;adjust for first track offset. 
c817 19				ADD	HL,DE 
c818 44				LD	B,H 
c819 4d				LD	C,L 
c81a cd aa d4			CALL	SETTRK		;select this track. 
c81d d1				POP	DE		;reset current track pointer. 
c81e 2a b5 d1			LD	HL,(SCRATCH2) 
c821 73				LD	(HL),E 
c822 23				INC	HL 
c823 72				LD	(HL),D 
c824 d1				POP	DE 
c825 2a b7 d1			LD	HL,(SCRATCH3)	;reset the first sector on this track. 
c828 73				LD	(HL),E 
c829 23				INC	HL 
c82a 72				LD	(HL),D 
c82b c1				POP	BC 
c82c 79				LD	A,C		;now subtract the desired one. 
c82d 93				SUB	E		;to make it relative (1-# sectors/track). 
c82e 4f				LD	C,A 
c82f 78				LD	A,B 
c830 9a				SBC	A,D 
c831 47				LD	B,A 
c832 2a d0 d1			LD	HL,(XLATE)	;translate this sector according to this table. 
c835 eb				EX	DE,HL 
c836 cd b8 d4			CALL	SECTRN		;let the bios translate it. 
c839 4d				LD	C,L 
c83a 44				LD	B,H 
c83b c3 b1 d4			JP	SETSEC		;and select it. 
c83e			; 
c83e			;   Compute block number from record number (SAVNREC) and 
c83e			; extent number (SAVEXT). 
c83e			; 
c83e 21 c3 d1		GETBLOCK: LD	HL,BLKSHFT	;get logical to physical conversion. 
c841 4e				LD	C,(HL)		;note that this is base 2 log of ratio. 
c842 3a e3 d1			LD	A,(SAVNREC)	;get record number. 
c845 b7			GETBLK1:OR	A		;compute (A)=(A)/2^BLKSHFT. 
c846 1f				RRA	 
c847 0d				DEC	C 
c848 c2 45 c8			JP	NZ,GETBLK1 
c84b 47				LD	B,A		;save result in (B). 
c84c 3e 08			LD	A,8 
c84e 96				SUB	(HL) 
c84f 4f				LD	C,A		;compute (C)=8-BLKSHFT. 
c850 3a e2 d1			LD	A,(SAVEXT) 
c853 0d			GETBLK2:DEC	C		;compute (A)=SAVEXT*2^(8-BLKSHFT). 
c854 ca 5c c8			JP	Z,GETBLK3 
c857 b7				OR	A 
c858 17				RLA	 
c859 c3 53 c8			JP	GETBLK2 
c85c 80			GETBLK3:ADD	A,B 
c85d c9				RET	 
c85e			; 
c85e			;   Routine to extract the (BC) block byte from the fcb pointed 
c85e			; to by (PARAMS). If this is a big-disk, then these are 16 bit 
c85e			; block numbers, else they are 8 bit numbers. 
c85e			; Number is returned in (HL). 
c85e			; 
c85e 2a 43 c7		EXTBLK:	LD	HL,(PARAMS)	;get fcb address. 
c861 11 10 00			LD	DE,16		;block numbers start 16 bytes into fcb. 
c864 19				ADD	HL,DE 
c865 09				ADD	HL,BC 
c866 3a dd d1			LD	A,(BIGDISK)	;are we using a big-disk? 
c869 b7				OR	A 
c86a ca 71 c8			JP	Z,EXTBLK1 
c86d 6e				LD	L,(HL)		;no, extract an 8 bit number from the fcb. 
c86e 26 00			LD	H,0 
c870 c9				RET	 
c871 09			EXTBLK1:ADD	HL,BC		;yes, extract a 16 bit number. 
c872 5e				LD	E,(HL) 
c873 23				INC	HL 
c874 56				LD	D,(HL) 
c875 eb				EX	DE,HL		;return in (HL). 
c876 c9				RET	 
c877			; 
c877			;   Compute block number. 
c877			; 
c877 cd 3e c8		COMBLK:	CALL	GETBLOCK 
c87a 4f				LD	C,A 
c87b 06 00			LD	B,0 
c87d cd 5e c8			CALL	EXTBLK 
c880 22 e5 d1			LD	(BLKNMBR),HL 
c883 c9				RET	 
c884			; 
c884			;   Check for a zero block number (unused). 
c884			; 
c884 2a e5 d1		CHKBLK:	LD	HL,(BLKNMBR) 
c887 7d				LD	A,L		;is it zero? 
c888 b4				OR	H 
c889 c9				RET	 
c88a			; 
c88a			;   Adjust physical block (BLKNMBR) and convert to logical 
c88a			; sector (LOGSECT). This is the starting sector of this block. 
c88a			; The actual sector of interest is then added to this and the 
c88a			; resulting sector number is stored back in (BLKNMBR). This 
c88a			; will still have to be adjusted for the track number. 
c88a			; 
c88a 3a c3 d1		LOGICAL:LD	A,(BLKSHFT)	;get log2(physical/logical sectors). 
c88d 2a e5 d1			LD	HL,(BLKNMBR)	;get physical sector desired. 
c890 29			LOGICL1:ADD	HL,HL		;compute logical sector number. 
c891 3d				DEC	A		;note logical sectors are 128 bytes long. 
c892 c2 90 c8			JP	NZ,LOGICL1 
c895 22 e7 d1			LD	(LOGSECT),HL	;save logical sector. 
c898 3a c4 d1			LD	A,(BLKMASK)	;get block mask. 
c89b 4f				LD	C,A 
c89c 3a e3 d1			LD	A,(SAVNREC)	;get next sector to access. 
c89f a1				AND	C		;extract the relative position within physical block. 
c8a0 b5				OR	L		;and add it too logical sector. 
c8a1 6f				LD	L,A 
c8a2 22 e5 d1			LD	(BLKNMBR),HL	;and store. 
c8a5 c9				RET	 
c8a6			; 
c8a6			;   Set (HL) to point to extent byte in fcb. 
c8a6			; 
c8a6 2a 43 c7		SETEXT:	LD	HL,(PARAMS) 
c8a9 11 0c 00			LD	DE,12		;it is the twelth byte. 
c8ac 19				ADD	HL,DE 
c8ad c9				RET	 
c8ae			; 
c8ae			;   Set (HL) to point to record count byte in fcb and (DE) to 
c8ae			; next record number byte. 
c8ae			; 
c8ae 2a 43 c7		SETHLDE:LD	HL,(PARAMS) 
c8b1 11 0f 00			LD	DE,15		;record count byte (#15). 
c8b4 19				ADD	HL,DE 
c8b5 eb				EX	DE,HL 
c8b6 21 11 00			LD	HL,17		;next record number (#32). 
c8b9 19				ADD	HL,DE 
c8ba c9				RET	 
c8bb			; 
c8bb			;   Save current file data from fcb. 
c8bb			; 
c8bb cd ae c8		STRDATA:CALL	SETHLDE 
c8be 7e				LD	A,(HL)		;get and store record count byte. 
c8bf 32 e3 d1			LD	(SAVNREC),A 
c8c2 eb				EX	DE,HL 
c8c3 7e				LD	A,(HL)		;get and store next record number byte. 
c8c4 32 e1 d1			LD	(SAVNXT),A 
c8c7 cd a6 c8			CALL	SETEXT		;point to extent byte. 
c8ca 3a c5 d1			LD	A,(EXTMASK)	;get extent mask. 
c8cd a6				AND	(HL) 
c8ce 32 e2 d1			LD	(SAVEXT),A	;and save extent here. 
c8d1 c9				RET	 
c8d2			; 
c8d2			;   Set the next record to access. If (MODE) is set to 2, then 
c8d2			; the last record byte (SAVNREC) has the correct number to access. 
c8d2			; For sequential access, (MODE) will be equal to 1. 
c8d2			; 
c8d2 cd ae c8		SETNREC:CALL	SETHLDE 
c8d5 3a d5 d1			LD	A,(MODE)	;get sequential flag (=1). 
c8d8 fe 02			CP	2		;a 2 indicates that no adder is needed. 
c8da c2 de c8			JP	NZ,STNREC1 
c8dd af				XOR	A		;clear adder (random access?). 
c8de 4f			STNREC1:LD	C,A 
c8df 3a e3 d1			LD	A,(SAVNREC)	;get last record number. 
c8e2 81				ADD	A,C		;increment record count. 
c8e3 77				LD	(HL),A		;and set fcb's next record byte. 
c8e4 eb				EX	DE,HL 
c8e5 3a e1 d1			LD	A,(SAVNXT)	;get next record byte from storage. 
c8e8 77				LD	(HL),A		;and put this into fcb as number of records used. 
c8e9 c9				RET	 
c8ea			; 
c8ea			;   Shift (HL) right (C) bits. 
c8ea			; 
c8ea 0c			SHIFTR:	INC	C 
c8eb 0d			SHIFTR1:DEC	C 
c8ec c8				RET	Z 
c8ed 7c				LD	A,H 
c8ee b7				OR	A 
c8ef 1f				RRA	 
c8f0 67				LD	H,A 
c8f1 7d				LD	A,L 
c8f2 1f				RRA	 
c8f3 6f				LD	L,A 
c8f4 c3 eb c8			JP	SHIFTR1 
c8f7			; 
c8f7			;   Compute the check-sum for the directory buffer. Return 
c8f7			; integer sum in (A). 
c8f7			; 
c8f7 0e 80		CHECKSUM: LD	C,128		;length of buffer. 
c8f9 2a b9 d1			LD	HL,(DIRBUF)	;get its location. 
c8fc af				XOR	A		;clear summation byte. 
c8fd 86			CHKSUM1:ADD	A,(HL)		;and compute sum ignoring carries. 
c8fe 23				INC	HL 
c8ff 0d				DEC	C 
c900 c2 fd c8			JP	NZ,CHKSUM1 
c903 c9				RET	 
c904			; 
c904			;   Shift (HL) left (C) bits. 
c904			; 
c904 0c			SHIFTL:	INC	C 
c905 0d			SHIFTL1:DEC	C 
c906 c8				RET	Z 
c907 29				ADD	HL,HL		;shift left 1 bit. 
c908 c3 05 c9			JP	SHIFTL1 
c90b			; 
c90b			;   Routine to set a bit in a 16 bit value contained in (BC). 
c90b			; The bit set depends on the current drive selection. 
c90b			; 
c90b c5			SETBIT:	PUSH	BC		;save 16 bit word. 
c90c 3a 42 c7			LD	A,(ACTIVE)	;get active drive. 
c90f 4f				LD	C,A 
c910 21 01 00			LD	HL,1 
c913 cd 04 c9			CALL	SHIFTL		;shift bit 0 into place. 
c916 c1				POP	BC		;now 'or' this with the original word. 
c917 79				LD	A,C 
c918 b5				OR	L 
c919 6f				LD	L,A		;low byte done, do high byte. 
c91a 78				LD	A,B 
c91b b4				OR	H 
c91c 67				LD	H,A 
c91d c9				RET	 
c91e			; 
c91e			;   Extract the write protect status bit for the current drive. 
c91e			; The result is returned in (A), bit 0. 
c91e			; 
c91e 2a ad d1		GETWPRT:LD	HL,(WRTPRT)	;get status bytes. 
c921 3a 42 c7			LD	A,(ACTIVE)	;which drive is current? 
c924 4f				LD	C,A 
c925 cd ea c8			CALL	SHIFTR		;shift status such that bit 0 is the 
c928 7d				LD	A,L		;one of interest for this drive. 
c929 e6 01			AND	01H		;and isolate it. 
c92b c9				RET	 
c92c			; 
c92c			;   Function to write protect the current disk. 
c92c			; 
c92c 21 ad d1		WRTPRTD:LD	HL,WRTPRT	;point to status word. 
c92f 4e				LD	C,(HL)		;set (BC) equal to the status. 
c930 23				INC	HL 
c931 46				LD	B,(HL) 
c932 cd 0b c9			CALL	SETBIT		;and set this bit according to current drive. 
c935 22 ad d1			LD	(WRTPRT),HL	;then save. 
c938 2a c8 d1			LD	HL,(DIRSIZE)	;now save directory size limit. 
c93b 23				INC	HL		;remember the last one. 
c93c eb				EX	DE,HL 
c93d 2a b3 d1			LD	HL,(SCRATCH1)	;and store it here. 
c940 73				LD	(HL),E		;put low byte. 
c941 23				INC	HL 
c942 72				LD	(HL),D		;then high byte. 
c943 c9				RET	 
c944			; 
c944			;   Check for a read only file. 
c944			; 
c944 cd 5e c9		CHKROFL:CALL	FCB2HL		;set (HL) to file entry in directory buffer. 
c947 11 09 00		CKROF1:	LD	DE,9		;look at bit 7 of the ninth byte. 
c94a 19				ADD	HL,DE 
c94b 7e				LD	A,(HL) 
c94c 17				RLA	 
c94d d0				RET	NC		;return if ok. 
c94e 21 0f c4			LD	HL,ROFILE	;else, print error message and terminate. 
c951 c3 4a c7			JP	JUMPHL 
c954			; 
c954			;   Check the write protect status of the active disk. 
c954			; 
c954 cd 1e c9		CHKWPRT:CALL	GETWPRT 
c957 c8				RET	Z		;return if ok. 
c958 21 0d c4			LD	HL,RODISK	;else print message and terminate. 
c95b c3 4a c7			JP	JUMPHL 
c95e			; 
c95e			;   Routine to set (HL) pointing to the proper entry in the 
c95e			; directory buffer. 
c95e			; 
c95e 2a b9 d1		FCB2HL:	LD	HL,(DIRBUF)	;get address of buffer. 
c961 3a e9 d1			LD	A,(FCBPOS)	;relative position of file. 
c964			; 
c964			;   Routine to add (A) to (HL). 
c964			; 
c964 85			ADDA2HL:ADD	A,L 
c965 6f				LD	L,A 
c966 d0				RET	NC 
c967 24				INC	H		;take care of any carry. 
c968 c9				RET	 
c969			; 
c969			;   Routine to get the 's2' byte from the fcb supplied in 
c969			; the initial parameter specification. 
c969			; 
c969 2a 43 c7		GETS2:	LD	HL,(PARAMS)	;get address of fcb. 
c96c 11 0e 00			LD	DE,14		;relative position of 's2'. 
c96f 19				ADD	HL,DE 
c970 7e				LD	A,(HL)		;extract this byte. 
c971 c9				RET	 
c972			; 
c972			;   Clear the 's2' byte in the fcb. 
c972			; 
c972 cd 69 c9		CLEARS2:CALL	GETS2		;this sets (HL) pointing to it. 
c975 36 00			LD	(HL),0		;now clear it. 
c977 c9				RET	 
c978			; 
c978			;   Set bit 7 in the 's2' byte of the fcb. 
c978			; 
c978 cd 69 c9		SETS2B7:CALL	GETS2		;get the byte. 
c97b f6 80			OR	80H		;and set bit 7. 
c97d 77				LD	(HL),A		;then store. 
c97e c9				RET	 
c97f			; 
c97f			;   Compare (FILEPOS) with (SCRATCH1) and set flags based on 
c97f			; the difference. This checks to see if there are more file 
c97f			; names in the directory. We are at (FILEPOS) and there are 
c97f			; (SCRATCH1) of them to check. 
c97f			; 
c97f 2a ea d1		MOREFLS:LD	HL,(FILEPOS)	;we are here. 
c982 eb				EX	DE,HL 
c983 2a b3 d1			LD	HL,(SCRATCH1)	;and don't go past here. 
c986 7b				LD	A,E		;compute difference but don't keep. 
c987 96				SUB	(HL) 
c988 23				INC	HL 
c989 7a				LD	A,D 
c98a 9e				SBC	A,(HL)		;set carry if no more names. 
c98b c9				RET	 
c98c			; 
c98c			;   Call this routine to prevent (SCRATCH1) from being greater 
c98c			; than (FILEPOS). 
c98c			; 
c98c cd 7f c9		CHKNMBR:CALL	MOREFLS		;SCRATCH1 too big? 
c98f d8				RET	C 
c990 13				INC	DE		;yes, reset it to (FILEPOS). 
c991 72				LD	(HL),D 
c992 2b				DEC	HL 
c993 73				LD	(HL),E 
c994 c9				RET	 
c995			; 
c995			;   Compute (HL)=(DE)-(HL) 
c995			; 
c995 7b			SUBHL:	LD	A,E		;compute difference. 
c996 95				SUB	L 
c997 6f				LD	L,A		;store low byte. 
c998 7a				LD	A,D 
c999 9c				SBC	A,H 
c99a 67				LD	H,A		;and then high byte. 
c99b c9				RET	 
c99c			; 
c99c			;   Set the directory checksum byte. 
c99c			; 
c99c 0e ff		SETDIR:	LD	C,0FFH 
c99e			; 
c99e			;   Routine to set or compare the directory checksum byte. If 
c99e			; (C)=0ffh, then this will set the checksum byte. Else the byte 
c99e			; will be checked. If the check fails (the disk has been changed), 
c99e			; then this disk will be write protected. 
c99e			; 
c99e 2a ec d1		CHECKDIR: LD	HL,(CKSUMTBL) 
c9a1 eb				EX	DE,HL 
c9a2 2a cc d1			LD	HL,(ALLOC1) 
c9a5 cd 95 c9			CALL	SUBHL 
c9a8 d0				RET	NC		;ok if (CKSUMTBL) > (ALLOC1), so return. 
c9a9 c5				PUSH	BC 
c9aa cd f7 c8			CALL	CHECKSUM	;else compute checksum. 
c9ad 2a bd d1			LD	HL,(CHKVECT)	;get address of checksum table. 
c9b0 eb				EX	DE,HL 
c9b1 2a ec d1			LD	HL,(CKSUMTBL) 
c9b4 19				ADD	HL,DE		;set (HL) to point to byte for this drive. 
c9b5 c1				POP	BC 
c9b6 0c				INC	C		;set or check ? 
c9b7 ca c4 c9			JP	Z,CHKDIR1 
c9ba be				CP	(HL)		;check them. 
c9bb c8				RET	Z		;return if they are the same. 
c9bc cd 7f c9			CALL	MOREFLS		;not the same, do we care? 
c9bf d0				RET	NC 
c9c0 cd 2c c9			CALL	WRTPRTD		;yes, mark this as write protected. 
c9c3 c9				RET	 
c9c4 77			CHKDIR1:LD	(HL),A		;just set the byte. 
c9c5 c9				RET	 
c9c6			; 
c9c6			;   Do a write to the directory of the current disk. 
c9c6			; 
c9c6 cd 9c c9		DIRWRITE: CALL	SETDIR		;set checksum byte. 
c9c9 cd e0 c9			CALL	DIRDMA		;set directory dma address. 
c9cc 0e 01			LD	C,1		;tell the bios to actually write. 
c9ce cd b8 c7			CALL	DOWRITE		;then do the write. 
c9d1 c3 da c9			JP	DEFDMA 
c9d4			; 
c9d4			;   Read from the directory. 
c9d4			; 
c9d4 cd e0 c9		DIRREAD:CALL	DIRDMA		;set the directory dma address. 
c9d7 cd b2 c7			CALL	DOREAD		;and read it. 
c9da			; 
c9da			;   Routine to set the dma address to the users choice. 
c9da			; 
c9da 21 b1 d1		DEFDMA:	LD	HL,USERDMA	;reset the default dma address and return. 
c9dd c3 e3 c9			JP	DIRDMA1 
c9e0			; 
c9e0			;   Routine to set the dma address for directory work. 
c9e0			; 
c9e0 21 b9 d1		DIRDMA:	LD	HL,DIRBUF 
c9e3			; 
c9e3			;   Set the dma address. On entry, (HL) points to 
c9e3			; word containing the desired dma address. 
c9e3			; 
c9e3 4e			DIRDMA1:LD	C,(HL) 
c9e4 23				INC	HL 
c9e5 46				LD	B,(HL)		;setup (BC) and go to the bios to set it. 
c9e6 c3 bc d4			JP	SETDMA 
c9e9			; 
c9e9			;   Move the directory buffer into user's dma space. 
c9e9			; 
c9e9 2a b9 d1		MOVEDIR:LD	HL,(DIRBUF)	;buffer is located here, and 
c9ec eb				EX	DE,HL 
c9ed 2a b1 d1			LD	HL,(USERDMA)	; put it here. 
c9f0 0e 80			LD	C,128		;this is its length. 
c9f2 c3 4f c7			JP	DE2HL		;move it now and return. 
c9f5			; 
c9f5			;   Check (FILEPOS) and set the zero flag if it equals 0ffffh. 
c9f5			; 
c9f5 21 ea d1		CKFILPOS: LD	HL,FILEPOS 
c9f8 7e				LD	A,(HL) 
c9f9 23				INC	HL 
c9fa be				CP	(HL)		;are both bytes the same? 
c9fb c0				RET	NZ 
c9fc 3c				INC	A		;yes, but are they each 0ffh? 
c9fd c9				RET	 
c9fe			; 
c9fe			;   Set location (FILEPOS) to 0ffffh. 
c9fe			; 
c9fe 21 ff ff		STFILPOS: LD	HL,0FFFFH 
ca01 22 ea d1			LD	(FILEPOS),HL 
ca04 c9				RET	 
ca05			; 
ca05			;   Move on to the next file position within the current 
ca05			; directory buffer. If no more exist, set pointer to 0ffffh 
ca05			; and the calling routine will check for this. Enter with (C) 
ca05			; equal to 0ffh to cause the checksum byte to be set, else we 
ca05			; will check this disk and set write protect if checksums are 
ca05			; not the same (applies only if another directory sector must 
ca05			; be read). 
ca05			; 
ca05 2a c8 d1		NXENTRY:LD	HL,(DIRSIZE)	;get directory entry size limit. 
ca08 eb				EX	DE,HL 
ca09 2a ea d1			LD	HL,(FILEPOS)	;get current count. 
ca0c 23				INC	HL		;go on to the next one. 
ca0d 22 ea d1			LD	(FILEPOS),HL 
ca10 cd 95 c9			CALL	SUBHL		;(HL)=(DIRSIZE)-(FILEPOS) 
ca13 d2 19 ca			JP	NC,NXENT1	;is there more room left? 
ca16 c3 fe c9			JP	STFILPOS	;no. Set this flag and return. 
ca19 3a ea d1		NXENT1:	LD	A,(FILEPOS)	;get file position within directory. 
ca1c e6 03			AND	03H		;only look within this sector (only 4 entries fit). 
ca1e 06 05			LD	B,5		;convert to relative position (32 bytes each). 
ca20 87			NXENT2:	ADD	A,A		;note that this is not efficient code. 
ca21 05				DEC	B		;5 'ADD A's would be better. 
ca22 c2 20 ca			JP	NZ,NXENT2 
ca25 32 e9 d1			LD	(FCBPOS),A	;save it as position of fcb. 
ca28 b7				OR	A 
ca29 c0				RET	NZ		;return if we are within buffer. 
ca2a c5				PUSH	BC 
ca2b cd c3 c7			CALL	TRKSEC		;we need the next directory sector. 
ca2e cd d4 c9			CALL	DIRREAD 
ca31 c1				POP	BC 
ca32 c3 9e c9			JP	CHECKDIR 
ca35			; 
ca35			;   Routine to to get a bit from the disk space allocation 
ca35			; map. It is returned in (A), bit position 0. On entry to here, 
ca35			; set (BC) to the block number on the disk to check. 
ca35			; On return, (D) will contain the original bit position for 
ca35			; this block number and (HL) will point to the address for it. 
ca35			; 
ca35 79			CKBITMAP: LD	A,C		;determine bit number of interest. 
ca36 e6 07			AND	07H		;compute (D)=(E)=(C and 7)+1. 
ca38 3c				INC	A 
ca39 5f				LD	E,A		;save particular bit number. 
ca3a 57				LD	D,A 
ca3b			; 
ca3b			;   compute (BC)=(BC)/8. 
ca3b			; 
ca3b 79				LD	A,C 
ca3c 0f				RRCA			;now shift right 3 bits. 
ca3d 0f				RRCA	 
ca3e 0f				RRCA	 
ca3f e6 1f			AND	1FH		;and clear bits 7,6,5. 
ca41 4f				LD	C,A 
ca42 78				LD	A,B 
ca43 87				ADD	A,A		;now shift (B) into bits 7,6,5. 
ca44 87				ADD	A,A 
ca45 87				ADD	A,A 
ca46 87				ADD	A,A 
ca47 87				ADD	A,A 
ca48 b1				OR	C		;and add in (C). 
ca49 4f				LD	C,A		;ok, (C) ha been completed. 
ca4a 78				LD	A,B		;is there a better way of doing this? 
ca4b 0f				RRCA	 
ca4c 0f				RRCA	 
ca4d 0f				RRCA	 
ca4e e6 1f			AND	1FH 
ca50 47				LD	B,A		;and now (B) is completed. 
ca51			; 
ca51			;   use this as an offset into the disk space allocation 
ca51			; table. 
ca51			; 
ca51 2a bf d1			LD	HL,(ALOCVECT) 
ca54 09				ADD	HL,BC 
ca55 7e				LD	A,(HL)		;now get correct byte. 
ca56 07			CKBMAP1:RLCA			;get correct bit into position 0. 
ca57 1d				DEC	E 
ca58 c2 56 ca			JP	NZ,CKBMAP1 
ca5b c9				RET	 
ca5c			; 
ca5c			;   Set or clear the bit map such that block number (BC) will be marked 
ca5c			; as used. On entry, if (E)=0 then this bit will be cleared, if it equals 
ca5c			; 1 then it will be set (don't use anyother values). 
ca5c			; 
ca5c d5			STBITMAP: PUSH	DE 
ca5d cd 35 ca			CALL	CKBITMAP	;get the byte of interest. 
ca60 e6 fe			AND	0FEH		;clear the affected bit. 
ca62 c1				POP	BC 
ca63 b1				OR	C		;and now set it acording to (C). 
ca64			; 
ca64			;  entry to restore the original bit position and then store 
ca64			; in table. (A) contains the value, (D) contains the bit 
ca64			; position (1-8), and (HL) points to the address within the 
ca64			; space allocation table for this byte. 
ca64			; 
ca64 0f			STBMAP1:RRCA			;restore original bit position. 
ca65 15				DEC	D 
ca66 c2 64 ca			JP	NZ,STBMAP1 
ca69 77				LD	(HL),A		;and stor byte in table. 
ca6a c9				RET	 
ca6b			; 
ca6b			;   Set/clear space used bits in allocation map for this file. 
ca6b			; On entry, (C)=1 to set the map and (C)=0 to clear it. 
ca6b			; 
ca6b cd 5e c9		SETFILE:CALL	FCB2HL		;get address of fcb 
ca6e 11 10 00			LD	DE,16 
ca71 19				ADD	HL,DE		;get to block number bytes. 
ca72 c5				PUSH	BC 
ca73 0e 11			LD	C,17		;check all 17 bytes (max) of table. 
ca75 d1			SETFL1:	POP	DE 
ca76 0d				DEC	C		;done all bytes yet? 
ca77 c8				RET	Z 
ca78 d5				PUSH	DE 
ca79 3a dd d1			LD	A,(BIGDISK)	;check disk size for 16 bit block numbers. 
ca7c b7				OR	A 
ca7d ca 88 ca			JP	Z,SETFL2 
ca80 c5				PUSH	BC		;only 8 bit numbers. set (BC) to this one. 
ca81 e5				PUSH	HL 
ca82 4e				LD	C,(HL)		;get low byte from table, always 
ca83 06 00			LD	B,0		;set high byte to zero. 
ca85 c3 8e ca			JP	SETFL3 
ca88 0d			SETFL2:	DEC	C		;for 16 bit block numbers, adjust counter. 
ca89 c5				PUSH	BC 
ca8a 4e				LD	C,(HL)		;now get both the low and high bytes. 
ca8b 23				INC	HL 
ca8c 46				LD	B,(HL) 
ca8d e5				PUSH	HL 
ca8e 79			SETFL3:	LD	A,C		;block used? 
ca8f b0				OR	B 
ca90 ca 9d ca			JP	Z,SETFL4 
ca93 2a c6 d1			LD	HL,(DSKSIZE)	;is this block number within the 
ca96 7d				LD	A,L		;space on the disk? 
ca97 91				SUB	C 
ca98 7c				LD	A,H 
ca99 98				SBC	A,B 
ca9a d4 5c ca			CALL	NC,STBITMAP	;yes, set the proper bit. 
ca9d e1			SETFL4:	POP	HL		;point to next block number in fcb. 
ca9e 23				INC	HL 
ca9f c1				POP	BC 
caa0 c3 75 ca			JP	SETFL1 
caa3			; 
caa3			;   Construct the space used allocation bit map for the active 
caa3			; drive. If a file name starts with '$' and it is under the 
caa3			; current user number, then (STATUS) is set to minus 1. Otherwise 
caa3			; it is not set at all. 
caa3			; 
caa3 2a c6 d1		BITMAP:	LD	HL,(DSKSIZE)	;compute size of allocation table. 
caa6 0e 03			LD	C,3 
caa8 cd ea c8			CALL	SHIFTR		;(HL)=(HL)/8. 
caab 23				INC	HL		;at lease 1 byte. 
caac 44				LD	B,H 
caad 4d				LD	C,L		;set (BC) to the allocation table length. 
caae			; 
caae			;   Initialize the bitmap for this drive. Right now, the first 
caae			; two bytes are specified by the disk parameter block. However 
caae			; a patch could be entered here if it were necessary to setup 
caae			; this table in a special mannor. For example, the bios could 
caae			; determine locations of 'bad blocks' and set them as already 
caae			; 'used' in the map. 
caae			; 
caae 2a bf d1			LD	HL,(ALOCVECT)	;now zero out the table now. 
cab1 36 00		BITMAP1:LD	(HL),0 
cab3 23				INC	HL 
cab4 0b				DEC	BC 
cab5 78				LD	A,B 
cab6 b1				OR	C 
cab7 c2 b1 ca			JP	NZ,BITMAP1 
caba 2a ca d1			LD	HL,(ALLOC0)	;get initial space used by directory. 
cabd eb				EX	DE,HL 
cabe 2a bf d1			LD	HL,(ALOCVECT)	;and put this into map. 
cac1 73				LD	(HL),E 
cac2 23				INC	HL 
cac3 72				LD	(HL),D 
cac4			; 
cac4			;   End of initialization portion. 
cac4			; 
cac4 cd a1 c7			CALL	HOMEDRV		;now home the drive. 
cac7 2a b3 d1			LD	HL,(SCRATCH1) 
caca 36 03			LD	(HL),3		;force next directory request to read 
cacc 23				INC	HL		;in a sector. 
cacd 36 00			LD	(HL),0 
cacf cd fe c9			CALL	STFILPOS	;clear initial file position also. 
cad2 0e ff		BITMAP2:LD	C,0FFH		;read next file name in directory 
cad4 cd 05 ca			CALL	NXENTRY		;and set checksum byte. 
cad7 cd f5 c9			CALL	CKFILPOS	;is there another file? 
cada c8				RET	Z 
cadb cd 5e c9			CALL	FCB2HL		;yes, get its address. 
cade 3e e5			LD	A,0E5H 
cae0 be				CP	(HL)		;empty file entry? 
cae1 ca d2 ca			JP	Z,BITMAP2 
cae4 3a 41 c7			LD	A,(USERNO)	;no, correct user number? 
cae7 be				CP	(HL) 
cae8 c2 f6 ca			JP	NZ,BITMAP3 
caeb 23				INC	HL 
caec 7e				LD	A,(HL)		;yes, does name start with a '$'? 
caed d6 24			SUB	'$' 
caef c2 f6 ca			JP	NZ,BITMAP3 
caf2 3d				DEC	A		;yes, set atatus to minus one. 
caf3 32 45 c7			LD	(STATUS),A 
caf6 0e 01		BITMAP3:LD	C,1		;now set this file's space as used in bit map. 
caf8 cd 6b ca			CALL	SETFILE 
cafb cd 8c c9			CALL	CHKNMBR		;keep (SCRATCH1) in bounds. 
cafe c3 d2 ca			JP	BITMAP2 
cb01			; 
cb01			;   Set the status (STATUS) and return. 
cb01			; 
cb01 3a d4 d1		STSTATUS: LD	A,(FNDSTAT) 
cb04 c3 01 c7			JP	SETSTAT 
cb07			; 
cb07			;   Check extents in (A) and (C). Set the zero flag if they 
cb07			; are the same. The number of 16k chunks of disk space that 
cb07			; the directory extent covers is expressad is (EXTMASK+1). 
cb07			; No registers are modified. 
cb07			; 
cb07 c5			SAMEXT:	PUSH	BC 
cb08 f5				PUSH	AF 
cb09 3a c5 d1			LD	A,(EXTMASK)	;get extent mask and use it to 
cb0c 2f				CPL			;to compare both extent numbers. 
cb0d 47				LD	B,A		;save resulting mask here. 
cb0e 79				LD	A,C		;mask first extent and save in (C). 
cb0f a0				AND	B 
cb10 4f				LD	C,A 
cb11 f1				POP	AF		;now mask second extent and compare 
cb12 a0				AND	B		;with the first one. 
cb13 91				SUB	C 
cb14 e6 1f			AND	1FH		;(* only check buts 0-4 *) 
cb16 c1				POP	BC		;the zero flag is set if they are the same. 
cb17 c9				RET			;restore (BC) and return. 
cb18			; 
cb18			;   Search for the first occurence of a file name. On entry, 
cb18			; register (C) should contain the number of bytes of the fcb 
cb18			; that must match. 
cb18			; 
cb18 3e ff		FINDFST:LD	A,0FFH 
cb1a 32 d4 d1			LD	(FNDSTAT),A 
cb1d 21 d8 d1			LD	HL,COUNTER	;save character count. 
cb20 71				LD	(HL),C 
cb21 2a 43 c7			LD	HL,(PARAMS)	;get filename to match. 
cb24 22 d9 d1			LD	(SAVEFCB),HL	;and save. 
cb27 cd fe c9			CALL	STFILPOS	;clear initial file position (set to 0ffffh). 
cb2a cd a1 c7			CALL	HOMEDRV		;home the drive. 
cb2d			; 
cb2d			;   Entry to locate the next occurence of a filename within the 
cb2d			; directory. The disk is not expected to have been changed. If 
cb2d			; it was, then it will be write protected. 
cb2d			; 
cb2d 0e 00		FINDNXT:LD	C,0		;write protect the disk if changed. 
cb2f cd 05 ca			CALL	NXENTRY		;get next filename entry in directory. 
cb32 cd f5 c9			CALL	CKFILPOS	;is file position = 0ffffh? 
cb35 ca 94 cb			JP	Z,FNDNXT6	;yes, exit now then. 
cb38 2a d9 d1			LD	HL,(SAVEFCB)	;set (DE) pointing to filename to match. 
cb3b eb				EX	DE,HL 
cb3c 1a				LD	A,(DE) 
cb3d fe e5			CP	0E5H		;empty directory entry? 
cb3f ca 4a cb			JP	Z,FNDNXT1	;(* are we trying to reserect erased entries? *) 
cb42 d5				PUSH	DE 
cb43 cd 7f c9			CALL	MOREFLS		;more files in directory? 
cb46 d1				POP	DE 
cb47 d2 94 cb			JP	NC,FNDNXT6	;no more. Exit now. 
cb4a cd 5e c9		FNDNXT1:CALL	FCB2HL		;get address of this fcb in directory. 
cb4d 3a d8 d1			LD	A,(COUNTER)	;get number of bytes (characters) to check. 
cb50 4f				LD	C,A 
cb51 06 00			LD	B,0		;initialize byte position counter. 
cb53 79			FNDNXT2:LD	A,C		;are we done with the compare? 
cb54 b7				OR	A 
cb55 ca 83 cb			JP	Z,FNDNXT5 
cb58 1a				LD	A,(DE)		;no, check next byte. 
cb59 fe 3f			CP	'?'		;don't care about this character? 
cb5b ca 7c cb			JP	Z,FNDNXT4 
cb5e 78				LD	A,B		;get bytes position in fcb. 
cb5f fe 0d			CP	13		;don't care about the thirteenth byte either. 
cb61 ca 7c cb			JP	Z,FNDNXT4 
cb64 fe 0c			CP	12		;extent byte? 
cb66 1a				LD	A,(DE) 
cb67 ca 73 cb			JP	Z,FNDNXT3 
cb6a 96				SUB	(HL)		;otherwise compare characters. 
cb6b e6 7f			AND	7FH 
cb6d c2 2d cb			JP	NZ,FINDNXT	;not the same, check next entry. 
cb70 c3 7c cb			JP	FNDNXT4		;so far so good, keep checking. 
cb73 c5			FNDNXT3:PUSH	BC		;check the extent byte here. 
cb74 4e				LD	C,(HL) 
cb75 cd 07 cb			CALL	SAMEXT 
cb78 c1				POP	BC 
cb79 c2 2d cb			JP	NZ,FINDNXT	;not the same, look some more. 
cb7c			; 
cb7c			;   So far the names compare. Bump pointers to the next byte 
cb7c			; and continue until all (C) characters have been checked. 
cb7c			; 
cb7c 13			FNDNXT4:INC	DE		;bump pointers. 
cb7d 23				INC	HL 
cb7e 04				INC	B 
cb7f 0d				DEC	C		;adjust character counter. 
cb80 c3 53 cb			JP	FNDNXT2 
cb83 3a ea d1		FNDNXT5:LD	A,(FILEPOS)	;return the position of this entry. 
cb86 e6 03			AND	03H 
cb88 32 45 c7			LD	(STATUS),A 
cb8b 21 d4 d1			LD	HL,FNDSTAT 
cb8e 7e				LD	A,(HL) 
cb8f 17				RLA	 
cb90 d0				RET	NC 
cb91 af				XOR	A 
cb92 77				LD	(HL),A 
cb93 c9				RET	 
cb94			; 
cb94			;   Filename was not found. Set appropriate status. 
cb94			; 
cb94 cd fe c9		FNDNXT6:CALL	STFILPOS	;set (FILEPOS) to 0ffffh. 
cb97 3e ff			LD	A,0FFH		;say not located. 
cb99 c3 01 c7			JP	SETSTAT 
cb9c			; 
cb9c			;   Erase files from the directory. Only the first byte of the 
cb9c			; fcb will be affected. It is set to (E5). 
cb9c			; 
cb9c cd 54 c9		ERAFILE:CALL	CHKWPRT		;is disk write protected? 
cb9f 0e 0c			LD	C,12		;only compare file names. 
cba1 cd 18 cb			CALL	FINDFST		;get first file name. 
cba4 cd f5 c9		ERAFIL1:CALL	CKFILPOS	;any found? 
cba7 c8				RET	Z		;nope, we must be done. 
cba8 cd 44 c9			CALL	CHKROFL		;is file read only? 
cbab cd 5e c9			CALL	FCB2HL		;nope, get address of fcb and 
cbae 36 e5			LD	(HL),0E5H	;set first byte to 'empty'. 
cbb0 0e 00			LD	C,0		;clear the space from the bit map. 
cbb2 cd 6b ca			CALL	SETFILE 
cbb5 cd c6 c9			CALL	DIRWRITE	;now write the directory sector back out. 
cbb8 cd 2d cb			CALL	FINDNXT		;find the next file name. 
cbbb c3 a4 cb			JP	ERAFIL1		;and repeat process. 
cbbe			; 
cbbe			;   Look through the space allocation map (bit map) for the 
cbbe			; next available block. Start searching at block number (BC-1). 
cbbe			; The search procedure is to look for an empty block that is 
cbbe			; before the starting block. If not empty, look at a later 
cbbe			; block number. In this way, we return the closest empty block 
cbbe			; on either side of the 'target' block number. This will speed 
cbbe			; access on random devices. For serial devices, this should be 
cbbe			; changed to look in the forward direction first and then start 
cbbe			; at the front and search some more. 
cbbe			; 
cbbe			;   On return, (DE)= block number that is empty and (HL) =0 
cbbe			; if no empry block was found. 
cbbe			; 
cbbe 50			FNDSPACE: LD	D,B		;set (DE) as the block that is checked. 
cbbf 59				LD	E,C 
cbc0			; 
cbc0			;   Look before target block. Registers (BC) are used as the lower 
cbc0			; pointer and (DE) as the upper pointer. 
cbc0			; 
cbc0 79			FNDSPA1:LD	A,C		;is block 0 specified? 
cbc1 b0				OR	B 
cbc2 ca d1 cb			JP	Z,FNDSPA2 
cbc5 0b				DEC	BC		;nope, check previous block. 
cbc6 d5				PUSH	DE 
cbc7 c5				PUSH	BC 
cbc8 cd 35 ca			CALL	CKBITMAP 
cbcb 1f				RRA			;is this block empty? 
cbcc d2 ec cb			JP	NC,FNDSPA3	;yes. use this. 
cbcf			; 
cbcf			;   Note that the above logic gets the first block that it finds 
cbcf			; that is empty. Thus a file could be written 'backward' making 
cbcf			; it very slow to access. This could be changed to look for the 
cbcf			; first empty block and then continue until the start of this 
cbcf			; empty space is located and then used that starting block. 
cbcf			; This should help speed up access to some files especially on 
cbcf			; a well used disk with lots of fairly small 'holes'. 
cbcf			; 
cbcf c1				POP	BC		;nope, check some more. 
cbd0 d1				POP	DE 
cbd1			; 
cbd1			;   Now look after target block. 
cbd1			; 
cbd1 2a c6 d1		FNDSPA2:LD	HL,(DSKSIZE)	;is block (DE) within disk limits? 
cbd4 7b				LD	A,E 
cbd5 95				SUB	L 
cbd6 7a				LD	A,D 
cbd7 9c				SBC	A,H 
cbd8 d2 f4 cb			JP	NC,FNDSPA4 
cbdb 13				INC	DE		;yes, move on to next one. 
cbdc c5				PUSH	BC 
cbdd d5				PUSH	DE 
cbde 42				LD	B,D 
cbdf 4b				LD	C,E 
cbe0 cd 35 ca			CALL	CKBITMAP	;check it. 
cbe3 1f				RRA			;empty? 
cbe4 d2 ec cb			JP	NC,FNDSPA3 
cbe7 d1				POP	DE		;nope, continue searching. 
cbe8 c1				POP	BC 
cbe9 c3 c0 cb			JP	FNDSPA1 
cbec			; 
cbec			;   Empty block found. Set it as used and return with (HL) 
cbec			; pointing to it (true?). 
cbec			; 
cbec 17			FNDSPA3:RLA			;reset byte. 
cbed 3c				INC	A		;and set bit 0. 
cbee cd 64 ca			CALL	STBMAP1		;update bit map. 
cbf1 e1				POP	HL		;set return registers. 
cbf2 d1				POP	DE 
cbf3 c9				RET	 
cbf4			; 
cbf4			;   Free block was not found. If (BC) is not zero, then we have 
cbf4			; not checked all of the disk space. 
cbf4			; 
cbf4 79			FNDSPA4:LD	A,C 
cbf5 b0				OR	B 
cbf6 c2 c0 cb			JP	NZ,FNDSPA1 
cbf9 21 00 00			LD	HL,0		;set 'not found' status. 
cbfc c9				RET	 
cbfd			; 
cbfd			;   Move a complete fcb entry into the directory and write it. 
cbfd			; 
cbfd 0e 00		FCBSET:	LD	C,0 
cbff 1e 20			LD	E,32		;length of each entry. 
cc01			; 
cc01			;   Move (E) bytes from the fcb pointed to by (PARAMS) into 
cc01			; fcb in directory starting at relative byte (C). This updated 
cc01			; directory buffer is then written to the disk. 
cc01			; 
cc01 d5			UPDATE:	PUSH	DE 
cc02 06 00			LD	B,0		;set (BC) to relative byte position. 
cc04 2a 43 c7			LD	HL,(PARAMS)	;get address of fcb. 
cc07 09				ADD	HL,BC		;compute starting byte. 
cc08 eb				EX	DE,HL 
cc09 cd 5e c9			CALL	FCB2HL		;get address of fcb to update in directory. 
cc0c c1				POP	BC		;set (C) to number of bytes to change. 
cc0d cd 4f c7			CALL	DE2HL 
cc10 cd c3 c7		UPDATE1:CALL	TRKSEC		;determine the track and sector affected. 
cc13 c3 c6 c9			JP	DIRWRITE	;then write this sector out. 
cc16			; 
cc16			;   Routine to change the name of all files on the disk with a 
cc16			; specified name. The fcb contains the current name as the 
cc16			; first 12 characters and the new name 16 bytes into the fcb. 
cc16			; 
cc16 cd 54 c9		CHGNAMES: CALL	CHKWPRT		;check for a write protected disk. 
cc19 0e 0c			LD	C,12		;match first 12 bytes of fcb only. 
cc1b cd 18 cb			CALL	FINDFST		;get first name. 
cc1e 2a 43 c7			LD	HL,(PARAMS)	;get address of fcb. 
cc21 7e				LD	A,(HL)		;get user number. 
cc22 11 10 00			LD	DE,16		;move over to desired name. 
cc25 19				ADD	HL,DE 
cc26 77				LD	(HL),A		;keep same user number. 
cc27 cd f5 c9		CHGNAM1:CALL	CKFILPOS	;any matching file found? 
cc2a c8				RET	Z		;no, we must be done. 
cc2b cd 44 c9			CALL	CHKROFL		;check for read only file. 
cc2e 0e 10			LD	C,16		;start 16 bytes into fcb. 
cc30 1e 0c			LD	E,12		;and update the first 12 bytes of directory. 
cc32 cd 01 cc			CALL	UPDATE 
cc35 cd 2d cb			CALL	FINDNXT		;get te next file name. 
cc38 c3 27 cc			JP	CHGNAM1		;and continue. 
cc3b			; 
cc3b			;   Update a files attributes. The procedure is to search for 
cc3b			; every file with the same name as shown in fcb (ignoring bit 7) 
cc3b			; and then to update it (which includes bit 7). No other changes 
cc3b			; are made. 
cc3b			; 
cc3b 0e 0c		SAVEATTR: LD	C,12		;match first 12 bytes. 
cc3d cd 18 cb			CALL	FINDFST		;look for first filename. 
cc40 cd f5 c9		SAVATR1:CALL	CKFILPOS	;was one found? 
cc43 c8				RET	Z		;nope, we must be done. 
cc44 0e 00			LD	C,0		;yes, update the first 12 bytes now. 
cc46 1e 0c			LD	E,12 
cc48 cd 01 cc			CALL	UPDATE		;update filename and write directory. 
cc4b cd 2d cb			CALL	FINDNXT		;and get the next file. 
cc4e c3 40 cc			JP	SAVATR1		;then continue until done. 
cc51			; 
cc51			;  Open a file (name specified in fcb). 
cc51			; 
cc51 0e 0f		OPENIT:	LD	C,15		;compare the first 15 bytes. 
cc53 cd 18 cb			CALL	FINDFST		;get the first one in directory. 
cc56 cd f5 c9			CALL	CKFILPOS	;any at all? 
cc59 c8				RET	Z 
cc5a cd a6 c8		OPENIT1:CALL	SETEXT		;point to extent byte within users fcb. 
cc5d 7e				LD	A,(HL)		;and get it. 
cc5e f5				PUSH	AF		;save it and address. 
cc5f e5				PUSH	HL 
cc60 cd 5e c9			CALL	FCB2HL		;point to fcb in directory. 
cc63 eb				EX	DE,HL 
cc64 2a 43 c7			LD	HL,(PARAMS)	;this is the users copy. 
cc67 0e 20			LD	C,32		;move it into users space. 
cc69 d5				PUSH	DE 
cc6a cd 4f c7			CALL	DE2HL 
cc6d cd 78 c9			CALL	SETS2B7		;set bit 7 in 's2' byte (unmodified). 
cc70 d1				POP	DE		;now get the extent byte from this fcb. 
cc71 21 0c 00			LD	HL,12 
cc74 19				ADD	HL,DE 
cc75 4e				LD	C,(HL)		;into (C). 
cc76 21 0f 00			LD	HL,15		;now get the record count byte into (B). 
cc79 19				ADD	HL,DE 
cc7a 46				LD	B,(HL) 
cc7b e1				POP	HL		;keep the same extent as the user had originally. 
cc7c f1				POP	AF 
cc7d 77				LD	(HL),A 
cc7e 79				LD	A,C		;is it the same as in the directory fcb? 
cc7f be				CP	(HL) 
cc80 78				LD	A,B		;if yes, then use the same record count. 
cc81 ca 8b cc			JP	Z,OPENIT2 
cc84 3e 00			LD	A,0		;if the user specified an extent greater than 
cc86 da 8b cc			JP	C,OPENIT2	;the one in the directory, then set record count to 0. 
cc89 3e 80			LD	A,128		;otherwise set to maximum. 
cc8b 2a 43 c7		OPENIT2:LD	HL,(PARAMS)	;set record count in users fcb to (A). 
cc8e 11 0f 00			LD	DE,15 
cc91 19				ADD	HL,DE		;compute relative position. 
cc92 77				LD	(HL),A		;and set the record count. 
cc93 c9				RET	 
cc94			; 
cc94			;   Move two bytes from (DE) to (HL) if (and only if) (HL) 
cc94			; point to a zero value (16 bit). 
cc94			;   Return with zero flag set it (DE) was moved. Registers (DE) 
cc94			; and (HL) are not changed. However (A) is. 
cc94			; 
cc94 7e			MOVEWORD: LD	A,(HL)		;check for a zero word. 
cc95 23				INC	HL 
cc96 b6				OR	(HL)		;both bytes zero? 
cc97 2b				DEC	HL 
cc98 c0				RET	NZ		;nope, just return. 
cc99 1a				LD	A,(DE)		;yes, move two bytes from (DE) into 
cc9a 77				LD	(HL),A		;this zero space. 
cc9b 13				INC	DE 
cc9c 23				INC	HL 
cc9d 1a				LD	A,(DE) 
cc9e 77				LD	(HL),A 
cc9f 1b				DEC	DE		;don't disturb these registers. 
cca0 2b				DEC	HL 
cca1 c9				RET	 
cca2			; 
cca2			;   Get here to close a file specified by (fcb). 
cca2			; 
cca2 af			CLOSEIT:XOR	A		;clear status and file position bytes. 
cca3 32 45 c7			LD	(STATUS),A 
cca6 32 ea d1			LD	(FILEPOS),A 
cca9 32 eb d1			LD	(FILEPOS+1),A 
ccac cd 1e c9			CALL	GETWPRT		;get write protect bit for this drive. 
ccaf c0				RET	NZ		;just return if it is set. 
ccb0 cd 69 c9			CALL	GETS2		;else get the 's2' byte. 
ccb3 e6 80			AND	80H		;and look at bit 7 (file unmodified?). 
ccb5 c0				RET	NZ		;just return if set. 
ccb6 0e 0f			LD	C,15		;else look up this file in directory. 
ccb8 cd 18 cb			CALL	FINDFST 
ccbb cd f5 c9			CALL	CKFILPOS	;was it found? 
ccbe c8				RET	Z		;just return if not. 
ccbf 01 10 00			LD	BC,16		;set (HL) pointing to records used section. 
ccc2 cd 5e c9			CALL	FCB2HL 
ccc5 09				ADD	HL,BC 
ccc6 eb				EX	DE,HL 
ccc7 2a 43 c7			LD	HL,(PARAMS)	;do the same for users specified fcb. 
ccca 09				ADD	HL,BC 
cccb 0e 10			LD	C,16		;this many bytes are present in this extent. 
cccd 3a dd d1		CLOSEIT1: LD	A,(BIGDISK)	;8 or 16 bit record numbers? 
ccd0 b7				OR	A 
ccd1 ca e8 cc			JP	Z,CLOSEIT4 
ccd4 7e				LD	A,(HL)		;just 8 bit. Get one from users fcb. 
ccd5 b7				OR	A 
ccd6 1a				LD	A,(DE)		;now get one from directory fcb. 
ccd7 c2 db cc			JP	NZ,CLOSEIT2 
ccda 77				LD	(HL),A		;users byte was zero. Update from directory. 
ccdb b7			CLOSEIT2: OR	A 
ccdc c2 e1 cc			JP	NZ,CLOSEIT3 
ccdf 7e				LD	A,(HL)		;directories byte was zero, update from users fcb. 
cce0 12				LD	(DE),A 
cce1 be			CLOSEIT3: CP	(HL)		;if neither one of these bytes were zero, 
cce2 c2 1f cd			JP	NZ,CLOSEIT7	;then close error if they are not the same. 
cce5 c3 fd cc			JP	CLOSEIT5	;ok so far, get to next byte in fcbs. 
cce8 cd 94 cc		CLOSEIT4: CALL	MOVEWORD	;update users fcb if it is zero. 
cceb eb				EX	DE,HL 
ccec cd 94 cc			CALL	MOVEWORD	;update directories fcb if it is zero. 
ccef eb				EX	DE,HL 
ccf0 1a				LD	A,(DE)		;if these two values are no different, 
ccf1 be				CP	(HL)		;then a close error occured. 
ccf2 c2 1f cd			JP	NZ,CLOSEIT7 
ccf5 13				INC	DE		;check second byte. 
ccf6 23				INC	HL 
ccf7 1a				LD	A,(DE) 
ccf8 be				CP	(HL) 
ccf9 c2 1f cd			JP	NZ,CLOSEIT7 
ccfc 0d				DEC	C		;remember 16 bit values. 
ccfd 13			CLOSEIT5: INC	DE		;bump to next item in table. 
ccfe 23				INC	HL 
ccff 0d				DEC	C		;there are 16 entries only. 
cd00 c2 cd cc			JP	NZ,CLOSEIT1	;continue if more to do. 
cd03 01 ec ff			LD	BC,0FFECH	;backup 20 places (extent byte). 
cd06 09				ADD	HL,BC 
cd07 eb				EX	DE,HL 
cd08 09				ADD	HL,BC 
cd09 1a				LD	A,(DE) 
cd0a be				CP	(HL)		;directory's extent already greater than the 
cd0b da 17 cd			JP	C,CLOSEIT6	;users extent? 
cd0e 77				LD	(HL),A		;no, update directory extent. 
cd0f 01 03 00			LD	BC,3		;and update the record count byte in 
cd12 09				ADD	HL,BC		;directories fcb. 
cd13 eb				EX	DE,HL 
cd14 09				ADD	HL,BC 
cd15 7e				LD	A,(HL)		;get from user. 
cd16 12				LD	(DE),A		;and put in directory. 
cd17 3e ff		CLOSEIT6: LD	A,0FFH		;set 'was open and is now closed' byte. 
cd19 32 d2 d1			LD	(CLOSEFLG),A 
cd1c c3 10 cc			JP	UPDATE1		;update the directory now. 
cd1f 21 45 c7		CLOSEIT7: LD	HL,STATUS	;set return status and then return. 
cd22 35				DEC	(HL) 
cd23 c9				RET	 
cd24			; 
cd24			;   Routine to get the next empty space in the directory. It 
cd24			; will then be cleared for use. 
cd24			; 
cd24 cd 54 c9		GETEMPTY: CALL	CHKWPRT		;make sure disk is not write protected. 
cd27 2a 43 c7			LD	HL,(PARAMS)	;save current parameters (fcb). 
cd2a e5				PUSH	HL 
cd2b 21 ac d1			LD	HL,EMPTYFCB	;use special one for empty space. 
cd2e 22 43 c7			LD	(PARAMS),HL 
cd31 0e 01			LD	C,1		;search for first empty spot in directory. 
cd33 cd 18 cb			CALL	FINDFST		;(* only check first byte *) 
cd36 cd f5 c9			CALL	CKFILPOS	;none? 
cd39 e1				POP	HL 
cd3a 22 43 c7			LD	(PARAMS),HL	;restore original fcb address. 
cd3d c8				RET	Z		;return if no more space. 
cd3e eb				EX	DE,HL 
cd3f 21 0f 00			LD	HL,15		;point to number of records for this file. 
cd42 19				ADD	HL,DE 
cd43 0e 11			LD	C,17		;and clear all of this space. 
cd45 af				XOR	A 
cd46 77			GETMT1:	LD	(HL),A 
cd47 23				INC	HL 
cd48 0d				DEC	C 
cd49 c2 46 cd			JP	NZ,GETMT1 
cd4c 21 0d 00			LD	HL,13		;clear the 's1' byte also. 
cd4f 19				ADD	HL,DE 
cd50 77				LD	(HL),A 
cd51 cd 8c c9			CALL	CHKNMBR		;keep (SCRATCH1) within bounds. 
cd54 cd fd cb			CALL	FCBSET		;write out this fcb entry to directory. 
cd57 c3 78 c9			JP	SETS2B7		;set 's2' byte bit 7 (unmodified at present). 
cd5a			; 
cd5a			;   Routine to close the current extent and open the next one 
cd5a			; for reading. 
cd5a			; 
cd5a af			GETNEXT:XOR	A 
cd5b 32 d2 d1			LD	(CLOSEFLG),A	;clear close flag. 
cd5e cd a2 cc			CALL	CLOSEIT		;close this extent. 
cd61 cd f5 c9			CALL	CKFILPOS 
cd64 c8				RET	Z		;not there??? 
cd65 2a 43 c7			LD	HL,(PARAMS)	;get extent byte. 
cd68 01 0c 00			LD	BC,12 
cd6b 09				ADD	HL,BC 
cd6c 7e				LD	A,(HL)		;and increment it. 
cd6d 3c				INC	A 
cd6e e6 1f			AND	1FH		;keep within range 0-31. 
cd70 77				LD	(HL),A 
cd71 ca 83 cd			JP	Z,GTNEXT1	;overflow? 
cd74 47				LD	B,A		;mask extent byte. 
cd75 3a c5 d1			LD	A,(EXTMASK) 
cd78 a0				AND	B 
cd79 21 d2 d1			LD	HL,CLOSEFLG	;check close flag (0ffh is ok). 
cd7c a6				AND	(HL) 
cd7d ca 8e cd			JP	Z,GTNEXT2	;if zero, we must read in next extent. 
cd80 c3 ac cd			JP	GTNEXT3		;else, it is already in memory. 
cd83 01 02 00		GTNEXT1:LD	BC,2		;Point to the 's2' byte. 
cd86 09				ADD	HL,BC 
cd87 34				INC	(HL)		;and bump it. 
cd88 7e				LD	A,(HL)		;too many extents? 
cd89 e6 0f			AND	0FH 
cd8b ca b6 cd			JP	Z,GTNEXT5	;yes, set error code. 
cd8e			; 
cd8e			;   Get here to open the next extent. 
cd8e			; 
cd8e 0e 0f		GTNEXT2:LD	C,15		;set to check first 15 bytes of fcb. 
cd90 cd 18 cb			CALL	FINDFST		;find the first one. 
cd93 cd f5 c9			CALL	CKFILPOS	;none available? 
cd96 c2 ac cd			JP	NZ,GTNEXT3 
cd99 3a d3 d1			LD	A,(RDWRTFLG)	;no extent present. Can we open an empty one? 
cd9c 3c				INC	A		;0ffh means reading (so not possible). 
cd9d ca b6 cd			JP	Z,GTNEXT5	;or an error. 
cda0 cd 24 cd			CALL	GETEMPTY	;we are writing, get an empty entry. 
cda3 cd f5 c9			CALL	CKFILPOS	;none? 
cda6 ca b6 cd			JP	Z,GTNEXT5	;error if true. 
cda9 c3 af cd			JP	GTNEXT4		;else we are almost done. 
cdac cd 5a cc		GTNEXT3:CALL	OPENIT1		;open this extent. 
cdaf cd bb c8		GTNEXT4:CALL	STRDATA		;move in updated data (rec #, extent #, etc.) 
cdb2 af				XOR	A		;clear status and return. 
cdb3 c3 01 c7			JP	SETSTAT 
cdb6			; 
cdb6			;   Error in extending the file. Too many extents were needed 
cdb6			; or not enough space on the disk. 
cdb6			; 
cdb6 cd 05 c7		GTNEXT5:CALL	IOERR1		;set error code, clear bit 7 of 's2' 
cdb9 c3 78 c9			JP	SETS2B7		;so this is not written on a close. 
cdbc			; 
cdbc			;   Read a sequential file. 
cdbc			; 
cdbc 3e 01		RDSEQ:	LD	A,1		;set sequential access mode. 
cdbe 32 d5 d1			LD	(MODE),A 
cdc1 3e ff		RDSEQ1:	LD	A,0FFH		;don't allow reading unwritten space. 
cdc3 32 d3 d1			LD	(RDWRTFLG),A 
cdc6 cd bb c8			CALL	STRDATA		;put rec# and ext# into fcb. 
cdc9 3a e3 d1			LD	A,(SAVNREC)	;get next record to read. 
cdcc 21 e1 d1			LD	HL,SAVNXT	;get number of records in extent. 
cdcf be				CP	(HL)		;within this extent? 
cdd0 da e6 cd			JP	C,RDSEQ2 
cdd3 fe 80			CP	128		;no. Is this extent fully used? 
cdd5 c2 fb cd			JP	NZ,RDSEQ3	;no. End-of-file. 
cdd8 cd 5a cd			CALL	GETNEXT		;yes, open the next one. 
cddb af				XOR	A		;reset next record to read. 
cddc 32 e3 d1			LD	(SAVNREC),A 
cddf 3a 45 c7			LD	A,(STATUS)	;check on open, successful? 
cde2 b7				OR	A 
cde3 c2 fb cd			JP	NZ,RDSEQ3	;no, error. 
cde6 cd 77 c8		RDSEQ2:	CALL	COMBLK		;ok. compute block number to read. 
cde9 cd 84 c8			CALL	CHKBLK		;check it. Within bounds? 
cdec ca fb cd			JP	Z,RDSEQ3	;no, error. 
cdef cd 8a c8			CALL	LOGICAL		;convert (BLKNMBR) to logical sector (128 byte). 
cdf2 cd d1 c7			CALL	TRKSEC1		;set the track and sector for this block #. 
cdf5 cd b2 c7			CALL	DOREAD		;and read it. 
cdf8 c3 d2 c8			JP	SETNREC		;and set the next record to be accessed. 
cdfb			; 
cdfb			;   Read error occured. Set status and return. 
cdfb			; 
cdfb c3 05 c7		RDSEQ3:	JP	IOERR1 
cdfe			; 
cdfe			;   Write the next sequential record. 
cdfe			; 
cdfe 3e 01		WTSEQ:	LD	A,1		;set sequential access mode. 
ce00 32 d5 d1			LD	(MODE),A 
ce03 3e 00		WTSEQ1:	LD	A,0		;allow an addition empty extent to be opened. 
ce05 32 d3 d1			LD	(RDWRTFLG),A 
ce08 cd 54 c9			CALL	CHKWPRT		;check write protect status. 
ce0b 2a 43 c7			LD	HL,(PARAMS) 
ce0e cd 47 c9			CALL	CKROF1		;check for read only file, (HL) already set to fcb. 
ce11 cd bb c8			CALL	STRDATA		;put updated data into fcb. 
ce14 3a e3 d1			LD	A,(SAVNREC)	;get record number to write. 
ce17 fe 80			CP	128		;within range? 
ce19 d2 05 c7			JP	NC,IOERR1	;no, error(?). 
ce1c cd 77 c8			CALL	COMBLK		;compute block number. 
ce1f cd 84 c8			CALL	CHKBLK		;check number. 
ce22 0e 00			LD	C,0		;is there one to write to? 
ce24 c2 6e ce			JP	NZ,WTSEQ6	;yes, go do it. 
ce27 cd 3e c8			CALL	GETBLOCK	;get next block number within fcb to use. 
ce2a 32 d7 d1			LD	(RELBLOCK),A	;and save. 
ce2d 01 00 00			LD	BC,0		;start looking for space from the start 
ce30 b7				OR	A		;if none allocated as yet. 
ce31 ca 3b ce			JP	Z,WTSEQ2 
ce34 4f				LD	C,A		;extract previous block number from fcb 
ce35 0b				DEC	BC		;so we can be closest to it. 
ce36 cd 5e c8			CALL	EXTBLK 
ce39 44				LD	B,H 
ce3a 4d				LD	C,L 
ce3b cd be cb		WTSEQ2:	CALL	FNDSPACE	;find the next empty block nearest number (BC). 
ce3e 7d				LD	A,L		;check for a zero number. 
ce3f b4				OR	H 
ce40 c2 48 ce			JP	NZ,WTSEQ3 
ce43 3e 02			LD	A,2		;no more space? 
ce45 c3 01 c7			JP	SETSTAT 
ce48 22 e5 d1		WTSEQ3:	LD	(BLKNMBR),HL	;save block number to access. 
ce4b eb				EX	DE,HL		;put block number into (DE). 
ce4c 2a 43 c7			LD	HL,(PARAMS)	;now we must update the fcb for this 
ce4f 01 10 00			LD	BC,16		;newly allocated block. 
ce52 09				ADD	HL,BC 
ce53 3a dd d1			LD	A,(BIGDISK)	;8 or 16 bit block numbers? 
ce56 b7				OR	A 
ce57 3a d7 d1			LD	A,(RELBLOCK)	;(* update this entry *) 
ce5a ca 64 ce			JP	Z,WTSEQ4	;zero means 16 bit ones. 
ce5d cd 64 c9			CALL	ADDA2HL		;(HL)=(HL)+(A) 
ce60 73				LD	(HL),E		;store new block number. 
ce61 c3 6c ce			JP	WTSEQ5 
ce64 4f			WTSEQ4:	LD	C,A		;compute spot in this 16 bit table. 
ce65 06 00			LD	B,0 
ce67 09				ADD	HL,BC 
ce68 09				ADD	HL,BC 
ce69 73				LD	(HL),E		;stuff block number (DE) there. 
ce6a 23				INC	HL 
ce6b 72				LD	(HL),D 
ce6c 0e 02		WTSEQ5:	LD	C,2		;set (C) to indicate writing to un-used disk space. 
ce6e 3a 45 c7		WTSEQ6:	LD	A,(STATUS)	;are we ok so far? 
ce71 b7				OR	A 
ce72 c0				RET	NZ 
ce73 c5				PUSH	BC		;yes, save write flag for bios (register C). 
ce74 cd 8a c8			CALL	LOGICAL		;convert (BLKNMBR) over to loical sectors. 
ce77 3a d5 d1			LD	A,(MODE)	;get access mode flag (1=sequential, 
ce7a 3d				DEC	A		;0=random, 2=special?). 
ce7b 3d				DEC	A 
ce7c c2 bb ce			JP	NZ,WTSEQ9 
ce7f			; 
ce7f			;   Special random i/o from function #40. Maybe for M/PM, but the 
ce7f			; current block, if it has not been written to, will be zeroed 
ce7f			; out and then written (reason?). 
ce7f			; 
ce7f c1				POP	BC 
ce80 c5				PUSH	BC 
ce81 79				LD	A,C		;get write status flag (2=writing unused space). 
ce82 3d				DEC	A 
ce83 3d				DEC	A 
ce84 c2 bb ce			JP	NZ,WTSEQ9 
ce87 e5				PUSH	HL 
ce88 2a b9 d1			LD	HL,(DIRBUF)	;zero out the directory buffer. 
ce8b 57				LD	D,A		;note that (A) is zero here. 
ce8c 77			WTSEQ7:	LD	(HL),A 
ce8d 23				INC	HL 
ce8e 14				INC	D		;do 128 bytes. 
ce8f f2 8c ce			JP	P,WTSEQ7 
ce92 cd e0 c9			CALL	DIRDMA		;tell the bios the dma address for directory access. 
ce95 2a e7 d1			LD	HL,(LOGSECT)	;get sector that starts current block. 
ce98 0e 02			LD	C,2		;set 'writing to unused space' flag. 
ce9a 22 e5 d1		WTSEQ8:	LD	(BLKNMBR),HL	;save sector to write. 
ce9d c5				PUSH	BC 
ce9e cd d1 c7			CALL	TRKSEC1		;determine its track and sector numbers. 
cea1 c1				POP	BC 
cea2 cd b8 c7			CALL	DOWRITE		;now write out 128 bytes of zeros. 
cea5 2a e5 d1			LD	HL,(BLKNMBR)	;get sector number. 
cea8 0e 00			LD	C,0		;set normal write flag. 
ceaa 3a c4 d1			LD	A,(BLKMASK)	;determine if we have written the entire 
cead 47				LD	B,A		;physical block. 
ceae a5				AND	L 
ceaf b8				CP	B 
ceb0 23				INC	HL		;prepare for the next one. 
ceb1 c2 9a ce			JP	NZ,WTSEQ8	;continue until (BLKMASK+1) sectors written. 
ceb4 e1				POP	HL		;reset next sector number. 
ceb5 22 e5 d1			LD	(BLKNMBR),HL 
ceb8 cd da c9			CALL	DEFDMA		;and reset dma address. 
cebb			; 
cebb			;   Normal disk write. Set the desired track and sector then 
cebb			; do the actual write. 
cebb			; 
cebb cd d1 c7		WTSEQ9:	CALL	TRKSEC1		;determine track and sector for this write. 
cebe c1				POP	BC		;get write status flag. 
cebf c5				PUSH	BC 
cec0 cd b8 c7			CALL	DOWRITE		;and write this out. 
cec3 c1				POP	BC 
cec4 3a e3 d1			LD	A,(SAVNREC)	;get number of records in file. 
cec7 21 e1 d1			LD	HL,SAVNXT	;get last record written. 
ceca be				CP	(HL) 
cecb da d2 ce			JP	C,WTSEQ10 
cece 77				LD	(HL),A		;we have to update record count. 
cecf 34				INC	(HL) 
ced0 0e 02			LD	C,2 
ced2			; 
ced2			;*   This area has been patched to correct disk update problem 
ced2			;* when using blocking and de-blocking in the BIOS. 
ced2			; 
ced2 00			WTSEQ10:NOP			;was 'dcr c' 
ced3 00				NOP			;was 'dcr c' 
ced4 21 00 00			LD	HL,0		;was 'jnz wtseq99' 
ced7			; 
ced7			; *   End of patch. 
ced7			; 
ced7 f5				PUSH	AF 
ced8 cd 69 c9			CALL	GETS2		;set 'extent written to' flag. 
cedb e6 7f			AND	7FH		;(* clear bit 7 *) 
cedd 77				LD	(HL),A 
cede f1				POP	AF		;get record count for this extent. 
cedf fe 7f		WTSEQ99:CP	127		;is it full? 
cee1 c2 00 cf			JP	NZ,WTSEQ12 
cee4 3a d5 d1			LD	A,(MODE)	;yes, are we in sequential mode? 
cee7 fe 01			CP	1 
cee9 c2 00 cf			JP	NZ,WTSEQ12 
ceec cd d2 c8			CALL	SETNREC		;yes, set next record number. 
ceef cd 5a cd			CALL	GETNEXT		;and get next empty space in directory. 
cef2 21 45 c7			LD	HL,STATUS	;ok? 
cef5 7e				LD	A,(HL) 
cef6 b7				OR	A 
cef7 c2 fe ce			JP	NZ,WTSEQ11 
cefa 3d				DEC	A		;yes, set record count to -1. 
cefb 32 e3 d1			LD	(SAVNREC),A 
cefe 36 00		WTSEQ11:LD	(HL),0		;clear status. 
cf00 c3 d2 c8		WTSEQ12:JP	SETNREC		;set next record to access. 
cf03			; 
cf03			;   For random i/o, set the fcb for the desired record number 
cf03			; based on the 'r0,r1,r2' bytes. These bytes in the fcb are 
cf03			; used as follows: 
cf03			; 
cf03			;       fcb+35            fcb+34            fcb+33 
cf03			;  |     'r-2'      |      'r-1'      |      'r-0'     | 
cf03			;  |7             0 | 7             0 | 7             0| 
cf03			;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0| 
cf03			;  |    overflow   | | extra |  extent   |   record #  | 
cf03			;  | ______________| |_extent|__number___|_____________| 
cf03			;                     also 's2' 
cf03			; 
cf03			;   On entry, register (C) contains 0ffh if this is a read 
cf03			; and thus we can not access unwritten disk space. Otherwise, 
cf03			; another extent will be opened (for writing) if required. 
cf03			; 
cf03 af			POSITION: XOR	A		;set random i/o flag. 
cf04 32 d5 d1			LD	(MODE),A 
cf07			; 
cf07			;   Special entry (function #40). M/PM ? 
cf07			; 
cf07 c5			POSITN1:PUSH	BC		;save read/write flag. 
cf08 2a 43 c7			LD	HL,(PARAMS)	;get address of fcb. 
cf0b eb				EX	DE,HL 
cf0c 21 21 00			LD	HL,33		;now get byte 'r0'. 
cf0f 19				ADD	HL,DE 
cf10 7e				LD	A,(HL) 
cf11 e6 7f			AND	7FH		;keep bits 0-6 for the record number to access. 
cf13 f5				PUSH	AF 
cf14 7e				LD	A,(HL)		;now get bit 7 of 'r0' and bits 0-3 of 'r1'. 
cf15 17				RLA	 
cf16 23				INC	HL 
cf17 7e				LD	A,(HL) 
cf18 17				RLA	 
cf19 e6 1f			AND	1FH		;and save this in bits 0-4 of (C). 
cf1b 4f				LD	C,A		;this is the extent byte. 
cf1c 7e				LD	A,(HL)		;now get the extra extent byte. 
cf1d 1f				RRA	 
cf1e 1f				RRA	 
cf1f 1f				RRA	 
cf20 1f				RRA	 
cf21 e6 0f			AND	0FH 
cf23 47				LD	B,A		;and save it in (B). 
cf24 f1				POP	AF		;get record number back to (A). 
cf25 23				INC	HL		;check overflow byte 'r2'. 
cf26 6e				LD	L,(HL) 
cf27 2c				INC	L 
cf28 2d				DEC	L 
cf29 2e 06			LD	L,6		;prepare for error. 
cf2b c2 8b cf			JP	NZ,POSITN5	;out of disk space error. 
cf2e 21 20 00			LD	HL,32		;store record number into fcb. 
cf31 19				ADD	HL,DE 
cf32 77				LD	(HL),A 
cf33 21 0c 00			LD	HL,12		;and now check the extent byte. 
cf36 19				ADD	HL,DE 
cf37 79				LD	A,C 
cf38 96				SUB	(HL)		;same extent as before? 
cf39 c2 47 cf			JP	NZ,POSITN2 
cf3c 21 0e 00			LD	HL,14		;yes, check extra extent byte 's2' also. 
cf3f 19				ADD	HL,DE 
cf40 78				LD	A,B 
cf41 96				SUB	(HL) 
cf42 e6 7f			AND	7FH 
cf44 ca 7f cf			JP	Z,POSITN3	;same, we are almost done then. 
cf47			; 
cf47			;  Get here when another extent is required. 
cf47			; 
cf47 c5			POSITN2:PUSH	BC 
cf48 d5				PUSH	DE 
cf49 cd a2 cc			CALL	CLOSEIT		;close current extent. 
cf4c d1				POP	DE 
cf4d c1				POP	BC 
cf4e 2e 03			LD	L,3		;prepare for error. 
cf50 3a 45 c7			LD	A,(STATUS) 
cf53 3c				INC	A 
cf54 ca 84 cf			JP	Z,POSITN4	;close error. 
cf57 21 0c 00			LD	HL,12		;put desired extent into fcb now. 
cf5a 19				ADD	HL,DE 
cf5b 71				LD	(HL),C 
cf5c 21 0e 00			LD	HL,14		;and store extra extent byte 's2'. 
cf5f 19				ADD	HL,DE 
cf60 70				LD	(HL),B 
cf61 cd 51 cc			CALL	OPENIT		;try and get this extent. 
cf64 3a 45 c7			LD	A,(STATUS)	;was it there? 
cf67 3c				INC	A 
cf68 c2 7f cf			JP	NZ,POSITN3 
cf6b c1				POP	BC		;no. can we create a new one (writing?). 
cf6c c5				PUSH	BC 
cf6d 2e 04			LD	L,4		;prepare for error. 
cf6f 0c				INC	C 
cf70 ca 84 cf			JP	Z,POSITN4	;nope, reading unwritten space error. 
cf73 cd 24 cd			CALL	GETEMPTY	;yes we can, try to find space. 
cf76 2e 05			LD	L,5		;prepare for error. 
cf78 3a 45 c7			LD	A,(STATUS) 
cf7b 3c				INC	A 
cf7c ca 84 cf			JP	Z,POSITN4	;out of space? 
cf7f			; 
cf7f			;   Normal return location. Clear error code and return. 
cf7f			; 
cf7f c1			POSITN3:POP	BC		;restore stack. 
cf80 af				XOR	A		;and clear error code byte. 
cf81 c3 01 c7			JP	SETSTAT 
cf84			; 
cf84			;   Error. Set the 's2' byte to indicate this (why?). 
cf84			; 
cf84 e5			POSITN4:PUSH	HL 
cf85 cd 69 c9			CALL	GETS2 
cf88 36 c0			LD	(HL),0C0H 
cf8a e1				POP	HL 
cf8b			; 
cf8b			;   Return with error code (presently in L). 
cf8b			; 
cf8b c1			POSITN5:POP	BC 
cf8c 7d				LD	A,L		;get error code. 
cf8d 32 45 c7			LD	(STATUS),A 
cf90 c3 78 c9			JP	SETS2B7 
cf93			; 
cf93			;   Read a random record. 
cf93			; 
cf93 0e ff		READRAN:LD	C,0FFH		;set 'read' status. 
cf95 cd 03 cf			CALL	POSITION	;position the file to proper record. 
cf98 cc c1 cd			CALL	Z,RDSEQ1	;and read it as usual (if no errors). 
cf9b c9				RET	 
cf9c			; 
cf9c			;   Write to a random record. 
cf9c			; 
cf9c 0e 00		WRITERAN: LD	C,0		;set 'writing' flag. 
cf9e cd 03 cf			CALL	POSITION	;position the file to proper record. 
cfa1 cc 03 ce			CALL	Z,WTSEQ1	;and write as usual (if no errors). 
cfa4 c9				RET	 
cfa5			; 
cfa5			;   Compute the random record number. Enter with (HL) pointing 
cfa5			; to a fcb an (DE) contains a relative location of a record 
cfa5			; number. On exit, (C) contains the 'r0' byte, (B) the 'r1' 
cfa5			; byte, and (A) the 'r2' byte. 
cfa5			; 
cfa5			;   On return, the zero flag is set if the record is within 
cfa5			; bounds. Otherwise, an overflow occured. 
cfa5			; 
cfa5 eb			COMPRAND: EX	DE,HL		;save fcb pointer in (DE). 
cfa6 19				ADD	HL,DE		;compute relative position of record #. 
cfa7 4e				LD	C,(HL)		;get record number into (BC). 
cfa8 06 00			LD	B,0 
cfaa 21 0c 00			LD	HL,12		;now get extent. 
cfad 19				ADD	HL,DE 
cfae 7e				LD	A,(HL)		;compute (BC)=(record #)+(extent)*128. 
cfaf 0f				RRCA			;move lower bit into bit 7. 
cfb0 e6 80			AND	80H		;and ignore all other bits. 
cfb2 81				ADD	A,C		;add to our record number. 
cfb3 4f				LD	C,A 
cfb4 3e 00			LD	A,0		;take care of any carry. 
cfb6 88				ADC	A,B 
cfb7 47				LD	B,A 
cfb8 7e				LD	A,(HL)		;now get the upper bits of extent into 
cfb9 0f				RRCA			;bit positions 0-3. 
cfba e6 0f			AND	0FH		;and ignore all others. 
cfbc 80				ADD	A,B		;add this in to 'r1' byte. 
cfbd 47				LD	B,A 
cfbe 21 0e 00			LD	HL,14		;get the 's2' byte (extra extent). 
cfc1 19				ADD	HL,DE 
cfc2 7e				LD	A,(HL) 
cfc3 87				ADD	A,A		;and shift it left 4 bits (bits 4-7). 
cfc4 87				ADD	A,A 
cfc5 87				ADD	A,A 
cfc6 87				ADD	A,A 
cfc7 f5				PUSH	AF		;save carry flag (bit 0 of flag byte). 
cfc8 80				ADD	A,B		;now add extra extent into 'r1'. 
cfc9 47				LD	B,A 
cfca f5				PUSH	AF		;and save carry (overflow byte 'r2'). 
cfcb e1				POP	HL		;bit 0 of (L) is the overflow indicator. 
cfcc 7d				LD	A,L 
cfcd e1				POP	HL		;and same for first carry flag. 
cfce b5				OR	L		;either one of these set? 
cfcf e6 01			AND	01H		;only check the carry flags. 
cfd1 c9				RET	 
cfd2			; 
cfd2			;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to 
cfd2			; reflect the last record used for a random (or other) file. 
cfd2			; This reads the directory and looks at all extents computing 
cfd2			; the largerst record number for each and keeping the maximum 
cfd2			; value only. Then 'r0', 'r1', and 'r2' will reflect this 
cfd2			; maximum record number. This is used to compute the space used 
cfd2			; by a random file. 
cfd2			; 
cfd2 0e 0c		RANSIZE:LD	C,12		;look thru directory for first entry with 
cfd4 cd 18 cb			CALL	FINDFST		;this name. 
cfd7 2a 43 c7			LD	HL,(PARAMS)	;zero out the 'r0, r1, r2' bytes. 
cfda 11 21 00			LD	DE,33 
cfdd 19				ADD	HL,DE 
cfde e5				PUSH	HL 
cfdf 72				LD	(HL),D		;note that (D)=0. 
cfe0 23				INC	HL 
cfe1 72				LD	(HL),D 
cfe2 23				INC	HL 
cfe3 72				LD	(HL),D 
cfe4 cd f5 c9		RANSIZ1:CALL	CKFILPOS	;is there an extent to process? 
cfe7 ca 0c d0			JP	Z,RANSIZ3	;no, we are done. 
cfea cd 5e c9			CALL	FCB2HL		;set (HL) pointing to proper fcb in dir. 
cfed 11 0f 00			LD	DE,15		;point to last record in extent. 
cff0 cd a5 cf			CALL	COMPRAND	;and compute random parameters. 
cff3 e1				POP	HL 
cff4 e5				PUSH	HL		;now check these values against those 
cff5 5f				LD	E,A		;already in fcb. 
cff6 79				LD	A,C		;the carry flag will be set if those 
cff7 96				SUB	(HL)		;in the fcb represent a larger size than 
cff8 23				INC	HL		;this extent does. 
cff9 78				LD	A,B 
cffa 9e				SBC	A,(HL) 
cffb 23				INC	HL 
cffc 7b				LD	A,E 
cffd 9e				SBC	A,(HL) 
cffe da 06 d0			JP	C,RANSIZ2 
d001 73				LD	(HL),E		;we found a larger (in size) extent. 
d002 2b				DEC	HL		;stuff these values into fcb. 
d003 70				LD	(HL),B 
d004 2b				DEC	HL 
d005 71				LD	(HL),C 
d006 cd 2d cb		RANSIZ2:CALL	FINDNXT		;now get the next extent. 
d009 c3 e4 cf			JP	RANSIZ1		;continue til all done. 
d00c e1			RANSIZ3:POP	HL		;we are done, restore the stack and 
d00d c9				RET			;return. 
d00e			; 
d00e			;   Function to return the random record position of a given 
d00e			; file which has been read in sequential mode up to now. 
d00e			; 
d00e 2a 43 c7		SETRAN:	LD	HL,(PARAMS)	;point to fcb. 
d011 11 20 00			LD	DE,32		;and to last used record. 
d014 cd a5 cf			CALL	COMPRAND	;compute random position. 
d017 21 21 00			LD	HL,33		;now stuff these values into fcb. 
d01a 19				ADD	HL,DE 
d01b 71				LD	(HL),C		;move 'r0'. 
d01c 23				INC	HL 
d01d 70				LD	(HL),B		;and 'r1'. 
d01e 23				INC	HL 
d01f 77				LD	(HL),A		;and lastly 'r2'. 
d020 c9				RET	 
d021			; 
d021			;   This routine select the drive specified in (ACTIVE) and 
d021			; update the login vector and bitmap table if this drive was 
d021			; not already active. 
d021			; 
d021 2a af d1		LOGINDRV: LD	HL,(LOGIN)	;get the login vector. 
d024 3a 42 c7			LD	A,(ACTIVE)	;get the default drive. 
d027 4f				LD	C,A 
d028 cd ea c8			CALL	SHIFTR		;position active bit for this drive 
d02b e5				PUSH	HL		;into bit 0. 
d02c eb				EX	DE,HL 
d02d cd 59 c7			CALL	SELECT		;select this drive. 
d030 e1				POP	HL 
d031 cc 47 c7			CALL	Z,SLCTERR	;valid drive? 
d034 7d				LD	A,L		;is this a newly activated drive? 
d035 1f				RRA	 
d036 d8				RET	C 
d037 2a af d1			LD	HL,(LOGIN)	;yes, update the login vector. 
d03a 4d				LD	C,L 
d03b 44				LD	B,H 
d03c cd 0b c9			CALL	SETBIT 
d03f 22 af d1			LD	(LOGIN),HL	;and save. 
d042 c3 a3 ca			JP	BITMAP		;now update the bitmap. 
d045			; 
d045			;   Function to set the active disk number. 
d045			; 
d045 3a d6 d1		SETDSK:	LD	A,(EPARAM)	;get parameter passed and see if this 
d048 21 42 c7			LD	HL,ACTIVE	;represents a change in drives. 
d04b be				CP	(HL) 
d04c c8				RET	Z 
d04d 77				LD	(HL),A		;yes it does, log it in. 
d04e c3 21 d0			JP	LOGINDRV 
d051			; 
d051			;   This is the 'auto disk select' routine. The firsst byte 
d051			; of the fcb is examined for a drive specification. If non 
d051			; zero then the drive will be selected and loged in. 
d051			; 
d051 3e ff		AUTOSEL:LD	A,0FFH		;say 'auto-select activated'. 
d053 32 de d1			LD	(AUTO),A 
d056 2a 43 c7			LD	HL,(PARAMS)	;get drive specified. 
d059 7e				LD	A,(HL) 
d05a e6 1f			AND	1FH		;look at lower 5 bits. 
d05c 3d				DEC	A		;adjust for (1=A, 2=B) etc. 
d05d 32 d6 d1			LD	(EPARAM),A	;and save for the select routine. 
d060 fe 1e			CP	1EH		;check for 'no change' condition. 
d062 d2 75 d0			JP	NC,AUTOSL1	;yes, don't change. 
d065 3a 42 c7			LD	A,(ACTIVE)	;we must change, save currently active 
d068 32 df d1			LD	(OLDDRV),A	;drive. 
d06b 7e				LD	A,(HL)		;and save first byte of fcb also. 
d06c 32 e0 d1			LD	(AUTOFLAG),A	;this must be non-zero. 
d06f e6 e0			AND	0E0H		;whats this for (bits 6,7 are used for 
d071 77				LD	(HL),A		;something)? 
d072 cd 45 d0			CALL	SETDSK		;select and log in this drive. 
d075 3a 41 c7		AUTOSL1:LD	A,(USERNO)	;move user number into fcb. 
d078 2a 43 c7			LD	HL,(PARAMS)	;(* upper half of first byte *) 
d07b b6				OR	(HL) 
d07c 77				LD	(HL),A 
d07d c9				RET			;and return (all done). 
d07e			; 
d07e			;   Function to return the current cp/m version number. 
d07e			; 
d07e 3e 22		GETVER:	LD	A,022H		;version 2.2 
d080 c3 01 c7			JP	SETSTAT 
d083			; 
d083			;   Function to reset the disk system. 
d083			; 
d083 21 00 00		RSTDSK:	LD	HL,0		;clear write protect status and log 
d086 22 ad d1			LD	(WRTPRT),HL	;in vector. 
d089 22 af d1			LD	(LOGIN),HL 
d08c af				XOR	A		;select drive 'A'. 
d08d 32 42 c7			LD	(ACTIVE),A 
d090 21 80 00			LD	HL,TBUFF	;setup default dma address. 
d093 22 b1 d1			LD	(USERDMA),HL 
d096 cd da c9			CALL	DEFDMA 
d099 c3 21 d0			JP	LOGINDRV	;now log in drive 'A'. 
d09c			; 
d09c			;   Function to open a specified file. 
d09c			; 
d09c cd 72 c9		OPENFIL:CALL	CLEARS2		;clear 's2' byte. 
d09f cd 51 d0			CALL	AUTOSEL		;select proper disk. 
d0a2 c3 51 cc			JP	OPENIT		;and open the file. 
d0a5			; 
d0a5			;   Function to close a specified file. 
d0a5			; 
d0a5 cd 51 d0		CLOSEFIL: CALL	AUTOSEL		;select proper disk. 
d0a8 c3 a2 cc			JP	CLOSEIT		;and close the file. 
d0ab			; 
d0ab			;   Function to return the first occurence of a specified file 
d0ab			; name. If the first byte of the fcb is '?' then the name will 
d0ab			; not be checked (get the first entry no matter what). 
d0ab			; 
d0ab 0e 00		GETFST:	LD	C,0		;prepare for special search. 
d0ad eb				EX	DE,HL 
d0ae 7e				LD	A,(HL)		;is first byte a '?'? 
d0af fe 3f			CP	'?' 
d0b1 ca c2 d0			JP	Z,GETFST1	;yes, just get very first entry (zero length match). 
d0b4 cd a6 c8			CALL	SETEXT		;get the extension byte from fcb. 
d0b7 7e				LD	A,(HL)		;is it '?'? if yes, then we want 
d0b8 fe 3f			CP	'?'		;an entry with a specific 's2' byte. 
d0ba c4 72 c9			CALL	NZ,CLEARS2	;otherwise, look for a zero 's2' byte. 
d0bd cd 51 d0			CALL	AUTOSEL		;select proper drive. 
d0c0 0e 0f			LD	C,15		;compare bytes 0-14 in fcb (12&13 excluded). 
d0c2 cd 18 cb		GETFST1:CALL	FINDFST		;find an entry and then move it into 
d0c5 c3 e9 c9			JP	MOVEDIR		;the users dma space. 
d0c8			; 
d0c8			;   Function to return the next occurence of a file name. 
d0c8			; 
d0c8 2a d9 d1		GETNXT:	LD	HL,(SAVEFCB)	;restore pointers. note that no 
d0cb 22 43 c7			LD	(PARAMS),HL	;other dbos calls are allowed. 
d0ce cd 51 d0			CALL	AUTOSEL		;no error will be returned, but the 
d0d1 cd 2d cb			CALL	FINDNXT		;results will be wrong. 
d0d4 c3 e9 c9			JP	MOVEDIR 
d0d7			; 
d0d7			;   Function to delete a file by name. 
d0d7			; 
d0d7 cd 51 d0		DELFILE:CALL	AUTOSEL		;select proper drive. 
d0da cd 9c cb			CALL	ERAFILE		;erase the file. 
d0dd c3 01 cb			JP	STSTATUS	;set status and return. 
d0e0			; 
d0e0			;   Function to execute a sequential read of the specified 
d0e0			; record number. 
d0e0			; 
d0e0 cd 51 d0		READSEQ:CALL	AUTOSEL		;select proper drive then read. 
d0e3 c3 bc cd			JP	RDSEQ 
d0e6			; 
d0e6			;   Function to write the net sequential record. 
d0e6			; 
d0e6 cd 51 d0		WRTSEQ:	CALL	AUTOSEL		;select proper drive then write. 
d0e9 c3 fe cd			JP	WTSEQ 
d0ec			; 
d0ec			;   Create a file function. 
d0ec			; 
d0ec cd 72 c9		FCREATE:CALL	CLEARS2		;clear the 's2' byte on all creates. 
d0ef cd 51 d0			CALL	AUTOSEL		;select proper drive and get the next 
d0f2 c3 24 cd			JP	GETEMPTY	;empty directory space. 
d0f5			; 
d0f5			;   Function to rename a file. 
d0f5			; 
d0f5 cd 51 d0		RENFILE:CALL	AUTOSEL		;select proper drive and then switch 
d0f8 cd 16 cc			CALL	CHGNAMES	;file names. 
d0fb c3 01 cb			JP	STSTATUS 
d0fe			; 
d0fe			;   Function to return the login vector. 
d0fe			; 
d0fe 2a af d1		GETLOG:	LD	HL,(LOGIN) 
d101 c3 29 d1			JP	GETPRM1 
d104			; 
d104			;   Function to return the current disk assignment. 
d104			; 
d104 3a 42 c7		GETCRNT:LD	A,(ACTIVE) 
d107 c3 01 c7			JP	SETSTAT 
d10a			; 
d10a			;   Function to set the dma address. 
d10a			; 
d10a eb			PUTDMA:	EX	DE,HL 
d10b 22 b1 d1			LD	(USERDMA),HL	;save in our space and then get to 
d10e c3 da c9			JP	DEFDMA		;the bios with this also. 
d111			; 
d111			;   Function to return the allocation vector. 
d111			; 
d111 2a bf d1		GETALOC:LD	HL,(ALOCVECT) 
d114 c3 29 d1			JP	GETPRM1 
d117			; 
d117			;   Function to return the read-only status vector. 
d117			; 
d117 2a ad d1		GETROV:	LD	HL,(WRTPRT) 
d11a c3 29 d1			JP	GETPRM1 
d11d			; 
d11d			;   Function to set the file attributes (read-only, system). 
d11d			; 
d11d cd 51 d0		SETATTR:CALL	AUTOSEL		;select proper drive then save attributes. 
d120 cd 3b cc			CALL	SAVEATTR 
d123 c3 01 cb			JP	STSTATUS 
d126			; 
d126			;   Function to return the address of the disk parameter block 
d126			; for the current drive. 
d126			; 
d126 2a bb d1		GETPARM:LD	HL,(DISKPB) 
d129 22 45 c7		GETPRM1:LD	(STATUS),HL 
d12c c9				RET	 
d12d			; 
d12d			;   Function to get or set the user number. If (E) was (FF) 
d12d			; then this is a request to return the current user number. 
d12d			; Else set the user number from (E). 
d12d			; 
d12d 3a d6 d1		GETUSER:LD	A,(EPARAM)	;get parameter. 
d130 fe ff			CP	0FFH		;get user number? 
d132 c2 3b d1			JP	NZ,SETUSER 
d135 3a 41 c7			LD	A,(USERNO)	;yes, just do it. 
d138 c3 01 c7			JP	SETSTAT 
d13b e6 1f		SETUSER:AND	1FH		;no, we should set it instead. keep low 
d13d 32 41 c7			LD	(USERNO),A	;bits (0-4) only. 
d140 c9				RET	 
d141			; 
d141			;   Function to read a random record from a file. 
d141			; 
d141 cd 51 d0		RDRANDOM: CALL	AUTOSEL		;select proper drive and read. 
d144 c3 93 cf			JP	READRAN 
d147			; 
d147			;   Function to compute the file size for random files. 
d147			; 
d147 cd 51 d0		WTRANDOM: CALL	AUTOSEL		;select proper drive and write. 
d14a c3 9c cf			JP	WRITERAN 
d14d			; 
d14d			;   Function to compute the size of a random file. 
d14d			; 
d14d cd 51 d0		FILESIZE: CALL	AUTOSEL		;select proper drive and check file length 
d150 c3 d2 cf			JP	RANSIZE 
d153			; 
d153			;   Function #37. This allows a program to log off any drives. 
d153			; On entry, set (DE) to contain a word with bits set for those 
d153			; drives that are to be logged off. The log-in vector and the 
d153			; write protect vector will be updated. This must be a M/PM 
d153			; special function. 
d153			; 
d153 2a 43 c7		LOGOFF:	LD	HL,(PARAMS)	;get drives to log off. 
d156 7d				LD	A,L		;for each bit that is set, we want 
d157 2f				CPL			;to clear that bit in (LOGIN) 
d158 5f				LD	E,A		;and (WRTPRT). 
d159 7c				LD	A,H 
d15a 2f				CPL	 
d15b 2a af d1			LD	HL,(LOGIN)	;reset the login vector. 
d15e a4				AND	H 
d15f 57				LD	D,A 
d160 7d				LD	A,L 
d161 a3				AND	E 
d162 5f				LD	E,A 
d163 2a ad d1			LD	HL,(WRTPRT) 
d166 eb				EX	DE,HL 
d167 22 af d1			LD	(LOGIN),HL	;and save. 
d16a 7d				LD	A,L		;now do the write protect vector. 
d16b a3				AND	E 
d16c 6f				LD	L,A 
d16d 7c				LD	A,H 
d16e a2				AND	D 
d16f 67				LD	H,A 
d170 22 ad d1			LD	(WRTPRT),HL	;and save. all done. 
d173 c9				RET	 
d174			; 
d174			;   Get here to return to the user. 
d174			; 
d174 3a de d1		GOBACK:	LD	A,(AUTO)	;was auto select activated? 
d177 b7				OR	A 
d178 ca 91 d1			JP	Z,GOBACK1 
d17b 2a 43 c7			LD	HL,(PARAMS)	;yes, but was a change made? 
d17e 36 00			LD	(HL),0		;(* reset first byte of fcb *) 
d180 3a e0 d1			LD	A,(AUTOFLAG) 
d183 b7				OR	A 
d184 ca 91 d1			JP	Z,GOBACK1 
d187 77				LD	(HL),A		;yes, reset first byte properly. 
d188 3a df d1			LD	A,(OLDDRV)	;and get the old drive and select it. 
d18b 32 d6 d1			LD	(EPARAM),A 
d18e cd 45 d0			CALL	SETDSK 
d191 2a 0f c7		GOBACK1:LD	HL,(USRSTACK)	;reset the users stack pointer. 
d194 f9				LD	SP,HL 
d195 2a 45 c7			LD	HL,(STATUS)	;get return status. 
d198 7d				LD	A,L		;force version 1.4 compatability. 
d199 44				LD	B,H 
d19a c9				RET			;and go back to user. 
d19b			; 
d19b			;   Function #40. This is a special entry to do random i/o. 
d19b			; For the case where we are writing to unused disk space, this 
d19b			; space will be zeroed out first. This must be a M/PM special 
d19b			; purpose function, because why would any normal program even 
d19b			; care about the previous contents of a sector about to be 
d19b			; written over. 
d19b			; 
d19b cd 51 d0		WTSPECL:CALL	AUTOSEL		;select proper drive. 
d19e 3e 02			LD	A,2		;use special write mode. 
d1a0 32 d5 d1			LD	(MODE),A 
d1a3 0e 00			LD	C,0		;set write indicator. 
d1a5 cd 07 cf			CALL	POSITN1		;position the file. 
d1a8 cc 03 ce			CALL	Z,WTSEQ1	;and write (if no errors). 
d1ab c9				RET	 
d1ac			; 
d1ac			;************************************************************** 
d1ac			;* 
d1ac			;*     BDOS data storage pool. 
d1ac			;* 
d1ac			;************************************************************** 
d1ac			; 
d1ac e5			EMPTYFCB: DEFB	0E5H		;empty directory segment indicator. 
d1ad 00 00		WRTPRT:	DEFW	0		;write protect status for all 16 drives. 
d1af 00 00		LOGIN:	DEFW	0		;drive active word (1 bit per drive). 
d1b1 80 00		USERDMA:DEFW	080H		;user's dma address (defaults to 80h). 
d1b3			; 
d1b3			;   Scratch areas from parameter block. 
d1b3			; 
d1b3 00 00		SCRATCH1: DEFW	0		;relative position within dir segment for file (0-3). 
d1b5 00 00		SCRATCH2: DEFW	0		;last selected track number. 
d1b7 00 00		SCRATCH3: DEFW	0		;last selected sector number. 
d1b9			; 
d1b9			;   Disk storage areas from parameter block. 
d1b9			; 
d1b9 00 00		DIRBUF:	DEFW	0		;address of directory buffer to use. 
d1bb 00 00		DISKPB:	DEFW	0		;contains address of disk parameter block. 
d1bd 00 00		CHKVECT:DEFW	0		;address of check vector. 
d1bf 00 00		ALOCVECT: DEFW	0		;address of allocation vector (bit map). 
d1c1			; 
d1c1			;   Parameter block returned from the bios. 
d1c1			; 
d1c1 00 00		SECTORS:DEFW	0		;sectors per track from bios. 
d1c3 00			BLKSHFT:DEFB	0		;block shift. 
d1c4 00			BLKMASK:DEFB	0		;block mask. 
d1c5 00			EXTMASK:DEFB	0		;extent mask. 
d1c6 00 00		DSKSIZE:DEFW	0		;disk size from bios (number of blocks-1). 
d1c8 00 00		DIRSIZE:DEFW	0		;directory size. 
d1ca 00 00		ALLOC0:	DEFW	0		;storage for first bytes of bit map (dir space used). 
d1cc 00 00		ALLOC1:	DEFW	0 
d1ce 00 00		OFFSET:	DEFW	0		;first usable track number. 
d1d0 00 00		XLATE:	DEFW	0		;sector translation table address. 
d1d2			; 
d1d2			; 
d1d2 00			CLOSEFLG: DEFB	0		;close flag (=0ffh is extent written ok). 
d1d3 00			RDWRTFLG: DEFB	0		;read/write flag (0ffh=read, 0=write). 
d1d4 00			FNDSTAT:DEFB	0		;filename found status (0=found first entry). 
d1d5 00			MODE:	DEFB	0		;I/o mode select (0=random, 1=sequential, 2=special random). 
d1d6 00			EPARAM:	DEFB	0		;storage for register (E) on entry to bdos. 
d1d7 00			RELBLOCK: DEFB	0		;relative position within fcb of block number written. 
d1d8 00			COUNTER:DEFB	0		;byte counter for directory name searches. 
d1d9 00 00 00 00	SAVEFCB:DEFW	0,0		;save space for address of fcb (for directory searches). 
d1dd 00			BIGDISK:DEFB	0		;if =0 then disk is > 256 blocks long. 
d1de 00			AUTO:	DEFB	0		;if non-zero, then auto select activated. 
d1df 00			OLDDRV:	DEFB	0		;on auto select, storage for previous drive. 
d1e0 00			AUTOFLAG: DEFB	0		;if non-zero, then auto select changed drives. 
d1e1 00			SAVNXT:	DEFB	0		;storage for next record number to access. 
d1e2 00			SAVEXT:	DEFB	0		;storage for extent number of file. 
d1e3 00 00		SAVNREC:DEFW	0		;storage for number of records in file. 
d1e5 00 00		BLKNMBR:DEFW	0		;block number (physical sector) used within a file or logical sect 
d1e7 00 00		LOGSECT:DEFW	0		;starting logical (128 byte) sector of block (physical sector). 
d1e9 00			FCBPOS:	DEFB	0		;relative position within buffer for fcb of file of interest. 
d1ea 00 00		FILEPOS:DEFW	0		;files position within directory (0 to max entries -1). 
d1ec			; 
d1ec			;   Disk directory buffer checksum bytes. One for each of the 
d1ec			; 16 possible drives. 
d1ec			; 
d1ec 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00	CKSUMTBL: DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 
d1fc			; 
d1fc			;   Extra space ? 
d1fc			; 
d1fc 00 00 00 00		DEFB	0,0,0,0 
d200			; 
d200			;************************************************************** 
d200			;* 
d200			;*        B I O S 
d200			;* 
d200			;************************************************************** 
d200			; 
d200			;	customized cbios for STM32ZXCPM CP/M 2.2 alteration 
d200			; 
d200			ccp:	equ	(MEM-7)*1024;base of ccp 
d200			bdos:	equ	ccp+0806h	;bdos entry 
d200			bios:	equ	ccp+01600h	;base of bios 
d200			cdisk:	equ	0004h		;address of current disk number 0=a,... 15=p 
d200			iobyte:	equ	0003h		;intel i/o byte 
d200			disks:	equ	08h		;number of disks in the system 
d200			; 
d200			;	I/O ports 
d200			; 
d200			cstp:	equ	0		;console status port 
d200			ciop:	equ	1		;console input/output port 
d200			sstp:	equ	2		;serial status port 
d200			siop:	equ	3		;serial input/output port 
d200			ddskp:	equ	8		;disk selct disk port 
d200			dtrkp:	equ	9		;disk select track  low/high byte port 
d200			dsecp:	equ	10		;disk select sector  low/high byte port 
d200			ddmalp:	equ	11		;disk set dma addr low byte port 
d200			ddmahp:	equ	12		;disk set dma addr high byte port 
d200			dcmdp:	equ	13		;disk command port 
d200			 
d200			; 
d200			nsects:	equ	($-ccp)/128	;warm start sector count 
d200			; 
d200			;	jump vector for individual subroutines 
d200			; 
d200			 
d200 c3 c2 d3			JP	BOOT	;cold start 
d203 c3 cf d3		WBOOTE:	JP	WBOOT	;warm start 
d206 c3 5c d4			JP	CONST	;console status 
d209 c3 5f d4			JP	CONIN	;console character in 
d20c c3 6b d4			JP	CONOUT	;console character out 
d20f c3 6f d4			JP	LIST	;LIST character out 
d212 c3 73 d4			JP	PUNCH	;PUNCH character out 
d215 c3 7e d4			JP	READER	;READER character out 
d218 c3 8a d4			JP	HOME	;move head to HOME position 
d21b c3 91 d4			JP	SELDSK	;select disk 
d21e c3 aa d4			JP	SETTRK	;set track number 
d221 c3 b1 d4			JP	SETSEC	;set sector number 
d224 c3 bc d4			JP	SETDMA	;set dma address 
d227 c3 dd d4			JP	READ	;READ disk 
d22a c3 e9 d4			JP	WRITE	;WRITE disk 
d22d c3 71 d4			JP	LISTST	;return LIST status 
d230 c3 b8 d4			JP	SECTRN	;sector translate 
d233			; 
d233			;	fixed data tables for four-drive standard 
d233			;	ibm-compatible 8" disks 
d233			;	no translations 
d233			; 
d233			;	disk Parameter header for disk 00 
d233 00 00 00 00	dpbase:	defw	0000h, 0000h 
d237 00 00 00 00	    defw	0000h, 0000h 
d23b 27 d5 b3 d3	    defw	dirbf, dpblk 
d23f 9f d6 a7 d5	    defw	chk00, all00 
d243			;	disk parameter header for disk 01 
d243 00 00 00 00	    defw	0000h, 0000h 
d247 00 00 00 00	    defw	0000h, 0000h 
d24b 27 d5 b3 d3	    defw	dirbf, dpblk 
d24f af d6 c6 d5	    defw	chk01, all01 
d253			;	disk parameter header for disk 02 
d253 00 00 00 00	    defw	0000h, 0000h 
d257 00 00 00 00	    defw	0000h, 0000h 
d25b 27 d5 b3 d3	    defw	dirbf, dpblk 
d25f bf d6 e5 d5	    defw	chk02, all02 
d263			;	disk parameter header for disk 03 
d263 00 00 00 00	    defw	0000h, 0000h 
d267 00 00 00 00	    defw	0000h, 0000h 
d26b 27 d5 b3 d3	    defw	dirbf, dpblk 
d26f cf d6 04 d6	    defw	chk03, all03 
d273			;	disk parameter header for disk 04 
d273 00 00 00 00	    defw	0000h, 0000h 
d277 00 00 00 00	    defw	0000h, 0000h 
d27b 27 d5 b3 d3	    defw	dirbf, dpblk 
d27f df d6 23 d6	    defw	chk04, all04 
d283			;	disk parameter header for disk 05 
d283 00 00 00 00	    defw	0000h, 0000h 
d287 00 00 00 00	    defw	0000h, 0000h 
d28b 27 d5 b3 d3	    defw	dirbf, dpblk 
d28f ef d6 42 d6	    defw	chk05, all05 
d293			;	disk parameter header for disk 06 
d293 00 00 00 00	    defw	0000h, 0000h 
d297 00 00 00 00	    defw	0000h, 0000h 
d29b 27 d5 b3 d3	    defw	dirbf, dpblk 
d29f ff d6 61 d6	    defw	chk06, all06 
d2a3			;	disk parameter header for disk 07 
d2a3 00 00 00 00	    defw	0000h, 0000h 
d2a7 00 00 00 00	    defw	0000h, 0000h 
d2ab 27 d5 b3 d3	    defw	dirbf, dpblk 
d2af 0f d7 80 d6	    defw	chk07, all07 
d2b3			; 
d2b3			;	sector translate vector 
d2b3			trans: 
d2b3 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f		defm	  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15 
d2c3 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f		defm	 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31 
d2d3 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f		defm	 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47 
d2e3 30 31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f		defm	 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63 
d2f3 40 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f		defm	 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79 
d303 50 51 52 53 54 55 56 57 58 59 5a 5b 5c 5d 5e 5f		defm	 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95 
d313 60 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f		defm	 96, 97, 98, 99,100,101,102,103,104,105,106,107,108,109,110,111 
d323 70 71 72 73 74 75 76 77 78 79 7a 7b 7c 7d 7e 7f		defm	112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127 
d333 80 81 82 83 84 85 86 87 88 89 8a 8b 8c 8d 8e 8f		defm	128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143 
d343 90 91 92 93 94 95 96 97 98 99 9a 9b 9c 9d 9e 9f		defm	144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159 
d353 a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 aa ab ac ad ae af		defm	160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175 
d363 b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 ba bb bc bd be bf		defm	176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191 
d373 c0 c1 c2 c3 c4 c5 c6 c7 c8 c9 ca cb cc cd ce cf		defm	192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207 
d383 d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 da db dc dd de df		defm	208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223 
d393 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 ea eb ec ed ee ef		defm	224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239 
d3a3 f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 fa fb fc fd fe ff		defm	240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255 
d3b3			; 
d3b3			dpblk:	;disk parameter block for all disks. 
d3b3 00 01		    defw	256		;sectors per track 
d3b5 04			    defm	4		;block shift factor 
d3b6 0f			    defm	15		;block mask 
d3b7 00			    defm	0		;extent mask 
d3b8 ef 0f		    defw	4079		;disk size-1 
d3ba ff 00		    defw	255		;directory max 
d3bc f0			    defm	240		;alloc 0 
d3bd 00			    defm	0		;alloc 1 
d3be 00 00		    defw	0		;check size 
d3c0 01 00		    defw	1		;track offset 
d3c2			; 
d3c2			;	end of fixed tables 
d3c2			; 
d3c2			;	individual subroutines to perform each function 
d3c2			BOOT:	;simplest case is to just perform parameter initialization 
d3c2 af			    XOR	a		;zero in the accum 
d3c3 32 03 00		    LD	(iobyte),A	;clear the iobyte 
d3c6 32 04 00		    LD	(cdisk),A	;select disk zero 
d3c9 31 80 00		    LD	sp, 80h		;use end of memory for stack 
d3cc c3 03 d4		    JP	gocpm		;initialize and go to cp/m 
d3cf			; 
d3cf			WBOOT:	;simplest case is to READ the disk until all sectors loaded 
d3cf 31 80 00		    LD	sp, 80h		;use space below buffer for stack 
d3d2 0e 00		    LD 	c, 0		;select disk 0 
d3d4 cd 91 d4		    call	SELDSK 
d3d7 cd 8a d4		    call	HOME		;go to track 00 
d3da			; 
d3da 06 2c		    LD 	b, nsects	;b counts * of sectors to load 
d3dc 0e 00		    LD 	c, 0		;c has the current track number 
d3de 16 01		    LD 	d, 1		;d has the next sector to READ 
d3e0			;	note that we begin by READing track 0, sector 2 since sector 1 
d3e0			;	contains the cold start loader, which is skipped in a warm start 
d3e0 21 00 bc		    LD	HL, ccp		;base of cp/m (initial load point) 
d3e3			load1:	;load	one more sector 
d3e3 c5			    PUSH	BC		;save sector count, current track 
d3e4 d5			    PUSH	DE		;save next sector to READ 
d3e5 e5			    PUSH	HL		;save dma address 
d3e6 4a			    LD 		c, d		;get sector address to register C 
d3e7 cd b1 d4		    call	SETSEC		;set sector address from register C 
d3ea c1			    pop		BC		;recall dma address to b, C 
d3eb c5			    PUSH	BC		;replace on stack for later recall 
d3ec cd bc d4		    call	SETDMA		;set dma address from b, C 
d3ef			; 
d3ef			;	drive set to 0, track set, sector set, dma address set 
d3ef cd dd d4		    call	READ 
d3f2 fe 00		    CP	00h		;any errors? 
d3f4 c2 cf d3		    JP	NZ,WBOOT	;retry the entire BOOT if an error occurs 
d3f7			; 
d3f7			;	no error, move to next sector 
d3f7 e1			    pop	HL		;recall dma address 
d3f8 11 80 00		    LD	DE, 128		;dma=dma+128 
d3fb 19			    ADD	HL,DE		;new dma address is in h, l 
d3fc d1			    pop	DE		;recall sector address 
d3fd c1			    pop	BC		;recall number of sectors remaining, and current trk 
d3fe 14			    INC D		;next sector to READ 
d3ff 05			    DEC	b		;sectors=sectors-1 
d400 c2 e3 d3		    JP	NZ,load1	;loop for READ next sector 
d403			; 
d403			; 
d403			;	end of	load operation, set parameters and go to cp/m 
d403			gocpm: 
d403 3e c3		    LD 	a, 0c3h		;c3 is a jmp instruction 
d405 32 00 00		    LD	(0),A		;for jmp to WBOOT 
d408 21 03 d2		    LD	HL, WBOOTE	;WBOOT entry point 
d40b 22 01 00		    LD	(1),HL		;set address field for jmp at 0 
d40e			; 
d40e 32 05 00		    LD	(5),A		;for jmp to bdos 
d411 21 06 c4		    LD	HL, bdos	;bdos entry point 
d414 22 06 00		    LD	(6),HL		;address field of Jump at 5 to bdos 
d417			; 
d417 01 80 00		    LD	BC, 80h		;default dma address is 80h 
d41a cd bc d4		    call	SETDMA 
d41d			; 
d41d			;out boot message 
d41d			; 
d41d 21 2d d4				ld	hl, bmsg 
d420			msgloop:		 
d420 7e					ld	a,(hl) 
d421 b7					OR	A 
d422 ca 4d d4				jp	z, gocpm1 
d425 4f					ld	c,a 
d426 cd 6b d4				call CONOUT 
d429 23					inc HL 
d42a c3 20 d4				JP	msgloop 
d42d 0d 0a		bmsg:	defb 0dh, 0ah 
d42f .. 0d 0a 00		defb '54k CP/M 2.2 for STM32ZXCPM', 0dh, 0ah, 0 
d44d			; 
d44d			gocpm1: 
d44d fb			    ei			;enable the interrupt system 
d44e 3a 04 00		    LD	A,(cdisk)	;get current disk number 
d451 fe 08		    cp	disks		;see if valid disk number 
d453 da 58 d4		    jp	c,diskok	;disk valid, go to ccp 
d456 3e 00		    ld	a,0		;invalid disk, change to disk 0 
d458 4f			diskok:	LD 	c, a		;send to the ccp 
d459 c3 00 bc				JP	ccp		;go to cp/m for further processing 
d45c			; 
d45c			; 
d45c			;	simple i/o handlers (must be filled in by user) 
d45c			;	in each case, the entry point is provided, with space reserved 
d45c			;	to insert your own code 
d45c			; 
d45c			CONST:	;console status, return 0ffh if character READy, 00h if not 
d45c db 00		    in 	a,(cstp)		;get status 
d45e c9			    ret 
d45f			; 
d45f			CONIN:	;console character into register a 
d45f db 00		    in 	a,(cstp)		;get status 
d461 e6 ff		    and	0ffh		;check RxRDY 
d463 ca 5f d4		    jp 	z,CONIN		;loop until char READy 
d466 db 01		    in 	a,(ciop)		;get char 
d468 e6 7f		    AND	7fh		;strip parity bit 
d46a c9			    ret 
d46b			; 
d46b			CONOUT:	;console character output from register c 
d46b 79			    ld	a, c 
d46c d3 01		    out	(ciop),a		;out to port 
d46e c9			    ret 
d46f			; 
d46f			LIST:	;LIST character from register c 
d46f 79			    LD 	a, c	  	;character to register a 
d470 c9			    ret		  	;null subroutine 
d471			; 
d471			LISTST:	;return LIST status (0 if not READy, 1 if READy) 
d471 af			    XOR	a	 	;0 is always ok to return 
d472 c9			    ret 
d473			; 
d473			PUNCH:	;PUNCH	character from	register C 
d473 db 02		    in 	a,(sstp)	;get status 
d475 e6 01		    and	001h		;check TxRDY bit 
d477 ca 73 d4		    jp 	z,PUNCH		;loop until char READy 
d47a 79			    LD 	a, c		;character to register a 
d47b d3 03		    out (siop), a 
d47d c9			    ret			;null subroutine 
d47e			; 
d47e			; 
d47e			READER:	;READER character into register a from READER device 
d47e db 02		    in 	a,(sstp)	;get status 
d480 e6 02		    and	002h		;check RxRDY bit 
d482 ca 7e d4		    jp 	z,READER	;loop until char READy 
d485 db 03		    in	a, (siop) 
d487 e6 7f		    AND    7fh		;remember to strip parity bit 
d489 c9			    ret 
d48a			; 
d48a			; 
d48a			;	i/o drivers for the disk follow 
d48a			;	for now, we will simply store the parameters away for use 
d48a			;	in the READ and WRITE	subroutines 
d48a			; 
d48a			HOME:	;move to the track 00	position of current drive 
d48a			;	translate this call into a SETTRK call with Parameter 00 
d48a 01 00 00		    LD     bc, 0		;select track 0 
d48d cd aa d4		    call   SETTRK 
d490 c9			    ret			;we will move to 00 on first READ/WRITE 
d491			; 
d491			SELDSK:	;select disk given by register c 
d491 21 00 00		    LD	HL, 0000h	;error return code 
d494 79			    LD 	a, c 
d495 32 26 d5		    LD	(diskno),A 
d498 fe 08		    CP	disks		;must be between 0 and 3 
d49a d0			    RET	NC		;no carry if 4, 5,... 
d49b			;	disk number is in the proper range 
d49b			;	defs	10		;space for disk select 
d49b			;	compute proper disk Parameter header address 
d49b 3a 26 d5		    LD	A,(diskno) 
d49e 6f			    LD 	l, a		;l=disk number 0, 1, 2, 3 
d49f 26 00		    LD 	h, 0		;high order zero 
d4a1 29			    ADD	HL,HL		;*2 
d4a2 29			    ADD	HL,HL		;*4 
d4a3 29			    ADD	HL,HL		;*8 
d4a4 29			    ADD	HL,HL		;*16 (size of each header) 
d4a5 11 33 d2		    LD	DE, dpbase 
d4a8 19			    ADD	HL,DE		;hl=,dpbase (diskno*16) Note typo here in original source. 
d4a9 c9			    ret 
d4aa			; 
d4aa			SETTRK:	;set track given by register c 
d4aa 69			    LD 	l, c 
d4ab 26 00		    LD 	h, 0 
d4ad 22 20 d5		    LD	(track),HL 
d4b0 c9			    ret 
d4b1			; 
d4b1			SETSEC:	;set sector given by register c 
d4b1 69			    LD 	l, c 
d4b2 26 00		    LD 	h, 0 
d4b4 22 22 d5		    LD	(sector),HL 
d4b7 c9			    ret 
d4b8			; 
d4b8			; 
d4b8			SECTRN: 
d4b8			    ;translate the sector given by bc using the 
d4b8			    ;translate table given by de 
d4b8			;    EX	DE,HL		;hl=.trans 
d4b8			;    ADD	HL,BC		;hl=.trans (sector) 
d4b8			;    LD 	l, (hl)		;l=trans (sector) 
d4b8 69			    LD	l, c 
d4b9 26 00		    LD 	h, 0		;hl=trans (sector) 
d4bb c9			    ret			;with value in hl 
d4bc			; 
d4bc			SETDMA:	;set	dma address given by registers b and c 
d4bc 69			    LD 	l, c		;low order address 
d4bd 60			    LD 	h, b		;high order address 
d4be 22 24 d5		    LD	(dmaad),HL	;save the address 
d4c1 c9			    ret 
d4c2			; 
d4c2			SETDOP:	;set disk operation parameters 
d4c2 3a 26 d5			ld	a,(diskno)		;disk 
d4c5 d3 08			out	(ddskp),a			; 
d4c7 2a 20 d5			ld	HL,(track)		;track 
d4ca 7d				ld	a,l 
d4cb d3 09			out	(dtrkp),a			;lba bits 0 - 7 
d4cd 2a 22 d5			ld	HL,(sector)		;sector 
d4d0 7d				ld	a,l 
d4d1 d3 0a			out	(dsecp),a			;lba bits 0 - 7 
d4d3 2a 24 d5			ld	HL,(dmaad)		;dma addres 
d4d6 7d				ld	a,l 
d4d7 d3 0b			out	(ddmalp),a			;lba bits 0 - 7 
d4d9 7c				ld	a,h 
d4da d3 0c			out	(ddmahp),a			;lba bits 8 - 15 
d4dc c9				ret 
d4dd			READ: 
d4dd			;Read one CP/M sector from disk. 
d4dd			;Return a 00h in register a if the operation completes properly, and 0lh if an error occurs during the READ. 
d4dd			;Disk number in 'diskno' 
d4dd			;Track number in 'track' 
d4dd			;Sector number in 'sector' 
d4dd			;Dma address in 'dmaad' (0-65535) 
d4dd			; 
d4dd cd c2 d4			CALL SETDOP 
d4e0 3e 00			ld	a,00h			;Read sector command 
d4e2 d3 0d			out	(dcmdp),a 
d4e4 db 0d			in	a,(dcmdp)			;get status 
d4e6 e6 01			and	01h			;error bit 
d4e8 c9				ret 
d4e9			 
d4e9			WRITE: 
d4e9			;Write one CP/M sector to disk. 
d4e9			;Return a 00h in register a if the operation completes properly, and 0lh if an error occurs during the READ or WRITE 
d4e9			;Disk number in 'diskno' 
d4e9			;Track number in 'track' 
d4e9			;Sector number in 'sector' 
d4e9			;Dma address in 'dmaad' (0-65535) 
d4e9 cd c2 d4			CALL SETDOP 
d4ec 3e 01			ld	a,01h			;Write sector command 
d4ee d3 0d			out	(dcmdp),a 
d4f0 db 0d			in	a,(dcmdp)			;get status 
d4f2 e6 01			and	01h			;error bit 
d4f4 c9				ret 
d4f5			 
d4f5			; 
d4f5			;patch CCP for user 0 and drive A COM search 
d4f5			; 
d4f5			ptchda: 
d4f5 21 f5 c3			ld	hl,CHGDRV 
d4f8 b6				or	(hl) 
d4f9 c2 03 d5			jp	NZ,ptchu0 
d4fc 34				inc	(hl) 
d4fd 11 db c3			ld	de,FCB+9 
d500 c3 d2 c2			jp	UNKWN2 
d503			ptchu0: 
d503 cd 13 bd			call	GETUSR 
d506 b7				or	a 
d507 ca 70 c3			jp	Z,UNKWN9	;error 
d50a 5f				ld	e,a 
d50b d5				push	de 
d50c 1e 00			ld	e,0 
d50e cd 15 bd			call	GETSETUC 
d511 cd d0 bc			call	OPENFCB 
d514 d1				pop	de 
d515 f5				push	AF 
d516 cd 15 bd			call	GETSETUC 
d519 f1				pop	AF 
d51a c2 e3 c2			jp	NZ,UNKWN25	;continue 
d51d c3 70 c3			jp	UNKWN9	;error 
d520			 
d520			; 
d520			;	the remainder of the cbios is reserved uninitialized 
d520			;	data area, and does not need to be a Part of the 
d520			;	system	memory image (the space must be available, 
d520			;	however, between"begdat" and"enddat"). 
d520			; 
d520 00...		track:	defs	2		;two bytes for expansion 
d522 00...		sector:	defs	2		;two bytes for expansion 
d524 00...		dmaad:	defs	2		;direct memory address 
d526 00...		diskno:	defs	1		;disk number 0-15 
d527			; 
d527			;	scratch ram area for bdos use 
d527			begdat:	equ	$	 	;beginning of data area 
d527 00...		dirbf:	defs	128	 	;scratch directory area 
d5a7 00...		all00:	defs	31	 	;allocation vector 0 
d5c6 00...		all01:	defs	31	 	;allocation vector 1 
d5e5 00...		all02:	defs	31	 	;allocation vector 2 
d604 00...		all03:	defs	31	 	;allocation vector 3 
d623 00...		all04:	defs	31	 	;allocation vector 4 
d642 00...		all05:	defs	31	 	;allocation vector 5 
d661 00...		all06:	defs	31	 	;allocation vector 6 
d680 00...		all07:	defs	31	 	;allocation vector 7 
d69f 00...		chk00:	defs	16		;check vector 0 
d6af 00...		chk01:	defs	16		;check vector 1 
d6bf 00...		chk02:	defs	16	 	;check vector 2 
d6cf 00...		chk03:	defs	16	 	;check vector 3 
d6df 00...		chk04:	defs	16		;check vector 4 
d6ef 00...		chk05:	defs	16		;check vector 5 
d6ff 00...		chk06:	defs	16	 	;check vector 6 
d70f 00...		chk07:	defs	16	 	;check vector 7 
d71f			; 
d71f			enddat:	equ	$	 	;end of data area 
d71f			datsiz:	equ	$-begdat;	;size of data area 
d71f			 
d71f			; 
d71f			;* 
d71f			;******************   E N D   O F   C P / M   ***************** 
d71f			;* 
d71f			 
# End of file CPM22.Z80
d71f
