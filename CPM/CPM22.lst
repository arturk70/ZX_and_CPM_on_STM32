# File CPM22.Z80
0000			;************************************************************** 
0000			;* 
0000			;*             C P / M   version   2 . 2 
0000			;* 
0000			;*   Reconstructed from memory image on February 27, 1981 
0000			;* 
0000			;*                by Clark A. Calkins 
0000			;* 
0000			;************************************************************** 
0000			; 
0000			;   Set memory limit here. This is the amount of contigeous 
0000			; ram starting from 0000. CP/M will reside at the end of this space. 
0000			; 
0000			MEM:	EQU	50		;total amount of memory. 
0000			; 
0000			IOBYTE:	EQU	3		;i/o definition byte. 
0000			TDRIVE:	EQU	4		;current drive name and user number. 
0000			ENTRY:	EQU	5		;entry point for the cp/m bdos. 
0000			TFCB:	EQU	5CH		;default file control block. 
0000			TBUFF:	EQU	80H		;i/o buffer and command line storage. 
0000			TBASE:	EQU	100H		;transiant program storage area. 
0000			; 
0000			;   Set control character equates. 
0000			; 
0000			CNTRLC:	EQU	3		;control-c 
0000			CNTRLE:	EQU	05H		;control-e 
0000			BS:	EQU	08H		;backspace 
0000			TAB:	EQU	09H		;tab 
0000			LF:	EQU	0AH		;line feed 
0000			FF:	EQU	0CH		;form feed 
0000			CR:	EQU	0DH		;carriage return 
0000			CNTRLP:	EQU	10H		;control-p 
0000			CNTRLR:	EQU	12H		;control-r 
0000			CNTRLS:	EQU	13H		;control-s 
0000			CNTRLU:	EQU	15H		;control-u 
0000			CNTRLX:	EQU	18H		;control-x 
0000			CNTRLZ:	EQU	1AH		;control-z (end-of-file mark) 
0000			DEL:	EQU	7FH		;rubout 
0000			; 
0000			;   Set origin for CP/M 
0000			; 
0000				ORG	(MEM-7)*1024 
ac00			; 
ac00 c3 5c af		CBASE:	JP	COMMAND		;execute command processor (ccp). 
ac03 c3 58 af			JP	CLEARBUF	;entry to empty input buffer before starting ccp. 
ac06			 
ac06			; 
ac06			;   Standard cp/m ccp input buffer. Format is (max length), 
ac06			; (actual length), (char #1), (char #2), (char #3), etc. 
ac06			; 
ac06 7f			INBUFF:	DEFB	127		;length of input buffer. 
ac07 00				DEFB	0		;current length of contents. 
ac08 ..				DEFB	'Copyright' 
ac11 ..				DEFB	' 1979 (c) by Digital Research      ' 
ac34 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 
ac4b 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 
ac62 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 
ac79 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 
ac88 08 ac		INPOINT:DEFW	INBUFF+2	;input line pointer 
ac8a 00 00		NAMEPNT:DEFW	0		;input line pointer used for error message. Points to 
ac8c			;			;start of name in error. 
ac8c			; 
ac8c			;   Routine to print (A) on the console. All registers used. 
ac8c			; 
ac8c 5f			PRINT:	LD	E,A		;setup bdos call. 
ac8d 0e 02			LD	C,2 
ac8f c3 05 00			JP	ENTRY 
ac92			; 
ac92			;   Routine to print (A) on the console and to save (BC). 
ac92			; 
ac92 c5			PRINTB:	PUSH	BC 
ac93 cd 8c ac			CALL	PRINT 
ac96 c1				POP	BC 
ac97 c9				RET	 
ac98			; 
ac98			;   Routine to send a carriage return, line feed combination 
ac98			; to the console. 
ac98			; 
ac98 3e 0d		CRLF:	LD	A,CR 
ac9a cd 92 ac			CALL	PRINTB 
ac9d 3e 0a			LD	A,LF 
ac9f c3 92 ac			JP	PRINTB 
aca2			; 
aca2			;   Routine to send one space to the console and save (BC). 
aca2			; 
aca2 3e 20		SPACE:	LD	A,' ' 
aca4 c3 92 ac			JP	PRINTB 
aca7			; 
aca7			;   Routine to print character string pointed to be (BC) on the 
aca7			; console. It must terminate with a null byte. 
aca7			; 
aca7 c5			PLINE:	PUSH	BC 
aca8 cd 98 ac			CALL	CRLF 
acab e1				POP	HL 
acac 7e			PLINE2:	LD	A,(HL) 
acad b7				OR	A 
acae c8				RET	Z 
acaf 23				INC	HL 
acb0 e5				PUSH	HL 
acb1 cd 8c ac			CALL	PRINT 
acb4 e1				POP	HL 
acb5 c3 ac ac			JP	PLINE2 
acb8			; 
acb8			;   Routine to reset the disk system. 
acb8			; 
acb8 0e 0d		RESDSK:	LD	C,13 
acba c3 05 00			JP	ENTRY 
acbd			; 
acbd			;   Routine to select disk (A). 
acbd			; 
acbd 5f			DSKSEL:	LD	E,A 
acbe 0e 0e			LD	C,14 
acc0 c3 05 00			JP	ENTRY 
acc3			; 
acc3			;   Routine to call bdos and save the return code. The zero 
acc3			; flag is set on a return of 0ffh. 
acc3			; 
acc3 cd 05 00		ENTRY1:	CALL	ENTRY 
acc6 32 f3 b3			LD	(RTNCODE),A	;save return code. 
acc9 3c				INC	A		;set zero if 0ffh returned. 
acca c9				RET	 
accb			; 
accb			;   Routine to open a file. (DE) must point to the FCB. 
accb			; 
accb 0e 0f		OPEN:	LD	C,15 
accd c3 c3 ac			JP	ENTRY1 
acd0			; 
acd0			;   Routine to open file at (FCB). 
acd0			; 
acd0 af			OPENFCB:XOR	A		;clear the record number byte at fcb+32 
acd1 32 f2 b3			LD	(FCB+32),A 
acd4 11 d2 b3			LD	DE,FCB 
acd7 c3 cb ac			JP	OPEN 
acda			; 
acda			;   Routine to close a file. (DE) points to FCB. 
acda			; 
acda 0e 10		CLOSE:	LD	C,16 
acdc c3 c3 ac			JP	ENTRY1 
acdf			; 
acdf			;   Routine to search for the first file with ambigueous name 
acdf			; (DE). 
acdf			; 
acdf 0e 11		SRCHFST:LD	C,17 
ace1 c3 c3 ac			JP	ENTRY1 
ace4			; 
ace4			;   Search for the next ambigeous file name. 
ace4			; 
ace4 0e 12		SRCHNXT:LD	C,18 
ace6 c3 c3 ac			JP	ENTRY1 
ace9			; 
ace9			;   Search for file at (FCB). 
ace9			; 
ace9 11 d2 b3		SRCHFCB:LD	DE,FCB 
acec c3 df ac			JP	SRCHFST 
acef			; 
acef			;   Routine to delete a file pointed to by (DE). 
acef			; 
acef 0e 13		DELETE:	LD	C,19 
acf1 c3 05 00			JP	ENTRY 
acf4			; 
acf4			;   Routine to call the bdos and set the zero flag if a zero 
acf4			; status is returned. 
acf4			; 
acf4 cd 05 00		ENTRY2:	CALL	ENTRY 
acf7 b7				OR	A		;set zero flag if appropriate. 
acf8 c9				RET	 
acf9			; 
acf9			;   Routine to read the next record from a sequential file. 
acf9			; (DE) points to the FCB. 
acf9			; 
acf9 0e 14		RDREC:	LD	C,20 
acfb c3 f4 ac			JP	ENTRY2 
acfe			; 
acfe			;   Routine to read file at (FCB). 
acfe			; 
acfe 11 d2 b3		READFCB:LD	DE,FCB 
ad01 c3 f9 ac			JP	RDREC 
ad04			; 
ad04			;   Routine to write the next record of a sequential file. 
ad04			; (DE) points to the FCB. 
ad04			; 
ad04 0e 15		WRTREC:	LD	C,21 
ad06 c3 f4 ac			JP	ENTRY2 
ad09			; 
ad09			;   Routine to create the file pointed to by (DE). 
ad09			; 
ad09 0e 16		CREATE:	LD	C,22 
ad0b c3 c3 ac			JP	ENTRY1 
ad0e			; 
ad0e			;   Routine to rename the file pointed to by (DE). Note that 
ad0e			; the new name starts at (DE+16). 
ad0e			; 
ad0e 0e 17		RENAM:	LD	C,23 
ad10 c3 05 00			JP	ENTRY 
ad13			; 
ad13			;   Get the current user code. 
ad13			; 
ad13 1e ff		GETUSR:	LD	E,0FFH 
ad15			; 
ad15			;   Routne to get or set the current user code. 
ad15			; If (E) is FF then this is a GET, else it is a SET. 
ad15			; 
ad15 0e 20		GETSETUC: LD	C,32 
ad17 c3 05 00			JP	ENTRY 
ad1a			; 
ad1a			;   Routine to set the current drive byte at (TDRIVE). 
ad1a			; 
ad1a cd 13 ad		SETCDRV:CALL	GETUSR		;get user number 
ad1d 87				ADD	A,A		;and shift into the upper 4 bits. 
ad1e 87				ADD	A,A 
ad1f 87				ADD	A,A 
ad20 87				ADD	A,A 
ad21 21 f4 b3			LD	HL,CDRIVE	;now add in the current drive number. 
ad24 b6				OR	(HL) 
ad25 32 04 00			LD	(TDRIVE),A	;and save. 
ad28 c9				RET	 
ad29			; 
ad29			;   Move currently active drive down to (TDRIVE). 
ad29			; 
ad29 3a f4 b3		MOVECD:	LD	A,(CDRIVE) 
ad2c 32 04 00			LD	(TDRIVE),A 
ad2f c9				RET	 
ad30			; 
ad30			;   Routine to convert (A) into upper case ascii. Only letters 
ad30			; are affected. 
ad30			; 
ad30 fe 61		UPPER:	CP	'a'		;check for letters in the range of 'a' to 'z'. 
ad32 d8				RET	C 
ad33 fe 7b			CP	'{' 
ad35 d0				RET	NC 
ad36 e6 5f			AND	5FH		;convert it if found. 
ad38 c9				RET	 
ad39			; 
ad39			;   Routine to get a line of input. We must check to see if the 
ad39			; user is in (BATCH) mode. If so, then read the input from file 
ad39			; ($$$.SUB). At the end, reset to console input. 
ad39			; 
ad39 3a b0 b3		GETINP:	LD	A,(BATCH)	;if =0, then use console input. 
ad3c b7				OR	A 
ad3d ca 96 ad			JP	Z,GETINP1 
ad40			; 
ad40			;   Use the submit file ($$$.sub) which is prepared by a 
ad40			; SUBMIT run. It must be on drive (A) and it will be deleted 
ad40			; if and error occures (like eof). 
ad40			; 
ad40 3a f4 b3			LD	A,(CDRIVE)	;select drive 0 if need be. 
ad43 b7				OR	A 
ad44 3e 00			LD	A,0		;always use drive A for submit. 
ad46 c4 bd ac			CALL	NZ,DSKSEL	;select it if required. 
ad49 11 b1 b3			LD	DE,BATCHFCB 
ad4c cd cb ac			CALL	OPEN		;look for it. 
ad4f ca 96 ad			JP	Z,GETINP1	;if not there, use normal input. 
ad52 3a c0 b3			LD	A,(BATCHFCB+15)	;get last record number+1. 
ad55 3d				DEC	A 
ad56 32 d1 b3			LD	(BATCHFCB+32),A 
ad59 11 b1 b3			LD	DE,BATCHFCB 
ad5c cd f9 ac			CALL	RDREC		;read last record. 
ad5f c2 96 ad			JP	NZ,GETINP1	;quit on end of file. 
ad62			; 
ad62			;   Move this record into input buffer. 
ad62			; 
ad62 11 07 ac			LD	DE,INBUFF+1 
ad65 21 80 00			LD	HL,TBUFF	;data was read into buffer here. 
ad68 06 80			LD	B,128		;all 128 characters may be used. 
ad6a cd 42 b0			CALL	HL2DE		;(HL) to (DE), (B) bytes. 
ad6d 21 bf b3			LD	HL,BATCHFCB+14 
ad70 36 00			LD	(HL),0		;zero out the 's2' byte. 
ad72 23				INC	HL		;and decrement the record count. 
ad73 35				DEC	(HL) 
ad74 11 b1 b3			LD	DE,BATCHFCB	;close the batch file now. 
ad77 cd da ac			CALL	CLOSE 
ad7a ca 96 ad			JP	Z,GETINP1	;quit on an error. 
ad7d 3a f4 b3			LD	A,(CDRIVE)	;re-select previous drive if need be. 
ad80 b7				OR	A 
ad81 c4 bd ac			CALL	NZ,DSKSEL	;don't do needless selects. 
ad84			; 
ad84			;   Print line just read on console. 
ad84			; 
ad84 21 08 ac			LD	HL,INBUFF+2 
ad87 cd ac ac			CALL	PLINE2 
ad8a cd c2 ad			CALL	CHKCON		;check console, quit on a key. 
ad8d ca a7 ad			JP	Z,GETINP2	;jump if no key is pressed. 
ad90			; 
ad90			;   Terminate the submit job on any keyboard input. Delete this 
ad90			; file such that it is not re-started and jump to normal keyboard 
ad90			; input section. 
ad90			; 
ad90 cd dd ad			CALL	DELBATCH	;delete the batch file. 
ad93 c3 82 af			JP	CMMND1		;and restart command input. 
ad96			; 
ad96			;   Get here for normal keyboard input. Delete the submit file 
ad96			; incase there was one. 
ad96			; 
ad96 cd dd ad		GETINP1:CALL	DELBATCH	;delete file ($$$.sub). 
ad99 cd 1a ad			CALL	SETCDRV		;reset active disk. 
ad9c 0e 0a			LD	C,10		;get line from console device. 
ad9e 11 06 ac			LD	DE,INBUFF 
ada1 cd 05 00			CALL	ENTRY 
ada4 cd 29 ad			CALL	MOVECD		;reset current drive (again). 
ada7			; 
ada7			;   Convert input line to upper case. 
ada7			; 
ada7 21 07 ac		GETINP2:LD	HL,INBUFF+1 
adaa 46				LD	B,(HL)		;(B)=character counter. 
adab 23			GETINP3:INC	HL 
adac 78				LD	A,B		;end of the line? 
adad b7				OR	A 
adae ca ba ad			JP	Z,GETINP4 
adb1 7e				LD	A,(HL)		;convert to upper case. 
adb2 cd 30 ad			CALL	UPPER 
adb5 77				LD	(HL),A 
adb6 05				DEC	B		;adjust character count. 
adb7 c3 ab ad			JP	GETINP3 
adba 77			GETINP4:LD	(HL),A		;add trailing null. 
adbb 21 08 ac			LD	HL,INBUFF+2 
adbe 22 88 ac			LD	(INPOINT),HL	;reset input line pointer. 
adc1 c9				RET	 
adc2			; 
adc2			;   Routine to check the console for a key pressed. The zero 
adc2			; flag is set is none, else the character is returned in (A). 
adc2			; 
adc2 0e 0b		CHKCON:	LD	C,11		;check console. 
adc4 cd 05 00			CALL	ENTRY 
adc7 b7				OR	A 
adc8 c8				RET	Z		;return if nothing. 
adc9 0e 01			LD	C,1		;else get character. 
adcb cd 05 00			CALL	ENTRY 
adce b7				OR	A		;clear zero flag and return. 
adcf c9				RET	 
add0			; 
add0			;   Routine to get the currently active drive number. 
add0			; 
add0 0e 19		GETDSK:	LD	C,25 
add2 c3 05 00			JP	ENTRY 
add5			; 
add5			;   Set the stabdard dma address. 
add5			; 
add5 11 80 00		STDDMA:	LD	DE,TBUFF 
add8			; 
add8			;   Routine to set the dma address to (DE). 
add8			; 
add8 0e 1a		DMASET:	LD	C,26 
adda c3 05 00			JP	ENTRY 
addd			; 
addd			;  Delete the batch file created by SUBMIT. 
addd			; 
addd 21 b0 b3		DELBATCH: LD	HL,BATCH	;is batch active? 
ade0 7e				LD	A,(HL) 
ade1 b7				OR	A 
ade2 c8				RET	Z 
ade3 36 00			LD	(HL),0		;yes, de-activate it. 
ade5 af				XOR	A 
ade6 cd bd ac			CALL	DSKSEL		;select drive 0 for sure. 
ade9 11 b1 b3			LD	DE,BATCHFCB	;and delete this file. 
adec cd ef ac			CALL	DELETE 
adef 3a f4 b3			LD	A,(CDRIVE)	;reset current drive. 
adf2 c3 bd ac			JP	DSKSEL 
adf5			; 
adf5			;   Check to two strings at (PATTRN1) and (PATTRN2). They must be 
adf5			; the same or we halt.... 
adf5			; 
adf5 11 28 af		VERIFY:	LD	DE,PATTRN1	;these are the serial number bytes. 
adf8 21 00 b4			LD	HL,PATTRN2	;ditto, but how could they be different? 
adfb 06 06			LD	B,6		;6 bytes each. 
adfd 1a			VERIFY1:LD	A,(DE) 
adfe be				CP	(HL) 
adff c2 cf af			JP	NZ,HALT		;jump to halt routine. 
ae02 13				INC	DE 
ae03 23				INC	HL 
ae04 05				DEC	B 
ae05 c2 fd ad			JP	NZ,VERIFY1 
ae08 c9				RET	 
ae09			; 
ae09			;   Print back file name with a '?' to indicate a syntax error. 
ae09			; 
ae09 cd 98 ac		SYNERR:	CALL	CRLF		;end current line. 
ae0c 2a 8a ac			LD	HL,(NAMEPNT)	;this points to name in error. 
ae0f 7e			SYNERR1:LD	A,(HL)		;print it until a space or null is found. 
ae10 fe 20			CP	' ' 
ae12 ca 22 ae			JP	Z,SYNERR2 
ae15 b7				OR	A 
ae16 ca 22 ae			JP	Z,SYNERR2 
ae19 e5				PUSH	HL 
ae1a cd 8c ac			CALL	PRINT 
ae1d e1				POP	HL 
ae1e 23				INC	HL 
ae1f c3 0f ae			JP	SYNERR1 
ae22 3e 3f		SYNERR2:LD	A,'?'		;add trailing '?'. 
ae24 cd 8c ac			CALL	PRINT 
ae27 cd 98 ac			CALL	CRLF 
ae2a cd dd ad			CALL	DELBATCH	;delete any batch file. 
ae2d c3 82 af			JP	CMMND1		;and restart from console input. 
ae30			; 
ae30			;   Check character at (DE) for legal command input. Note that the 
ae30			; zero flag is set if the character is a delimiter. 
ae30			; 
ae30 1a			CHECK:	LD	A,(DE) 
ae31 b7				OR	A 
ae32 c8				RET	Z 
ae33 fe 20			CP	' '		;control characters are not legal here. 
ae35 da 09 ae			JP	C,SYNERR 
ae38 c8				RET	Z		;check for valid delimiter. 
ae39 fe 3d			CP	'=' 
ae3b c8				RET	Z 
ae3c fe 5f			CP	'_' 
ae3e c8				RET	Z 
ae3f fe 2e			CP	'.' 
ae41 c8				RET	Z 
ae42 fe 3a			CP	':' 
ae44 c8				RET	Z 
ae45 fe 3b			CP	';' 
ae47 c8				RET	Z 
ae48 fe 3c			CP	'<' 
ae4a c8				RET	Z 
ae4b fe 3e			CP	'>' 
ae4d c8				RET	Z 
ae4e c9				RET	 
ae4f			; 
ae4f			;   Get the next non-blank character from (DE). 
ae4f			; 
ae4f 1a			NONBLANK: LD	A,(DE) 
ae50 b7				OR	A		;string ends with a null. 
ae51 c8				RET	Z 
ae52 fe 20			CP	' ' 
ae54 c0				RET	NZ 
ae55 13				INC	DE 
ae56 c3 4f ae			JP	NONBLANK 
ae59			; 
ae59			;   Add (HL)=(HL)+(A) 
ae59			; 
ae59 85			ADDHL:	ADD	A,L 
ae5a 6f				LD	L,A 
ae5b d0				RET	NC		;take care of any carry. 
ae5c 24				INC	H 
ae5d c9				RET	 
ae5e			; 
ae5e			;   Convert the first name in (FCB). 
ae5e			; 
ae5e 3e 00		CONVFST:LD	A,0 
ae60			; 
ae60			;   Format a file name (convert * to '?', etc.). On return, 
ae60			; (A)=0 is an unambigeous name was specified. Enter with (A) equal to 
ae60			; the position within the fcb for the name (either 0 or 16). 
ae60			; 
ae60 21 d2 b3		CONVERT:LD	HL,FCB 
ae63 cd 59 ae			CALL	ADDHL 
ae66 e5				PUSH	HL 
ae67 e5				PUSH	HL 
ae68 af				XOR	A 
ae69 32 f5 b3			LD	(CHGDRV),A	;initialize drive change flag. 
ae6c 2a 88 ac			LD	HL,(INPOINT)	;set (HL) as pointer into input line. 
ae6f eb				EX	DE,HL 
ae70 cd 4f ae			CALL	NONBLANK	;get next non-blank character. 
ae73 eb				EX	DE,HL 
ae74 22 8a ac			LD	(NAMEPNT),HL	;save pointer here for any error message. 
ae77 eb				EX	DE,HL 
ae78 e1				POP	HL 
ae79 1a				LD	A,(DE)		;get first character. 
ae7a b7				OR	A 
ae7b ca 89 ae			JP	Z,CONVRT1 
ae7e de 40			SBC	A,'A'-1		;might be a drive name, convert to binary. 
ae80 47				LD	B,A		;and save. 
ae81 13				INC	DE		;check next character for a ':'. 
ae82 1a				LD	A,(DE) 
ae83 fe 3a			CP	':' 
ae85 ca 90 ae			JP	Z,CONVRT2 
ae88 1b				DEC	DE		;nope, move pointer back to the start of the line. 
ae89 3a f4 b3		CONVRT1:LD	A,(CDRIVE) 
ae8c 77				LD	(HL),A 
ae8d c3 96 ae			JP	CONVRT3 
ae90 78			CONVRT2:LD	A,B 
ae91 32 f5 b3			LD	(CHGDRV),A	;set change in drives flag. 
ae94 70				LD	(HL),B 
ae95 13				INC	DE 
ae96			; 
ae96			;   Convert the basic file name. 
ae96			; 
ae96 06 08		CONVRT3:LD	B,08H 
ae98 cd 30 ae		CONVRT4:CALL	CHECK 
ae9b ca b9 ae			JP	Z,CONVRT8 
ae9e 23				INC	HL 
ae9f fe 2a			CP	'*'		;note that an '*' will fill the remaining 
aea1 c2 a9 ae			JP	NZ,CONVRT5	;field with '?'. 
aea4 36 3f			LD	(HL),'?' 
aea6 c3 ab ae			JP	CONVRT6 
aea9 77			CONVRT5:LD	(HL),A 
aeaa 13				INC	DE 
aeab 05			CONVRT6:DEC	B 
aeac c2 98 ae			JP	NZ,CONVRT4 
aeaf cd 30 ae		CONVRT7:CALL	CHECK		;get next delimiter. 
aeb2 ca c0 ae			JP	Z,GETEXT 
aeb5 13				INC	DE 
aeb6 c3 af ae			JP	CONVRT7 
aeb9 23			CONVRT8:INC	HL		;blank fill the file name. 
aeba 36 20			LD	(HL),' ' 
aebc 05				DEC	B 
aebd c2 b9 ae			JP	NZ,CONVRT8 
aec0			; 
aec0			;   Get the extension and convert it. 
aec0			; 
aec0 06 03		GETEXT:	LD	B,03H 
aec2 fe 2e			CP	'.' 
aec4 c2 e9 ae			JP	NZ,GETEXT5 
aec7 13				INC	DE 
aec8 cd 30 ae		GETEXT1:CALL	CHECK 
aecb ca e9 ae			JP	Z,GETEXT5 
aece 23				INC	HL 
aecf fe 2a			CP	'*' 
aed1 c2 d9 ae			JP	NZ,GETEXT2 
aed4 36 3f			LD	(HL),'?' 
aed6 c3 db ae			JP	GETEXT3 
aed9 77			GETEXT2:LD	(HL),A 
aeda 13				INC	DE 
aedb 05			GETEXT3:DEC	B 
aedc c2 c8 ae			JP	NZ,GETEXT1 
aedf cd 30 ae		GETEXT4:CALL	CHECK 
aee2 ca f0 ae			JP	Z,GETEXT6 
aee5 13				INC	DE 
aee6 c3 df ae			JP	GETEXT4 
aee9 23			GETEXT5:INC	HL 
aeea 36 20			LD	(HL),' ' 
aeec 05				DEC	B 
aeed c2 e9 ae			JP	NZ,GETEXT5 
aef0 06 03		GETEXT6:LD	B,3 
aef2 23			GETEXT7:INC	HL 
aef3 36 00			LD	(HL),0 
aef5 05				DEC	B 
aef6 c2 f2 ae			JP	NZ,GETEXT7 
aef9 eb				EX	DE,HL 
aefa 22 88 ac			LD	(INPOINT),HL	;save input line pointer. 
aefd e1				POP	HL 
aefe			; 
aefe			;   Check to see if this is an ambigeous file name specification. 
aefe			; Set the (A) register to non zero if it is. 
aefe			; 
aefe 01 0b 00			LD	BC,11		;set name length. 
af01 23			GETEXT8:INC	HL 
af02 7e				LD	A,(HL) 
af03 fe 3f			CP	'?'		;any question marks? 
af05 c2 09 af			JP	NZ,GETEXT9 
af08 04				INC	B		;count them. 
af09 0d			GETEXT9:DEC	C 
af0a c2 01 af			JP	NZ,GETEXT8 
af0d 78				LD	A,B 
af0e b7				OR	A 
af0f c9				RET	 
af10			; 
af10			;   CP/M command table. Note commands can be either 3 or 4 characters long. 
af10			; 
af10			NUMCMDS:EQU	6		;number of commands 
af10 ..			CMDTBL:	DEFB	'DIR ' 
af14 ..				DEFB	'ERA ' 
af18 ..				DEFB	'TYPE' 
af1c ..				DEFB	'SAVE' 
af20 ..				DEFB	'REN ' 
af24 ..				DEFB	'USER' 
af28			; 
af28			;   The following six bytes must agree with those at (PATTRN2) 
af28			; or cp/m will HALT. Why? 
af28			; 
af28 00 16 00 00 00 00	PATTRN1:DEFB	0,22,0,0,0,0	;(* serial number bytes *). 
af2e			; 
af2e			;   Search the command table for a match with what has just 
af2e			; been entered. If a match is found, then we jump to the 
af2e			; proper section. Else jump to (UNKNOWN). 
af2e			; On return, the (C) register is set to the command number 
af2e			; that matched (or NUMCMDS+1 if no match). 
af2e			; 
af2e 21 10 af		SEARCH:	LD	HL,CMDTBL 
af31 0e 00			LD	C,0 
af33 79			SEARCH1:LD	A,C 
af34 fe 06			CP	NUMCMDS		;this commands exists. 
af36 d0				RET	NC 
af37 11 d3 b3			LD	DE,FCB+1	;check this one. 
af3a 06 04			LD	B,4		;max command length. 
af3c 1a			SEARCH2:LD	A,(DE) 
af3d be				CP	(HL) 
af3e c2 4f af			JP	NZ,SEARCH3	;not a match. 
af41 13				INC	DE 
af42 23				INC	HL 
af43 05				DEC	B 
af44 c2 3c af			JP	NZ,SEARCH2 
af47 1a				LD	A,(DE)		;allow a 3 character command to match. 
af48 fe 20			CP	' ' 
af4a c2 54 af			JP	NZ,SEARCH4 
af4d 79				LD	A,C		;set return register for this command. 
af4e c9				RET	 
af4f 23			SEARCH3:INC	HL 
af50 05				DEC	B 
af51 c2 4f af			JP	NZ,SEARCH3 
af54 0c			SEARCH4:INC	C 
af55 c3 33 af			JP	SEARCH1 
af58			; 
af58			;   Set the input buffer to empty and then start the command 
af58			; processor (ccp). 
af58			; 
af58 af			CLEARBUF: XOR	A 
af59 32 07 ac			LD	(INBUFF+1),A	;second byte is actual length. 
af5c			; 
af5c			;************************************************************** 
af5c			;* 
af5c			;* 
af5c			;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r 
af5c			;* 
af5c			;************************************************************** 
af5c			;* 
af5c 31 b0 b3		COMMAND:LD	SP,CCPSTACK	;setup stack area. 
af5f c5				PUSH	BC		;note that (C) should be equal to: 
af60 79				LD	A,C		;(uuuudddd) where 'uuuu' is the user number 
af61 1f				RRA			;and 'dddd' is the drive number. 
af62 1f				RRA	 
af63 1f				RRA	 
af64 1f				RRA	 
af65 e6 0f			AND	0FH		;isolate the user number. 
af67 5f				LD	E,A 
af68 cd 15 ad			CALL	GETSETUC	;and set it. 
af6b cd b8 ac			CALL	RESDSK		;reset the disk system. 
af6e 32 b0 b3			LD	(BATCH),A	;clear batch mode flag. 
af71 c1				POP	BC 
af72 79				LD	A,C 
af73 e6 0f			AND	0FH		;isolate the drive number. 
af75 32 f4 b3			LD	(CDRIVE),A	;and save. 
af78 cd bd ac			CALL	DSKSEL		;...and select. 
af7b 3a 07 ac			LD	A,(INBUFF+1) 
af7e b7				OR	A		;anything in input buffer already? 
af7f c2 98 af			JP	NZ,CMMND2	;yes, we just process it. 
af82			; 
af82			;   Entry point to get a command line from the console. 
af82			; 
af82 31 b0 b3		CMMND1:	LD	SP,CCPSTACK	;set stack straight. 
af85 cd 98 ac			CALL	CRLF		;start a new line on the screen. 
af88 cd d0 ad			CALL	GETDSK		;get current drive. 
af8b c6 61			ADD	A,'a' 
af8d cd 8c ac			CALL	PRINT		;print current drive. 
af90 3e 3e			LD	A,'>' 
af92 cd 8c ac			CALL	PRINT		;and add prompt. 
af95 cd 39 ad			CALL	GETINP		;get line from user. 
af98			; 
af98			;   Process command line here. 
af98			; 
af98 11 80 00		CMMND2:	LD	DE,TBUFF 
af9b cd d8 ad			CALL	DMASET		;set standard dma address. 
af9e cd d0 ad			CALL	GETDSK 
afa1 32 f4 b3			LD	(CDRIVE),A	;set current drive. 
afa4 cd 5e ae			CALL	CONVFST		;convert name typed in. 
afa7 c4 09 ae			CALL	NZ,SYNERR	;wild cards are not allowed. 
afaa 3a f5 b3			LD	A,(CHGDRV)	;if a change in drives was indicated, 
afad b7				OR	A		;then treat this as an unknown command 
afae c2 aa b2			JP	NZ,UNKNOWN	;which gets executed. 
afb1 cd 2e af			CALL	SEARCH		;else search command table for a match. 
afb4			; 
afb4			;   Note that an unknown command returns 
afb4			; with (A) pointing to the last address 
afb4			; in our table which is (UNKNOWN). 
afb4			; 
afb4 21 c1 af			LD	HL,CMDADR	;now, look thru our address table for command (A). 
afb7 5f				LD	E,A		;set (DE) to command number. 
afb8 16 00			LD	D,0 
afba 19				ADD	HL,DE 
afbb 19				ADD	HL,DE		;(HL)=(CMDADR)+2*(command number). 
afbc 7e				LD	A,(HL)		;now pick out this address. 
afbd 23				INC	HL 
afbe 66				LD	H,(HL) 
afbf 6f				LD	L,A 
afc0 e9				JP	(HL)		;now execute it. 
afc1			; 
afc1			;   CP/M command address table. 
afc1			; 
afc1 77 b0 24 b1 62 b1 b2 b1	CMDADR:	DEFW	DIRECT,ERASE,TYPE,SAVE 
afc9 15 b2 93 b2 aa b2		DEFW	RENAME,USER,UNKNOWN 
afcf			; 
afcf			;   Halt the system. Reason for this is unknown at present. 
afcf			; 
afcf 21 f3 76		HALT:	LD	HL,76F3H	;'DI HLT' instructions. 
afd2 22 00 ac			LD	(CBASE),HL 
afd5 21 00 ac			LD	HL,CBASE 
afd8 e9				JP	(HL) 
afd9			; 
afd9			;   Read error while TYPEing a file. 
afd9			; 
afd9 01 df af		RDERROR:LD	BC,RDERR 
afdc c3 a7 ac			JP	PLINE 
afdf .. 00		RDERR:	DEFB	'Read error',0 
afea			; 
afea			;   Required file was not located. 
afea			; 
afea 01 f0 af		NONE:	LD	BC,NOFILE 
afed c3 a7 ac			JP	PLINE 
aff0 .. 00		NOFILE:	DEFB	'No file',0 
aff8			; 
aff8			;   Decode a command of the form 'A>filename number{ filename}. 
aff8			; Note that a drive specifier is not allowed on the first file 
aff8			; name. On return, the number is in register (A). Any error 
aff8			; causes 'filename?' to be printed and the command is aborted. 
aff8			; 
aff8 cd 5e ae		DECODE:	CALL	CONVFST		;convert filename. 
affb 3a f5 b3			LD	A,(CHGDRV)	;do not allow a drive to be specified. 
affe b7				OR	A 
afff c2 09 ae			JP	NZ,SYNERR 
b002 21 d3 b3			LD	HL,FCB+1	;convert number now. 
b005 01 0b 00			LD	BC,11		;(B)=sum register, (C)=max digit count. 
b008 7e			DECODE1:LD	A,(HL) 
b009 fe 20			CP	' '		;a space terminates the numeral. 
b00b ca 33 b0			JP	Z,DECODE3 
b00e 23				INC	HL 
b00f d6 30			SUB	'0'		;make binary from ascii. 
b011 fe 0a			CP	10		;legal digit? 
b013 d2 09 ae			JP	NC,SYNERR 
b016 57				LD	D,A		;yes, save it in (D). 
b017 78				LD	A,B		;compute (B)=(B)*10 and check for overflow. 
b018 e6 e0			AND	0E0H 
b01a c2 09 ae			JP	NZ,SYNERR 
b01d 78				LD	A,B 
b01e 07				RLCA	 
b01f 07				RLCA	 
b020 07				RLCA			;(A)=(B)*8 
b021 80				ADD	A,B		;.......*9 
b022 da 09 ae			JP	C,SYNERR 
b025 80				ADD	A,B		;.......*10 
b026 da 09 ae			JP	C,SYNERR 
b029 82				ADD	A,D		;add in new digit now. 
b02a da 09 ae		DECODE2:JP	C,SYNERR 
b02d 47				LD	B,A		;and save result. 
b02e 0d				DEC	C		;only look at 11 digits. 
b02f c2 08 b0			JP	NZ,DECODE1 
b032 c9				RET	 
b033 7e			DECODE3:LD	A,(HL)		;spaces must follow (why?). 
b034 fe 20			CP	' ' 
b036 c2 09 ae			JP	NZ,SYNERR 
b039 23				INC	HL 
b03a 0d			DECODE4:DEC	C 
b03b c2 33 b0			JP	NZ,DECODE3 
b03e 78				LD	A,B		;set (A)=the numeric value entered. 
b03f c9				RET	 
b040			; 
b040			;   Move 3 bytes from (HL) to (DE). Note that there is only 
b040			; one reference to this at (A2D5h). 
b040			; 
b040 06 03		MOVE3:	LD	B,3 
b042			; 
b042			;   Move (B) bytes from (HL) to (DE). 
b042			; 
b042 7e			HL2DE:	LD	A,(HL) 
b043 12				LD	(DE),A 
b044 23				INC	HL 
b045 13				INC	DE 
b046 05				DEC	B 
b047 c2 42 b0			JP	NZ,HL2DE 
b04a c9				RET	 
b04b			; 
b04b			;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here. 
b04b			; 
b04b 21 80 00		EXTRACT:LD	HL,TBUFF 
b04e 81				ADD	A,C 
b04f cd 59 ae			CALL	ADDHL 
b052 7e				LD	A,(HL) 
b053 c9				RET	 
b054			; 
b054			;  Check drive specified. If it means a change, then the new 
b054			; drive will be selected. In any case, the drive byte of the 
b054			; fcb will be set to null (means use current drive). 
b054			; 
b054 af			DSELECT:XOR	A		;null out first byte of fcb. 
b055 32 d2 b3			LD	(FCB),A 
b058 3a f5 b3			LD	A,(CHGDRV)	;a drive change indicated? 
b05b b7				OR	A 
b05c c8				RET	Z 
b05d 3d				DEC	A		;yes, is it the same as the current drive? 
b05e 21 f4 b3			LD	HL,CDRIVE 
b061 be				CP	(HL) 
b062 c8				RET	Z 
b063 c3 bd ac			JP	DSKSEL		;no. Select it then. 
b066			; 
b066			;   Check the drive selection and reset it to the previous 
b066			; drive if it was changed for the preceeding command. 
b066			; 
b066 3a f5 b3		RESETDR:LD	A,(CHGDRV)	;drive change indicated? 
b069 b7				OR	A 
b06a c8				RET	Z 
b06b 3d				DEC	A		;yes, was it a different drive? 
b06c 21 f4 b3			LD	HL,CDRIVE 
b06f be				CP	(HL) 
b070 c8				RET	Z 
b071 3a f4 b3			LD	A,(CDRIVE)	;yes, re-select our old drive. 
b074 c3 bd ac			JP	DSKSEL 
b077			; 
b077			;************************************************************** 
b077			;* 
b077			;*           D I R E C T O R Y   C O M M A N D 
b077			;* 
b077			;************************************************************** 
b077			; 
b077 cd 5e ae		DIRECT:	CALL	CONVFST		;convert file name. 
b07a cd 54 b0			CALL	DSELECT		;select indicated drive. 
b07d 21 d3 b3			LD	HL,FCB+1	;was any file indicated? 
b080 7e				LD	A,(HL) 
b081 fe 20			CP	' ' 
b083 c2 8f b0			JP	NZ,DIRECT2 
b086 06 0b			LD	B,11		;no. Fill field with '?' - same as *.*. 
b088 36 3f		DIRECT1:LD	(HL),'?' 
b08a 23				INC	HL 
b08b 05				DEC	B 
b08c c2 88 b0			JP	NZ,DIRECT1 
b08f 1e 00		DIRECT2:LD	E,0		;set initial cursor position. 
b091 d5				PUSH	DE 
b092 cd e9 ac			CALL	SRCHFCB		;get first file name. 
b095 cc ea af			CALL	Z,NONE		;none found at all? 
b098 ca 20 b1		DIRECT3:JP	Z,DIRECT9	;terminate if no more names. 
b09b 3a f3 b3			LD	A,(RTNCODE)	;get file's position in segment (0-3). 
b09e 0f				RRCA	 
b09f 0f				RRCA	 
b0a0 0f				RRCA	 
b0a1 e6 60			AND	60H		;(A)=position*32 
b0a3 4f				LD	C,A 
b0a4 3e 0a			LD	A,10 
b0a6 cd 4b b0			CALL	EXTRACT		;extract the tenth entry in fcb. 
b0a9 17				RLA			;check system file status bit. 
b0aa da 14 b1			JP	C,DIRECT8	;we don't list them. 
b0ad d1				POP	DE 
b0ae 7b				LD	A,E		;bump name count. 
b0af 1c				INC	E 
b0b0 d5				PUSH	DE 
b0b1			;_______patch for STM32ZXCPM 3 column dir 
b0b1			DRECT32: 
b0b1 d6 03			SUB	03H 
b0b3 d2 b1 b0			JP	NC, DRECT32 
b0b6 c6 03			ADD	03H 
b0b8			;	AND	03H 
b0b8			;_______end of patch 
b0b8 f5				PUSH	AF 
b0b9 c2 d1 b0			JP	NZ,DIRECT4		;at end of line? 
b0bc cd 98 ac			CALL	CRLF		;yes, end this line and start another. 
b0bf c5				PUSH	BC 
b0c0 cd d0 ad			CALL	GETDSK		;start line with ('A:'). 
b0c3 c1				POP	BC 
b0c4 c6 41			ADD	A,'A' 
b0c6 cd 92 ac			CALL	PRINTB 
b0c9 3e 3a			LD	A,':' 
b0cb cd 92 ac			CALL	PRINTB 
b0ce c3 d9 b0			JP	DIRECT5 
b0d1 cd a2 ac		DIRECT4:CALL	SPACE		;add seperator between file names. 
b0d4 3e 3a			LD	A,':' 
b0d6 cd 92 ac			CALL	PRINTB 
b0d9 cd a2 ac		DIRECT5:CALL	SPACE 
b0dc 06 01			LD	B,1		;'extract' each file name character at a time. 
b0de 78			DIRECT6:LD	A,B 
b0df cd 4b b0			CALL	EXTRACT 
b0e2 e6 7f			AND	7FH		;strip bit 7 (status bit). 
b0e4 fe 20			CP	' '		;are we at the end of the name? 
b0e6 c2 fe b0			JP	NZ,DRECT65 
b0e9 f1				POP	AF		;yes, don't print spaces at the end of a line. 
b0ea f5				PUSH	AF 
b0eb fe 02			CP	2 
b0ed c2 fc b0			JP	NZ,DRECT63 
b0f0 3e 09			LD	A,9		;first check for no extension. 
b0f2 cd 4b b0			CALL	EXTRACT 
b0f5 e6 7f			AND	7FH 
b0f7 fe 20			CP	' ' 
b0f9 ca 13 b1			JP	Z,DIRECT7	;don't print spaces. 
b0fc 3e 20		DRECT63:LD	A,' '		;else print them. 
b0fe cd 92 ac		DRECT65:CALL	PRINTB 
b101 04				INC	B		;bump to next character psoition. 
b102 78				LD	A,B 
b103 fe 0c			CP	12		;end of the name? 
b105 d2 13 b1			JP	NC,DIRECT7 
b108 fe 09			CP	9		;nope, starting extension? 
b10a c2 de b0			JP	NZ,DIRECT6 
b10d cd a2 ac			CALL	SPACE		;yes, add seperating space. 
b110 c3 de b0			JP	DIRECT6 
b113 f1			DIRECT7:POP	AF		;get the next file name. 
b114 cd c2 ad		DIRECT8:CALL	CHKCON		;first check console, quit on anything. 
b117 c2 20 b1			JP	NZ,DIRECT9 
b11a cd e4 ac			CALL	SRCHNXT		;get next name. 
b11d c3 98 b0			JP	DIRECT3		;and continue with our list. 
b120 d1			DIRECT9:POP	DE		;restore the stack and return to command level. 
b121 c3 8b b3			JP	GETBACK 
b124			; 
b124			;************************************************************** 
b124			;* 
b124			;*                E R A S E   C O M M A N D 
b124			;* 
b124			;************************************************************** 
b124			; 
b124 cd 5e ae		ERASE:	CALL	CONVFST		;convert file name. 
b127 fe 0b			CP	11		;was '*.*' entered? 
b129 c2 47 b1			JP	NZ,ERASE1 
b12c 01 57 b1			LD	BC,YESNO	;yes, ask for confirmation. 
b12f cd a7 ac			CALL	PLINE 
b132 cd 39 ad			CALL	GETINP 
b135 21 07 ac			LD	HL,INBUFF+1 
b138 35				DEC	(HL)		;must be exactly 'y'. 
b139 c2 82 af			JP	NZ,CMMND1 
b13c 23				INC	HL 
b13d 7e				LD	A,(HL) 
b13e fe 59			CP	'Y' 
b140 c2 82 af			JP	NZ,CMMND1 
b143 23				INC	HL 
b144 22 88 ac			LD	(INPOINT),HL	;save input line pointer. 
b147 cd 54 b0		ERASE1:	CALL	DSELECT		;select desired disk. 
b14a 11 d2 b3			LD	DE,FCB 
b14d cd ef ac			CALL	DELETE		;delete the file. 
b150 3c				INC	A 
b151 cc ea af			CALL	Z,NONE		;not there? 
b154 c3 8b b3			JP	GETBACK		;return to command level now. 
b157 .. 00		YESNO:	DEFB	'All (y/n)?',0 
b162			; 
b162			;************************************************************** 
b162			;* 
b162			;*            T Y P E   C O M M A N D 
b162			;* 
b162			;************************************************************** 
b162			; 
b162 cd 5e ae		TYPE:	CALL	CONVFST		;convert file name. 
b165 c2 09 ae			JP	NZ,SYNERR	;wild cards not allowed. 
b168 cd 54 b0			CALL	DSELECT		;select indicated drive. 
b16b cd d0 ac			CALL	OPENFCB		;open the file. 
b16e ca ac b1			JP	Z,TYPE5		;not there? 
b171 cd 98 ac			CALL	CRLF		;ok, start a new line on the screen. 
b174 21 f6 b3			LD	HL,NBYTES	;initialize byte counter. 
b177 36 ff			LD	(HL),0FFH	;set to read first sector. 
b179 21 f6 b3		TYPE1:	LD	HL,NBYTES 
b17c 7e			TYPE2:	LD	A,(HL)		;have we written the entire sector? 
b17d fe 80			CP	128 
b17f da 8c b1			JP	C,TYPE3 
b182 e5				PUSH	HL		;yes, read in the next one. 
b183 cd fe ac			CALL	READFCB 
b186 e1				POP	HL 
b187 c2 a5 b1			JP	NZ,TYPE4	;end or error? 
b18a af				XOR	A		;ok, clear byte counter. 
b18b 77				LD	(HL),A 
b18c 34			TYPE3:	INC	(HL)		;count this byte. 
b18d 21 80 00			LD	HL,TBUFF	;and get the (A)th one from the buffer (TBUFF). 
b190 cd 59 ae			CALL	ADDHL 
b193 7e				LD	A,(HL) 
b194 fe 1a			CP	CNTRLZ		;end of file mark? 
b196 ca 8b b3			JP	Z,GETBACK 
b199 cd 8c ac			CALL	PRINT		;no, print it. 
b19c cd c2 ad			CALL	CHKCON		;check console, quit if anything ready. 
b19f c2 8b b3			JP	NZ,GETBACK 
b1a2 c3 79 b1			JP	TYPE1 
b1a5			; 
b1a5			;   Get here on an end of file or read error. 
b1a5			; 
b1a5 3d			TYPE4:	DEC	A		;read error? 
b1a6 ca 8b b3			JP	Z,GETBACK 
b1a9 cd d9 af			CALL	RDERROR		;yes, print message. 
b1ac cd 66 b0		TYPE5:	CALL	RESETDR		;and reset proper drive 
b1af c3 09 ae			JP	SYNERR		;now print file name with problem. 
b1b2			; 
b1b2			;************************************************************** 
b1b2			;* 
b1b2			;*            S A V E   C O M M A N D 
b1b2			;* 
b1b2			;************************************************************** 
b1b2			; 
b1b2 cd f8 af		SAVE:	CALL	DECODE		;get numeric number that follows SAVE. 
b1b5 f5				PUSH	AF		;save number of pages to write. 
b1b6 cd 5e ae			CALL	CONVFST		;convert file name. 
b1b9 c2 09 ae			JP	NZ,SYNERR	;wild cards not allowed. 
b1bc cd 54 b0			CALL	DSELECT		;select specified drive. 
b1bf 11 d2 b3			LD	DE,FCB		;now delete this file. 
b1c2 d5				PUSH	DE 
b1c3 cd ef ac			CALL	DELETE 
b1c6 d1				POP	DE 
b1c7 cd 09 ad			CALL	CREATE		;and create it again. 
b1ca ca 00 b2			JP	Z,SAVE3		;can't create? 
b1cd af				XOR	A		;clear record number byte. 
b1ce 32 f2 b3			LD	(FCB+32),A 
b1d1 f1				POP	AF		;convert pages to sectors. 
b1d2 6f				LD	L,A 
b1d3 26 00			LD	H,0 
b1d5 29				ADD	HL,HL		;(HL)=number of sectors to write. 
b1d6 11 00 01			LD	DE,TBASE	;and we start from here. 
b1d9 7c			SAVE1:	LD	A,H		;done yet? 
b1da b5				OR	L 
b1db ca f6 b1			JP	Z,SAVE2 
b1de 2b				DEC	HL		;nope, count this and compute the start 
b1df e5				PUSH	HL		;of the next 128 byte sector. 
b1e0 21 80 00			LD	HL,128 
b1e3 19				ADD	HL,DE 
b1e4 e5				PUSH	HL		;save it and set the transfer address. 
b1e5 cd d8 ad			CALL	DMASET 
b1e8 11 d2 b3			LD	DE,FCB		;write out this sector now. 
b1eb cd 04 ad			CALL	WRTREC 
b1ee d1				POP	DE		;reset (DE) to the start of the last sector. 
b1ef e1				POP	HL		;restore sector count. 
b1f0 c2 00 b2			JP	NZ,SAVE3	;write error? 
b1f3 c3 d9 b1			JP	SAVE1 
b1f6			; 
b1f6			;   Get here after writing all of the file. 
b1f6			; 
b1f6 11 d2 b3		SAVE2:	LD	DE,FCB		;now close the file. 
b1f9 cd da ac			CALL	CLOSE 
b1fc 3c				INC	A		;did it close ok? 
b1fd c2 06 b2			JP	NZ,SAVE4 
b200			; 
b200			;   Print out error message (no space). 
b200			; 
b200 01 0c b2		SAVE3:	LD	BC,NOSPACE 
b203 cd a7 ac			CALL	PLINE 
b206 cd d5 ad		SAVE4:	CALL	STDDMA		;reset the standard dma address. 
b209 c3 8b b3			JP	GETBACK 
b20c .. 00		NOSPACE:DEFB	'No space',0 
b215			; 
b215			;************************************************************** 
b215			;* 
b215			;*           R E N A M E   C O M M A N D 
b215			;* 
b215			;************************************************************** 
b215			; 
b215 cd 5e ae		RENAME:	CALL	CONVFST		;convert first file name. 
b218 c2 09 ae			JP	NZ,SYNERR	;wild cards not allowed. 
b21b 3a f5 b3			LD	A,(CHGDRV)	;remember any change in drives specified. 
b21e f5				PUSH	AF 
b21f cd 54 b0			CALL	DSELECT		;and select this drive. 
b222 cd e9 ac			CALL	SRCHFCB		;is this file present? 
b225 c2 7e b2			JP	NZ,RENAME6	;yes, print error message. 
b228 21 d2 b3			LD	HL,FCB		;yes, move this name into second slot. 
b22b 11 e2 b3			LD	DE,FCB+16 
b22e 06 10			LD	B,16 
b230 cd 42 b0			CALL	HL2DE 
b233 2a 88 ac			LD	HL,(INPOINT)	;get input pointer. 
b236 eb				EX	DE,HL 
b237 cd 4f ae			CALL	NONBLANK	;get next non blank character. 
b23a fe 3d			CP	'='		;only allow an '=' or '_' seperator. 
b23c ca 44 b2			JP	Z,RENAME1 
b23f fe 5f			CP	'_' 
b241 c2 78 b2			JP	NZ,RENAME5 
b244 eb			RENAME1:EX	DE,HL 
b245 23				INC	HL		;ok, skip seperator. 
b246 22 88 ac			LD	(INPOINT),HL	;save input line pointer. 
b249 cd 5e ae			CALL	CONVFST		;convert this second file name now. 
b24c c2 78 b2			JP	NZ,RENAME5	;again, no wild cards. 
b24f f1				POP	AF		;if a drive was specified, then it 
b250 47				LD	B,A		;must be the same as before. 
b251 21 f5 b3			LD	HL,CHGDRV 
b254 7e				LD	A,(HL) 
b255 b7				OR	A 
b256 ca 5e b2			JP	Z,RENAME2 
b259 b8				CP	B 
b25a 70				LD	(HL),B 
b25b c2 78 b2			JP	NZ,RENAME5	;they were different, error. 
b25e 70			RENAME2:LD	(HL),B		;	reset as per the first file specification. 
b25f af				XOR	A 
b260 32 d2 b3			LD	(FCB),A		;clear the drive byte of the fcb. 
b263 cd e9 ac		RENAME3:CALL	SRCHFCB		;and go look for second file. 
b266 ca 72 b2			JP	Z,RENAME4	;doesn't exist? 
b269 11 d2 b3			LD	DE,FCB 
b26c cd 0e ad			CALL	RENAM		;ok, rename the file. 
b26f c3 8b b3			JP	GETBACK 
b272			; 
b272			;   Process rename errors here. 
b272			; 
b272 cd ea af		RENAME4:CALL	NONE		;file not there. 
b275 c3 8b b3			JP	GETBACK 
b278 cd 66 b0		RENAME5:CALL	RESETDR		;bad command format. 
b27b c3 09 ae			JP	SYNERR 
b27e 01 87 b2		RENAME6:LD	BC,EXISTS	;destination file already exists. 
b281 cd a7 ac			CALL	PLINE 
b284 c3 8b b3			JP	GETBACK 
b287 .. 00		EXISTS:	DEFB	'File exists',0 
b293			; 
b293			;************************************************************** 
b293			;* 
b293			;*             U S E R   C O M M A N D 
b293			;* 
b293			;************************************************************** 
b293			; 
b293 cd f8 af		USER:	CALL	DECODE		;get numeric value following command. 
b296 fe 10			CP	16		;legal user number? 
b298 d2 09 ae			JP	NC,SYNERR 
b29b 5f				LD	E,A		;yes but is there anything else? 
b29c 3a d3 b3			LD	A,(FCB+1) 
b29f fe 20			CP	' ' 
b2a1 ca 09 ae			JP	Z,SYNERR	;yes, that is not allowed. 
b2a4 cd 15 ad			CALL	GETSETUC	;ok, set user code. 
b2a7 c3 8e b3			JP	GETBACK1 
b2aa			; 
b2aa			;************************************************************** 
b2aa			;* 
b2aa			;*        T R A N S I A N T   P R O G R A M   C O M M A N D 
b2aa			;* 
b2aa			;************************************************************** 
b2aa			; 
b2aa cd f5 ad		UNKNOWN:CALL	VERIFY		;check for valid system (why?). 
b2ad 3a d3 b3			LD	A,(FCB+1)	;anything to execute? 
b2b0 fe 20			CP	' ' 
b2b2 c2 c9 b2			JP	NZ,UNKWN1 
b2b5 3a f5 b3			LD	A,(CHGDRV)	;nope, only a drive change? 
b2b8 b7				OR	A 
b2b9 ca 8e b3			JP	Z,GETBACK1	;neither??? 
b2bc 3d				DEC	A 
b2bd 32 f4 b3			LD	(CDRIVE),A	;ok, store new drive. 
b2c0 cd 29 ad			CALL	MOVECD		;set (TDRIVE) also. 
b2c3 cd bd ac			CALL	DSKSEL		;and select this drive. 
b2c6 c3 8e b3			JP	GETBACK1	;then return. 
b2c9			; 
b2c9			;   Here a file name was typed. Prepare to execute it. 
b2c9			; 
b2c9 11 db b3		UNKWN1:	LD	DE,FCB+9	;an extension specified? 
b2cc 1a				LD	A,(DE) 
b2cd fe 20			CP	' ' 
b2cf c2 09 ae			JP	NZ,SYNERR	;yes, not allowed. 
b2d2 d5			UNKWN2:	PUSH	DE 
b2d3 cd 54 b0			CALL	DSELECT		;select specified drive. 
b2d6 d1				POP	DE 
b2d7 21 88 b3			LD	HL,COMFILE	;set the extension to 'COM'. 
b2da cd 40 b0			CALL	MOVE3 
b2dd cd d0 ac			CALL	OPENFCB		;and open this file. 
b2e0 ca f5 c4			JP	Z,ptchda	;not present? 
b2e3			; 
b2e3			;   Load in the program. 
b2e3			; 
b2e3			UNKWN25: 
b2e3 21 00 01			LD	HL,TBASE	;store the program starting here. 
b2e6			UNKWN3: 
b2e6 e5				PUSH	HL 
b2e7 eb				EX	DE,HL 
b2e8 cd d8 ad			CALL	DMASET		;set transfer address. 
b2eb 11 d2 b3			LD	DE,FCB		;and read the next record. 
b2ee cd f9 ac			CALL	RDREC 
b2f1 c2 06 b3			JP	NZ,UNKWN4	;end of file or read error? 
b2f4 e1				POP	HL		;nope, bump pointer for next sector. 
b2f5 11 80 00			LD	DE,128 
b2f8 19				ADD	HL,DE 
b2f9 11 00 ac			LD	DE,CBASE	;enough room for the whole file? 
b2fc 7d				LD	A,L 
b2fd 93				SUB	E 
b2fe 7c				LD	A,H 
b2ff 9a				SBC	A,D 
b300 d2 76 b3			JP	NC,UNKWN0	;no, it can't fit. 
b303 c3 e6 b2			JP	UNKWN3 
b306			; 
b306			;   Get here after finished reading. 
b306			; 
b306 e1			UNKWN4:	POP	HL 
b307 3d				DEC	A		;normal end of file? 
b308 c2 76 b3			JP	NZ,UNKWN0 
b30b cd 66 b0			CALL	RESETDR		;yes, reset previous drive. 
b30e cd 5e ae			CALL	CONVFST		;convert the first file name that follows 
b311 21 f5 b3			LD	HL,CHGDRV	;command name. 
b314 e5				PUSH	HL 
b315 7e				LD	A,(HL)		;set drive code in default fcb. 
b316 32 d2 b3			LD	(FCB),A 
b319 3e 10			LD	A,16		;put second name 16 bytes later. 
b31b cd 60 ae			CALL	CONVERT		;convert second file name. 
b31e e1				POP	HL 
b31f 7e				LD	A,(HL)		;and set the drive for this second file. 
b320 32 e2 b3			LD	(FCB+16),A 
b323 af				XOR	A		;clear record byte in fcb. 
b324 32 f2 b3			LD	(FCB+32),A 
b327 11 5c 00			LD	DE,TFCB		;move it into place at(005Ch). 
b32a 21 d2 b3			LD	HL,FCB 
b32d 06 21			LD	B,33 
b32f cd 42 b0			CALL	HL2DE 
b332 21 08 ac			LD	HL,INBUFF+2	;now move the remainder of the input 
b335 7e			UNKWN5:	LD	A,(HL)		;line down to (0080h). Look for a non blank. 
b336 b7				OR	A		;or a null. 
b337 ca 43 b3			JP	Z,UNKWN6 
b33a fe 20			CP	' ' 
b33c ca 43 b3			JP	Z,UNKWN6 
b33f 23				INC	HL 
b340 c3 35 b3			JP	UNKWN5 
b343			; 
b343			;   Do the line move now. It ends in a null byte. 
b343			; 
b343 06 00		UNKWN6:	LD	B,0		;keep a character count. 
b345 11 81 00			LD	DE,TBUFF+1	;data gets put here. 
b348 7e			UNKWN7:	LD	A,(HL)		;move it now. 
b349 12				LD	(DE),A 
b34a b7				OR	A 
b34b ca 54 b3			JP	Z,UNKWN8 
b34e 04				INC	B 
b34f 23				INC	HL 
b350 13				INC	DE 
b351 c3 48 b3			JP	UNKWN7 
b354 78			UNKWN8:	LD	A,B		;now store the character count. 
b355 32 80 00			LD	(TBUFF),A 
b358 cd 98 ac			CALL	CRLF		;clean up the screen. 
b35b cd d5 ad			CALL	STDDMA		;set standard transfer address. 
b35e cd 1a ad			CALL	SETCDRV		;reset current drive. 
b361 cd 00 01			CALL	TBASE		;and execute the program. 
b364			; 
b364			;   Transiant programs return here (or reboot). 
b364			; 
b364 31 b0 b3			LD	SP,BATCH	;set stack first off. 
b367 cd 29 ad			CALL	MOVECD		;move current drive into place (TDRIVE). 
b36a cd bd ac			CALL	DSKSEL		;and reselect it. 
b36d c3 82 af			JP	CMMND1		;back to comand mode. 
b370			; 
b370			;   Get here if some error occured. 
b370			; 
b370 cd 66 b0		UNKWN9:	CALL	RESETDR		;inproper format. 
b373 c3 09 ae			JP	SYNERR 
b376 01 7f b3		UNKWN0:	LD	BC,BADLOAD	;read error or won't fit. 
b379 cd a7 ac			CALL	PLINE 
b37c c3 8b b3			JP	GETBACK 
b37f .. 00		BADLOAD:DEFB	'Bad load',0 
b388 ..			COMFILE:DEFB	'COM'		;command file extension. 
b38b			; 
b38b			;   Get here to return to command level. We will reset the 
b38b			; previous active drive and then either return to command 
b38b			; level directly or print error message and then return. 
b38b			; 
b38b cd 66 b0		GETBACK:CALL	RESETDR		;reset previous drive. 
b38e cd 5e ae		GETBACK1: CALL	CONVFST		;convert first name in (FCB). 
b391 3a d3 b3			LD	A,(FCB+1)	;if this was just a drive change request, 
b394 d6 20			SUB	' '		;make sure it was valid. 
b396 21 f5 b3			LD	HL,CHGDRV 
b399 b6				OR	(HL) 
b39a c2 09 ae			JP	NZ,SYNERR 
b39d c3 82 af			JP	CMMND1		;ok, return to command level. 
b3a0			; 
b3a0			;   ccp stack area. 
b3a0			; 
b3a0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 
b3b0			CCPSTACK:EQU	$	;end of ccp stack area. 
b3b0			; 
b3b0			;   Batch (or SUBMIT) processing information storage. 
b3b0			; 
b3b0 00			BATCH:	DEFB	0		;batch mode flag (0=not active). 
b3b1 00 .. 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00	BATCHFCB: DEFB	0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 
b3d2			; 
b3d2			;   File control block setup by the CCP. 
b3d2			; 
b3d2 00 .. 00 00 00 00 00 .. 00 00 00 00 00	FCB:	DEFB	0,'           ',0,0,0,0,0,'           ',0,0,0,0,0 
b3f3 00			RTNCODE:DEFB	0		;status returned from bdos call. 
b3f4 00			CDRIVE:	DEFB	0		;currently active drive. 
b3f5 00			CHGDRV:	DEFB	0		;change in drives flag (0=no change). 
b3f6 00 00		NBYTES:	DEFW	0		;byte counter used by TYPE. 
b3f8			; 
b3f8			;   Room for expansion? 
b3f8			; 
b3f8 00 00 00 00 00 00 00 00		DEFB	0,0,0,0,0,0,0,0 
b400			; 
b400			;   Note that the following six bytes must match those at 
b400			; (PATTRN1) or cp/m will HALT. Why? 
b400			; 
b400 00 16 00 00 00 00	PATTRN2:DEFB	0,22,0,0,0,0	;(* serial number bytes *). 
b406			; 
b406			;************************************************************** 
b406			;* 
b406			;*                    B D O S   E N T R Y 
b406			;* 
b406			;************************************************************** 
b406			; 
b406 c3 11 b4		FBASE:	JP	FBASE1 
b409			; 
b409			;   Bdos error table. 
b409			; 
b409 99 b4		BADSCTR:DEFW	ERROR1		;bad sector on read or write. 
b40b a5 b4		BADSLCT:DEFW	ERROR2		;bad disk select. 
b40d ab b4		RODISK:	DEFW	ERROR3		;disk is read only. 
b40f b1 b4		ROFILE:	DEFW	ERROR4		;file is read only. 
b411			; 
b411			;   Entry into bdos. (DE) or (E) are the parameters passed. The 
b411			; function number desired is in register (C). 
b411			; 
b411 eb			FBASE1:	EX	DE,HL		;save the (DE) parameters. 
b412 22 43 b7			LD	(PARAMS),HL 
b415 eb				EX	DE,HL 
b416 7b				LD	A,E		;and save register (E) in particular. 
b417 32 d6 c1			LD	(EPARAM),A 
b41a 21 00 00			LD	HL,0 
b41d 22 45 b7			LD	(STATUS),HL	;clear return status. 
b420 39				ADD	HL,SP 
b421 22 0f b7			LD	(USRSTACK),HL	;save users stack pointer. 
b424 31 41 b7			LD	SP,STKAREA	;and set our own. 
b427 af				XOR	A		;clear auto select storage space. 
b428 32 e0 c1			LD	(AUTOFLAG),A 
b42b 32 de c1			LD	(AUTO),A 
b42e 21 74 c1			LD	HL,GOBACK	;set return address. 
b431 e5				PUSH	HL 
b432 79				LD	A,C		;get function number. 
b433 fe 29			CP	NFUNCTS		;valid function number? 
b435 d0				RET	NC 
b436 4b				LD	C,E		;keep single register function here. 
b437 21 47 b4			LD	HL,FUNCTNS	;now look thru the function table. 
b43a 5f				LD	E,A 
b43b 16 00			LD	D,0		;(DE)=function number. 
b43d 19				ADD	HL,DE 
b43e 19				ADD	HL,DE		;(HL)=(start of table)+2*(function number). 
b43f 5e				LD	E,(HL) 
b440 23				INC	HL 
b441 56				LD	D,(HL)		;now (DE)=address for this function. 
b442 2a 43 b7			LD	HL,(PARAMS)	;retrieve parameters. 
b445 eb				EX	DE,HL		;now (DE) has the original parameters. 
b446 e9				JP	(HL)		;execute desired function. 
b447			; 
b447			;   BDOS function jump table. 
b447			; 
b447			NFUNCTS:EQU	41		;number of functions in followin table. 
b447			; 
b447 cf c3 c8 b6 90 b5 ce b6 73 c4 6f c4 d4 b6 ed b6	FUNCTNS:DEFW	WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB 
b457 f3 b6 f8 b6 e1 b5 fe b6 7e c0 83 c0 45 c0 9c c0		DEFW	SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL 
b467 a5 c0 ab c0 c8 c0 d7 c0 e0 c0 e6 c0 ec c0		DEFW	CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE 
b475 f5 c0 fe c0 04 c1 0a c1 11 c1 2c b9 17 c1 1d c1		DEFW	RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR 
b485 26 c1 2d c1 41 c1 47 c1 4d c1 0e c0 53 c1 04 b7		DEFW	GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN 
b495 04 b7 9b c1		DEFW	RTN,WTSPECL 
b499			; 
b499			;   Bdos error message section. 
b499			; 
b499 21 ca b4		ERROR1:	LD	HL,BADSEC	;bad sector message. 
b49c cd e5 b4			CALL	PRTERR		;print it and get a 1 char responce. 
b49f fe 03			CP	CNTRLC		;re-boot request (control-c)? 
b4a1 ca 00 00			JP	Z,0		;yes. 
b4a4 c9				RET			;no, return to retry i/o function. 
b4a5			; 
b4a5 21 d5 b4		ERROR2:	LD	HL,BADSEL	;bad drive selected. 
b4a8 c3 b4 b4			JP	ERROR5 
b4ab			; 
b4ab 21 e1 b4		ERROR3:	LD	HL,DISKRO	;disk is read only. 
b4ae c3 b4 b4			JP	ERROR5 
b4b1			; 
b4b1 21 dc b4		ERROR4:	LD	HL,FILERO	;file is read only. 
b4b4			; 
b4b4 cd e5 b4		ERROR5:	CALL	PRTERR 
b4b7 c3 00 00			JP	0		;always reboot on these errors. 
b4ba			; 
b4ba ..			BDOSERR:DEFB	'Bdos Err On ' 
b4c6 ..			BDOSDRV:DEFB	' : $' 
b4ca ..			BADSEC:	DEFB	'Bad Sector$' 
b4d5 ..			BADSEL:	DEFB	'Select$' 
b4dc ..			FILERO:	DEFB	'File ' 
b4e1 ..			DISKRO:	DEFB	'R/O$' 
b4e5			; 
b4e5			;   Print bdos error message. 
b4e5			; 
b4e5 e5			PRTERR:	PUSH	HL		;save second message pointer. 
b4e6 cd c9 b5			CALL	OUTCRLF		;send (cr)(lf). 
b4e9 3a 42 b7			LD	A,(ACTIVE)	;get active drive. 
b4ec c6 41			ADD	A,'A'		;make ascii. 
b4ee 32 c6 b4			LD	(BDOSDRV),A	;and put in message. 
b4f1 01 ba b4			LD	BC,BDOSERR	;and print it. 
b4f4 cd d3 b5			CALL	PRTMESG 
b4f7 c1				POP	BC		;print second message line now. 
b4f8 cd d3 b5			CALL	PRTMESG 
b4fb			; 
b4fb			;   Get an input character. We will check our 1 character 
b4fb			; buffer first. This may be set by the console status routine. 
b4fb			; 
b4fb 21 0e b7		GETCHAR:LD	HL,CHARBUF	;check character buffer. 
b4fe 7e				LD	A,(HL)		;anything present already? 
b4ff 36 00			LD	(HL),0		;...either case clear it. 
b501 b7				OR	A 
b502 c0				RET	NZ		;yes, use it. 
b503 c3 5f c4			JP	CONIN		;nope, go get a character responce. 
b506			; 
b506			;   Input and echo a character. 
b506			; 
b506 cd fb b4		GETECHO:CALL	GETCHAR		;input a character. 
b509 cd 14 b5			CALL	CHKCHAR		;carriage control? 
b50c d8				RET	C		;no, a regular control char so don't echo. 
b50d f5				PUSH	AF		;ok, save character now. 
b50e 4f				LD	C,A 
b50f cd 90 b5			CALL	OUTCON		;and echo it. 
b512 f1				POP	AF		;get character and return. 
b513 c9				RET	 
b514			; 
b514			;   Check character in (A). Set the zero flag on a carriage 
b514			; control character and the carry flag on any other control 
b514			; character. 
b514			; 
b514 fe 0d		CHKCHAR:CP	CR		;check for carriage return, line feed, backspace, 
b516 c8				RET	Z		;or a tab. 
b517 fe 0a			CP	LF 
b519 c8				RET	Z 
b51a fe 09			CP	TAB 
b51c c8				RET	Z 
b51d fe 08			CP	BS 
b51f c8				RET	Z 
b520 fe 20			CP	' '		;other control char? Set carry flag. 
b522 c9				RET	 
b523			; 
b523			;   Check the console during output. Halt on a control-s, then 
b523			; reboot on a control-c. If anything else is ready, clear the 
b523			; zero flag and return (the calling routine may want to do 
b523			; something). 
b523			; 
b523 3a 0e b7		CKCONSOL: LD	A,(CHARBUF)	;check buffer. 
b526 b7				OR	A		;if anything, just return without checking. 
b527 c2 45 b5			JP	NZ,CKCON2 
b52a cd 5c c4			CALL	CONST		;nothing in buffer. Check console. 
b52d e6 01			AND	01H		;look at bit 0. 
b52f c8				RET	Z		;return if nothing. 
b530 cd 5f c4			CALL	CONIN		;ok, get it. 
b533 fe 13			CP	CNTRLS		;if not control-s, return with zero cleared. 
b535 c2 42 b5			JP	NZ,CKCON1 
b538 cd 5f c4			CALL	CONIN		;halt processing until another char 
b53b fe 03			CP	CNTRLC		;is typed. Control-c? 
b53d ca 00 00			JP	Z,0		;yes, reboot now. 
b540 af				XOR	A		;no, just pretend nothing was ever ready. 
b541 c9				RET	 
b542 32 0e b7		CKCON1:	LD	(CHARBUF),A	;save character in buffer for later processing. 
b545 3e 01		CKCON2:	LD	A,1		;set (A) to non zero to mean something is ready. 
b547 c9				RET	 
b548			; 
b548			;   Output (C) to the screen. If the printer flip-flop flag 
b548			; is set, we will send character to printer also. The console 
b548			; will be checked in the process. 
b548			; 
b548 3a 0a b7		OUTCHAR:LD	A,(OUTFLAG)	;check output flag. 
b54b b7				OR	A		;anything and we won't generate output. 
b54c c2 62 b5			JP	NZ,OUTCHR1 
b54f c5				PUSH	BC 
b550 cd 23 b5			CALL	CKCONSOL	;check console (we don't care whats there). 
b553 c1				POP	BC 
b554 c5				PUSH	BC 
b555 cd 6b c4			CALL	CONOUT		;output (C) to the screen. 
b558 c1				POP	BC 
b559 c5				PUSH	BC 
b55a 3a 0d b7			LD	A,(PRTFLAG)	;check printer flip-flop flag. 
b55d b7				OR	A 
b55e c4 6f c4			CALL	NZ,LIST		;print it also if non-zero. 
b561 c1				POP	BC 
b562 79			OUTCHR1:LD	A,C		;update cursors position. 
b563 21 0c b7			LD	HL,CURPOS 
b566 fe 7f			CP	DEL		;rubouts don't do anything here. 
b568 c8				RET	Z 
b569 34				INC	(HL)		;bump line pointer. 
b56a fe 20			CP	' '		;and return if a normal character. 
b56c d0				RET	NC 
b56d 35				DEC	(HL)		;restore and check for the start of the line. 
b56e 7e				LD	A,(HL) 
b56f b7				OR	A 
b570 c8				RET	Z		;ingnore control characters at the start of the line. 
b571 79				LD	A,C 
b572 fe 08			CP	BS		;is it a backspace? 
b574 c2 79 b5			JP	NZ,OUTCHR2 
b577 35				DEC	(HL)		;yes, backup pointer. 
b578 c9				RET	 
b579 fe 0a		OUTCHR2:CP	LF		;is it a line feed? 
b57b c0				RET	NZ		;ignore anything else. 
b57c 36 00			LD	(HL),0		;reset pointer to start of line. 
b57e c9				RET	 
b57f			; 
b57f			;   Output (A) to the screen. If it is a control character 
b57f			; (other than carriage control), use ^x format. 
b57f			; 
b57f 79			SHOWIT:	LD	A,C 
b580 cd 14 b5			CALL	CHKCHAR		;check character. 
b583 d2 90 b5			JP	NC,OUTCON	;not a control, use normal output. 
b586 f5				PUSH	AF 
b587 0e 5e			LD	C,'^'		;for a control character, preceed it with '^'. 
b589 cd 48 b5			CALL	OUTCHAR 
b58c f1				POP	AF 
b58d f6 40			OR	'@'		;and then use the letter equivelant. 
b58f 4f				LD	C,A 
b590			; 
b590			;   Function to output (C) to the console device and expand tabs 
b590			; if necessary. 
b590			; 
b590 79			OUTCON:	LD	A,C 
b591 fe 09			CP	TAB		;is it a tab? 
b593 c2 48 b5			JP	NZ,OUTCHAR	;use regular output. 
b596 0e 20		OUTCON1:LD	C,' '		;yes it is, use spaces instead. 
b598 cd 48 b5			CALL	OUTCHAR 
b59b 3a 0c b7			LD	A,(CURPOS)	;go until the cursor is at a multiple of 8 
b59e			 
b59e e6 07			AND	07H		;position. 
b5a0 c2 96 b5			JP	NZ,OUTCON1 
b5a3 c9				RET	 
b5a4			; 
b5a4			;   Echo a backspace character. Erase the prevoius character 
b5a4			; on the screen. 
b5a4			; 
b5a4 cd ac b5		BACKUP:	CALL	BACKUP1		;backup the screen 1 place. 
b5a7 0e 20			LD	C,' '		;then blank that character. 
b5a9 cd 6b c4			CALL	CONOUT 
b5ac 0e 08		BACKUP1:LD	C,BS		;then back space once more. 
b5ae c3 6b c4			JP	CONOUT 
b5b1			; 
b5b1			;   Signal a deleted line. Print a '#' at the end and start 
b5b1			; over. 
b5b1			; 
b5b1 0e 23		NEWLINE:LD	C,'#' 
b5b3 cd 48 b5			CALL	OUTCHAR		;print this. 
b5b6 cd c9 b5			CALL	OUTCRLF		;start new line. 
b5b9 3a 0c b7		NEWLN1:	LD	A,(CURPOS)	;move the cursor to the starting position. 
b5bc 21 0b b7			LD	HL,STARTING 
b5bf be				CP	(HL) 
b5c0 d0				RET	NC		;there yet? 
b5c1 0e 20			LD	C,' ' 
b5c3 cd 48 b5			CALL	OUTCHAR		;nope, keep going. 
b5c6 c3 b9 b5			JP	NEWLN1 
b5c9			; 
b5c9			;   Output a (cr) (lf) to the console device (screen). 
b5c9			; 
b5c9 0e 0d		OUTCRLF:LD	C,CR 
b5cb cd 48 b5			CALL	OUTCHAR 
b5ce 0e 0a			LD	C,LF 
b5d0 c3 48 b5			JP	OUTCHAR 
b5d3			; 
b5d3			;   Print message pointed to by (BC). It will end with a '$'. 
b5d3			; 
b5d3 0a			PRTMESG:LD	A,(BC)		;check for terminating character. 
b5d4 fe 24			CP	'$' 
b5d6 c8				RET	Z 
b5d7 03				INC	BC 
b5d8 c5				PUSH	BC		;otherwise, bump pointer and print it. 
b5d9 4f				LD	C,A 
b5da cd 90 b5			CALL	OUTCON 
b5dd c1				POP	BC 
b5de c3 d3 b5			JP	PRTMESG 
b5e1			; 
b5e1			;   Function to execute a buffered read. 
b5e1			; 
b5e1 3a 0c b7		RDBUFF:	LD	A,(CURPOS)	;use present location as starting one. 
b5e4 32 0b b7			LD	(STARTING),A 
b5e7 2a 43 b7			LD	HL,(PARAMS)	;get the maximum buffer space. 
b5ea 4e				LD	C,(HL) 
b5eb 23				INC	HL		;point to first available space. 
b5ec e5				PUSH	HL		;and save. 
b5ed 06 00			LD	B,0		;keep a character count. 
b5ef c5			RDBUF1:	PUSH	BC 
b5f0 e5				PUSH	HL 
b5f1 cd fb b4		RDBUF2:	CALL	GETCHAR		;get the next input character. 
b5f4 e6 7f			AND	7FH		;strip bit 7. 
b5f6 e1				POP	HL		;reset registers. 
b5f7 c1				POP	BC 
b5f8 fe 0d			CP	CR		;en of the line? 
b5fa ca c1 b6			JP	Z,RDBUF17 
b5fd fe 0a			CP	LF 
b5ff ca c1 b6			JP	Z,RDBUF17 
b602 fe 08			CP	BS		;how about a backspace? 
b604 c2 16 b6			JP	NZ,RDBUF3 
b607 78				LD	A,B		;yes, but ignore at the beginning of the line. 
b608 b7				OR	A 
b609 ca ef b5			JP	Z,RDBUF1 
b60c 05				DEC	B		;ok, update counter. 
b60d 3a 0c b7			LD	A,(CURPOS)	;if we backspace to the start of the line, 
b610 32 0a b7			LD	(OUTFLAG),A	;treat as a cancel (control-x). 
b613 c3 70 b6			JP	RDBUF10 
b616 fe 7f		RDBUF3:	CP	DEL		;user typed a rubout? 
b618 c2 26 b6			JP	NZ,RDBUF4 
b61b 78				LD	A,B		;ignore at the start of the line. 
b61c b7				OR	A 
b61d ca ef b5			JP	Z,RDBUF1 
b620 7e				LD	A,(HL)		;ok, echo the prevoius character. 
b621 05				DEC	B		;and reset pointers (counters). 
b622 2b				DEC	HL 
b623 c3 a9 b6			JP	RDBUF15 
b626 fe 05		RDBUF4:	CP	CNTRLE		;physical end of line? 
b628 c2 37 b6			JP	NZ,RDBUF5 
b62b c5				PUSH	BC		;yes, do it. 
b62c e5				PUSH	HL 
b62d cd c9 b5			CALL	OUTCRLF 
b630 af				XOR	A		;and update starting position. 
b631 32 0b b7			LD	(STARTING),A 
b634 c3 f1 b5			JP	RDBUF2 
b637 fe 10		RDBUF5:	CP	CNTRLP		;control-p? 
b639 c2 48 b6			JP	NZ,RDBUF6 
b63c e5				PUSH	HL		;yes, flip the print flag filp-flop byte. 
b63d 21 0d b7			LD	HL,PRTFLAG 
b640 3e 01			LD	A,1		;PRTFLAG=1-PRTFLAG 
b642 96				SUB	(HL) 
b643 77				LD	(HL),A 
b644 e1				POP	HL 
b645 c3 ef b5			JP	RDBUF1 
b648 fe 18		RDBUF6:	CP	CNTRLX		;control-x (cancel)? 
b64a c2 5f b6			JP	NZ,RDBUF8 
b64d e1				POP	HL 
b64e 3a 0b b7		RDBUF7:	LD	A,(STARTING)	;yes, backup the cursor to here. 
b651 21 0c b7			LD	HL,CURPOS 
b654 be				CP	(HL) 
b655 d2 e1 b5			JP	NC,RDBUFF	;done yet? 
b658 35				DEC	(HL)		;no, decrement pointer and output back up one space. 
b659 cd a4 b5			CALL	BACKUP 
b65c c3 4e b6			JP	RDBUF7 
b65f fe 15		RDBUF8:	CP	CNTRLU		;cntrol-u (cancel line)? 
b661 c2 6b b6			JP	NZ,RDBUF9 
b664 cd b1 b5			CALL	NEWLINE		;start a new line. 
b667 e1				POP	HL 
b668 c3 e1 b5			JP	RDBUFF 
b66b fe 12		RDBUF9:	CP	CNTRLR		;control-r? 
b66d c2 a6 b6			JP	NZ,RDBUF14 
b670 c5			RDBUF10:PUSH	BC		;yes, start a new line and retype the old one. 
b671 cd b1 b5			CALL	NEWLINE 
b674 c1				POP	BC 
b675 e1				POP	HL 
b676 e5				PUSH	HL 
b677 c5				PUSH	BC 
b678 78			RDBUF11:LD	A,B		;done whole line yet? 
b679 b7				OR	A 
b67a ca 8a b6			JP	Z,RDBUF12 
b67d 23				INC	HL		;nope, get next character. 
b67e 4e				LD	C,(HL) 
b67f 05				DEC	B		;count it. 
b680 c5				PUSH	BC 
b681 e5				PUSH	HL 
b682 cd 7f b5			CALL	SHOWIT		;and display it. 
b685 e1				POP	HL 
b686 c1				POP	BC 
b687 c3 78 b6			JP	RDBUF11 
b68a e5			RDBUF12:PUSH	HL		;done with line. If we were displaying 
b68b 3a 0a b7			LD	A,(OUTFLAG)	;then update cursor position. 
b68e b7				OR	A 
b68f ca f1 b5			JP	Z,RDBUF2 
b692 21 0c b7			LD	HL,CURPOS	;because this line is shorter, we must 
b695 96				SUB	(HL)		;back up the cursor (not the screen however) 
b696 32 0a b7			LD	(OUTFLAG),A	;some number of positions. 
b699 cd a4 b5		RDBUF13:CALL	BACKUP		;note that as long as (OUTFLAG) is non 
b69c 21 0a b7			LD	HL,OUTFLAG	;zero, the screen will not be changed. 
b69f 35				DEC	(HL) 
b6a0 c2 99 b6			JP	NZ,RDBUF13 
b6a3 c3 f1 b5			JP	RDBUF2		;now just get the next character. 
b6a6			; 
b6a6			;   Just a normal character, put this in our buffer and echo. 
b6a6			; 
b6a6 23			RDBUF14:INC	HL 
b6a7 77				LD	(HL),A		;store character. 
b6a8 04				INC	B		;and count it. 
b6a9 c5			RDBUF15:PUSH	BC 
b6aa e5				PUSH	HL 
b6ab 4f				LD	C,A		;echo it now. 
b6ac cd 7f b5			CALL	SHOWIT 
b6af e1				POP	HL 
b6b0 c1				POP	BC 
b6b1 7e				LD	A,(HL)		;was it an abort request? 
b6b2 fe 03			CP	CNTRLC		;control-c abort? 
b6b4 78				LD	A,B 
b6b5 c2 bd b6			JP	NZ,RDBUF16 
b6b8 fe 01			CP	1		;only if at start of line. 
b6ba ca 00 00			JP	Z,0 
b6bd b9			RDBUF16:CP	C		;nope, have we filled the buffer? 
b6be da ef b5			JP	C,RDBUF1 
b6c1 e1			RDBUF17:POP	HL		;yes end the line and return. 
b6c2 70				LD	(HL),B 
b6c3 0e 0d			LD	C,CR 
b6c5 c3 48 b5			JP	OUTCHAR		;output (cr) and return. 
b6c8			; 
b6c8			;   Function to get a character from the console device. 
b6c8			; 
b6c8 cd 06 b5		GETCON:	CALL	GETECHO		;get and echo. 
b6cb c3 01 b7			JP	SETSTAT		;save status and return. 
b6ce			; 
b6ce			;   Function to get a character from the tape reader device. 
b6ce			; 
b6ce cd 7e c4		GETRDR:	CALL	READER		;get a character from reader, set status and return. 
b6d1 c3 01 b7			JP	SETSTAT 
b6d4			; 
b6d4			;  Function to perform direct console i/o. If (C) contains (FF) 
b6d4			; then this is an input request. If (C) contains (FE) then 
b6d4			; this is a status request. Otherwise we are to output (C). 
b6d4			; 
b6d4 79			DIRCIO:	LD	A,C		;test for (FF). 
b6d5 3c				INC	A 
b6d6 ca e0 b6			JP	Z,DIRC1 
b6d9 3c				INC	A		;test for (FE). 
b6da ca 5c c4			JP	Z,CONST 
b6dd c3 6b c4			JP	CONOUT		;just output (C). 
b6e0 cd 5c c4		DIRC1:	CALL	CONST		;this is an input request. 
b6e3 b7				OR	A 
b6e4 ca 91 c1			JP	Z,GOBACK1	;not ready? Just return (directly). 
b6e7 cd 5f c4			CALL	CONIN		;yes, get character. 
b6ea c3 01 b7			JP	SETSTAT		;set status and return. 
b6ed			; 
b6ed			;   Function to return the i/o byte. 
b6ed			; 
b6ed 3a 03 00		GETIOB:	LD	A,(IOBYTE) 
b6f0 c3 01 b7			JP	SETSTAT 
b6f3			; 
b6f3			;   Function to set the i/o byte. 
b6f3			; 
b6f3 21 03 00		SETIOB:	LD	HL,IOBYTE 
b6f6 71				LD	(HL),C 
b6f7 c9				RET	 
b6f8			; 
b6f8			;   Function to print the character string pointed to by (DE) 
b6f8			; on the console device. The string ends with a '$'. 
b6f8			; 
b6f8 eb			PRTSTR:	EX	DE,HL 
b6f9 4d				LD	C,L 
b6fa 44				LD	B,H		;now (BC) points to it. 
b6fb c3 d3 b5			JP	PRTMESG 
b6fe			; 
b6fe			;   Function to interigate the console device. 
b6fe			; 
b6fe cd 23 b5		GETCSTS:CALL	CKCONSOL 
b701			; 
b701			;   Get here to set the status and return to the cleanup 
b701			; section. Then back to the user. 
b701			; 
b701 32 45 b7		SETSTAT:LD	(STATUS),A 
b704 c9			RTN:	RET	 
b705			; 
b705			;   Set the status to 1 (read or write error code). 
b705			; 
b705 3e 01		IOERR1:	LD	A,1 
b707 c3 01 b7			JP	SETSTAT 
b70a			; 
b70a 00			OUTFLAG:DEFB	0		;output flag (non zero means no output). 
b70b 02			STARTING: DEFB	2		;starting position for cursor. 
b70c 00			CURPOS:	DEFB	0		;cursor position (0=start of line). 
b70d 00			PRTFLAG:DEFB	0		;printer flag (control-p toggle). List if non zero. 
b70e 00			CHARBUF:DEFB	0		;single input character buffer. 
b70f			; 
b70f			;   Stack area for BDOS calls. 
b70f			; 
b70f 00 00		USRSTACK: DEFW	0		;save users stack pointer here. 
b711			; 
b711 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 
b729 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 
b741			STKAREA:EQU	$		;end of stack area. 
b741			; 
b741 00			USERNO:	DEFB	0		;current user number. 
b742 00			ACTIVE:	DEFB	0		;currently active drive. 
b743 00 00		PARAMS:	DEFW	0		;save (DE) parameters here on entry. 
b745 00 00		STATUS:	DEFW	0		;status returned from bdos function. 
b747			; 
b747			;   Select error occured, jump to error routine. 
b747			; 
b747 21 0b b4		SLCTERR:LD	HL,BADSLCT 
b74a			; 
b74a			;   Jump to (HL) indirectly. 
b74a			; 
b74a 5e			JUMPHL:	LD	E,(HL) 
b74b 23				INC	HL 
b74c 56				LD	D,(HL)		;now (DE) contain the desired address. 
b74d eb				EX	DE,HL 
b74e e9				JP	(HL) 
b74f			; 
b74f			;   Block move. (DE) to (HL), (C) bytes total. 
b74f			; 
b74f 0c			DE2HL:	INC	C		;is count down to zero? 
b750 0d			DE2HL1:	DEC	C 
b751 c8				RET	Z		;yes, we are done. 
b752 1a				LD	A,(DE)		;no, move one more byte. 
b753 77				LD	(HL),A 
b754 13				INC	DE 
b755 23				INC	HL 
b756 c3 50 b7			JP	DE2HL1		;and repeat. 
b759			; 
b759			;   Select the desired drive. 
b759			; 
b759 3a 42 b7		SELECT:	LD	A,(ACTIVE)	;get active disk. 
b75c 4f				LD	C,A 
b75d cd 91 c4			CALL	SELDSK		;select it. 
b760 7c				LD	A,H		;valid drive? 
b761 b5				OR	L		;valid drive? 
b762 c8				RET	Z		;return if not. 
b763			; 
b763			;   Here, the BIOS returned the address of the parameter block 
b763			; in (HL). We will extract the necessary pointers and save them. 
b763			; 
b763 5e				LD	E,(HL)		;yes, get address of translation table into (DE). 
b764 23				INC	HL 
b765 56				LD	D,(HL) 
b766 23				INC	HL 
b767 22 b3 c1			LD	(SCRATCH1),HL	;save pointers to scratch areas. 
b76a 23				INC	HL 
b76b 23				INC	HL 
b76c 22 b5 c1			LD	(SCRATCH2),HL	;ditto. 
b76f 23				INC	HL 
b770 23				INC	HL 
b771 22 b7 c1			LD	(SCRATCH3),HL	;ditto. 
b774 23				INC	HL 
b775 23				INC	HL 
b776 eb				EX	DE,HL		;now save the translation table address. 
b777 22 d0 c1			LD	(XLATE),HL 
b77a 21 b9 c1			LD	HL,DIRBUF	;put the next 8 bytes here. 
b77d 0e 08			LD	C,8		;they consist of the directory buffer 
b77f cd 4f b7			CALL	DE2HL		;pointer, parameter block pointer, 
b782 2a bb c1			LD	HL,(DISKPB)	;check and allocation vectors. 
b785 eb				EX	DE,HL 
b786 21 c1 c1			LD	HL,SECTORS	;move parameter block into our ram. 
b789 0e 0f			LD	C,15		;it is 15 bytes long. 
b78b cd 4f b7			CALL	DE2HL 
b78e 2a c6 c1			LD	HL,(DSKSIZE)	;check disk size. 
b791 7c				LD	A,H		;more than 256 blocks on this? 
b792 21 dd c1			LD	HL,BIGDISK 
b795 36 ff			LD	(HL),0FFH	;set to samll. 
b797 b7				OR	A 
b798 ca 9d b7			JP	Z,SELECT1 
b79b 36 00			LD	(HL),0		;wrong, set to large. 
b79d 3e ff		SELECT1:LD	A,0FFH		;clear the zero flag. 
b79f b7				OR	A 
b7a0 c9				RET	 
b7a1			; 
b7a1			;   Routine to home the disk track head and clear pointers. 
b7a1			; 
b7a1 cd 8a c4		HOMEDRV:CALL	HOME		;home the head. 
b7a4 af				XOR	A 
b7a5 2a b5 c1			LD	HL,(SCRATCH2)	;set our track pointer also. 
b7a8 77				LD	(HL),A 
b7a9 23				INC	HL 
b7aa 77				LD	(HL),A 
b7ab 2a b7 c1			LD	HL,(SCRATCH3)	;and our sector pointer. 
b7ae 77				LD	(HL),A 
b7af 23				INC	HL 
b7b0 77				LD	(HL),A 
b7b1 c9				RET	 
b7b2			; 
b7b2			;   Do the actual disk read and check the error return status. 
b7b2			; 
b7b2 cd dd c4		DOREAD:	CALL	READ 
b7b5 c3 bb b7			JP	IORET 
b7b8			; 
b7b8			;   Do the actual disk write and handle any bios error. 
b7b8			; 
b7b8 cd e9 c4		DOWRITE:CALL	WRITE 
b7bb b7			IORET:	OR	A 
b7bc c8				RET	Z		;return unless an error occured. 
b7bd 21 09 b4			LD	HL,BADSCTR	;bad read/write on this sector. 
b7c0 c3 4a b7			JP	JUMPHL 
b7c3			; 
b7c3			;   Routine to select the track and sector that the desired 
b7c3			; block number falls in. 
b7c3			; 
b7c3 2a ea c1		TRKSEC:	LD	HL,(FILEPOS)	;get position of last accessed file 
b7c6 0e 02			LD	C,2		;in directory and compute sector #. 
b7c8 cd ea b8			CALL	SHIFTR		;sector #=file-position/4. 
b7cb 22 e5 c1			LD	(BLKNMBR),HL	;save this as the block number of interest. 
b7ce 22 ec c1			LD	(CKSUMTBL),HL	;what's it doing here too? 
b7d1			; 
b7d1			;   if the sector number has already been set (BLKNMBR), enter 
b7d1			; at this point. 
b7d1			; 
b7d1 21 e5 c1		TRKSEC1:LD	HL,BLKNMBR 
b7d4 4e				LD	C,(HL)		;move sector number into (BC). 
b7d5 23				INC	HL 
b7d6 46				LD	B,(HL) 
b7d7 2a b7 c1			LD	HL,(SCRATCH3)	;get current sector number and 
b7da 5e				LD	E,(HL)		;move this into (DE). 
b7db 23				INC	HL 
b7dc 56				LD	D,(HL) 
b7dd 2a b5 c1			LD	HL,(SCRATCH2)	;get current track number. 
b7e0 7e				LD	A,(HL)		;and this into (HL). 
b7e1 23				INC	HL 
b7e2 66				LD	H,(HL) 
b7e3 6f				LD	L,A 
b7e4 79			TRKSEC2:LD	A,C		;is desired sector before current one? 
b7e5 93				SUB	E 
b7e6 78				LD	A,B 
b7e7 9a				SBC	A,D 
b7e8 d2 fa b7			JP	NC,TRKSEC3 
b7eb e5				PUSH	HL		;yes, decrement sectors by one track. 
b7ec 2a c1 c1			LD	HL,(SECTORS)	;get sectors per track. 
b7ef 7b				LD	A,E 
b7f0 95				SUB	L 
b7f1 5f				LD	E,A 
b7f2 7a				LD	A,D 
b7f3 9c				SBC	A,H 
b7f4 57				LD	D,A		;now we have backed up one full track. 
b7f5 e1				POP	HL 
b7f6 2b				DEC	HL		;adjust track counter. 
b7f7 c3 e4 b7			JP	TRKSEC2 
b7fa e5			TRKSEC3:PUSH	HL		;desired sector is after current one. 
b7fb 2a c1 c1			LD	HL,(SECTORS)	;get sectors per track. 
b7fe 19				ADD	HL,DE		;bump sector pointer to next track. 
b7ff da 0f b8			JP	C,TRKSEC4 
b802 79				LD	A,C		;is desired sector now before current one? 
b803 95				SUB	L 
b804 78				LD	A,B 
b805 9c				SBC	A,H 
b806 da 0f b8			JP	C,TRKSEC4 
b809 eb				EX	DE,HL		;not yes, increment track counter 
b80a e1				POP	HL		;and continue until it is. 
b80b 23				INC	HL 
b80c c3 fa b7			JP	TRKSEC3 
b80f			; 
b80f			;   here we have determined the track number that contains the 
b80f			; desired sector. 
b80f			; 
b80f e1			TRKSEC4:POP	HL		;get track number (HL). 
b810 c5				PUSH	BC 
b811 d5				PUSH	DE 
b812 e5				PUSH	HL 
b813 eb				EX	DE,HL 
b814 2a ce c1			LD	HL,(OFFSET)	;adjust for first track offset. 
b817 19				ADD	HL,DE 
b818 44				LD	B,H 
b819 4d				LD	C,L 
b81a cd aa c4			CALL	SETTRK		;select this track. 
b81d d1				POP	DE		;reset current track pointer. 
b81e 2a b5 c1			LD	HL,(SCRATCH2) 
b821 73				LD	(HL),E 
b822 23				INC	HL 
b823 72				LD	(HL),D 
b824 d1				POP	DE 
b825 2a b7 c1			LD	HL,(SCRATCH3)	;reset the first sector on this track. 
b828 73				LD	(HL),E 
b829 23				INC	HL 
b82a 72				LD	(HL),D 
b82b c1				POP	BC 
b82c 79				LD	A,C		;now subtract the desired one. 
b82d 93				SUB	E		;to make it relative (1-# sectors/track). 
b82e 4f				LD	C,A 
b82f 78				LD	A,B 
b830 9a				SBC	A,D 
b831 47				LD	B,A 
b832 2a d0 c1			LD	HL,(XLATE)	;translate this sector according to this table. 
b835 eb				EX	DE,HL 
b836 cd b8 c4			CALL	SECTRN		;let the bios translate it. 
b839 4d				LD	C,L 
b83a 44				LD	B,H 
b83b c3 b1 c4			JP	SETSEC		;and select it. 
b83e			; 
b83e			;   Compute block number from record number (SAVNREC) and 
b83e			; extent number (SAVEXT). 
b83e			; 
b83e 21 c3 c1		GETBLOCK: LD	HL,BLKSHFT	;get logical to physical conversion. 
b841 4e				LD	C,(HL)		;note that this is base 2 log of ratio. 
b842 3a e3 c1			LD	A,(SAVNREC)	;get record number. 
b845 b7			GETBLK1:OR	A		;compute (A)=(A)/2^BLKSHFT. 
b846 1f				RRA	 
b847 0d				DEC	C 
b848 c2 45 b8			JP	NZ,GETBLK1 
b84b 47				LD	B,A		;save result in (B). 
b84c 3e 08			LD	A,8 
b84e 96				SUB	(HL) 
b84f 4f				LD	C,A		;compute (C)=8-BLKSHFT. 
b850 3a e2 c1			LD	A,(SAVEXT) 
b853 0d			GETBLK2:DEC	C		;compute (A)=SAVEXT*2^(8-BLKSHFT). 
b854 ca 5c b8			JP	Z,GETBLK3 
b857 b7				OR	A 
b858 17				RLA	 
b859 c3 53 b8			JP	GETBLK2 
b85c 80			GETBLK3:ADD	A,B 
b85d c9				RET	 
b85e			; 
b85e			;   Routine to extract the (BC) block byte from the fcb pointed 
b85e			; to by (PARAMS). If this is a big-disk, then these are 16 bit 
b85e			; block numbers, else they are 8 bit numbers. 
b85e			; Number is returned in (HL). 
b85e			; 
b85e 2a 43 b7		EXTBLK:	LD	HL,(PARAMS)	;get fcb address. 
b861 11 10 00			LD	DE,16		;block numbers start 16 bytes into fcb. 
b864 19				ADD	HL,DE 
b865 09				ADD	HL,BC 
b866 3a dd c1			LD	A,(BIGDISK)	;are we using a big-disk? 
b869 b7				OR	A 
b86a ca 71 b8			JP	Z,EXTBLK1 
b86d 6e				LD	L,(HL)		;no, extract an 8 bit number from the fcb. 
b86e 26 00			LD	H,0 
b870 c9				RET	 
b871 09			EXTBLK1:ADD	HL,BC		;yes, extract a 16 bit number. 
b872 5e				LD	E,(HL) 
b873 23				INC	HL 
b874 56				LD	D,(HL) 
b875 eb				EX	DE,HL		;return in (HL). 
b876 c9				RET	 
b877			; 
b877			;   Compute block number. 
b877			; 
b877 cd 3e b8		COMBLK:	CALL	GETBLOCK 
b87a 4f				LD	C,A 
b87b 06 00			LD	B,0 
b87d cd 5e b8			CALL	EXTBLK 
b880 22 e5 c1			LD	(BLKNMBR),HL 
b883 c9				RET	 
b884			; 
b884			;   Check for a zero block number (unused). 
b884			; 
b884 2a e5 c1		CHKBLK:	LD	HL,(BLKNMBR) 
b887 7d				LD	A,L		;is it zero? 
b888 b4				OR	H 
b889 c9				RET	 
b88a			; 
b88a			;   Adjust physical block (BLKNMBR) and convert to logical 
b88a			; sector (LOGSECT). This is the starting sector of this block. 
b88a			; The actual sector of interest is then added to this and the 
b88a			; resulting sector number is stored back in (BLKNMBR). This 
b88a			; will still have to be adjusted for the track number. 
b88a			; 
b88a 3a c3 c1		LOGICAL:LD	A,(BLKSHFT)	;get log2(physical/logical sectors). 
b88d 2a e5 c1			LD	HL,(BLKNMBR)	;get physical sector desired. 
b890 29			LOGICL1:ADD	HL,HL		;compute logical sector number. 
b891 3d				DEC	A		;note logical sectors are 128 bytes long. 
b892 c2 90 b8			JP	NZ,LOGICL1 
b895 22 e7 c1			LD	(LOGSECT),HL	;save logical sector. 
b898 3a c4 c1			LD	A,(BLKMASK)	;get block mask. 
b89b 4f				LD	C,A 
b89c 3a e3 c1			LD	A,(SAVNREC)	;get next sector to access. 
b89f a1				AND	C		;extract the relative position within physical block. 
b8a0 b5				OR	L		;and add it too logical sector. 
b8a1 6f				LD	L,A 
b8a2 22 e5 c1			LD	(BLKNMBR),HL	;and store. 
b8a5 c9				RET	 
b8a6			; 
b8a6			;   Set (HL) to point to extent byte in fcb. 
b8a6			; 
b8a6 2a 43 b7		SETEXT:	LD	HL,(PARAMS) 
b8a9 11 0c 00			LD	DE,12		;it is the twelth byte. 
b8ac 19				ADD	HL,DE 
b8ad c9				RET	 
b8ae			; 
b8ae			;   Set (HL) to point to record count byte in fcb and (DE) to 
b8ae			; next record number byte. 
b8ae			; 
b8ae 2a 43 b7		SETHLDE:LD	HL,(PARAMS) 
b8b1 11 0f 00			LD	DE,15		;record count byte (#15). 
b8b4 19				ADD	HL,DE 
b8b5 eb				EX	DE,HL 
b8b6 21 11 00			LD	HL,17		;next record number (#32). 
b8b9 19				ADD	HL,DE 
b8ba c9				RET	 
b8bb			; 
b8bb			;   Save current file data from fcb. 
b8bb			; 
b8bb cd ae b8		STRDATA:CALL	SETHLDE 
b8be 7e				LD	A,(HL)		;get and store record count byte. 
b8bf 32 e3 c1			LD	(SAVNREC),A 
b8c2 eb				EX	DE,HL 
b8c3 7e				LD	A,(HL)		;get and store next record number byte. 
b8c4 32 e1 c1			LD	(SAVNXT),A 
b8c7 cd a6 b8			CALL	SETEXT		;point to extent byte. 
b8ca 3a c5 c1			LD	A,(EXTMASK)	;get extent mask. 
b8cd a6				AND	(HL) 
b8ce 32 e2 c1			LD	(SAVEXT),A	;and save extent here. 
b8d1 c9				RET	 
b8d2			; 
b8d2			;   Set the next record to access. If (MODE) is set to 2, then 
b8d2			; the last record byte (SAVNREC) has the correct number to access. 
b8d2			; For sequential access, (MODE) will be equal to 1. 
b8d2			; 
b8d2 cd ae b8		SETNREC:CALL	SETHLDE 
b8d5 3a d5 c1			LD	A,(MODE)	;get sequential flag (=1). 
b8d8 fe 02			CP	2		;a 2 indicates that no adder is needed. 
b8da c2 de b8			JP	NZ,STNREC1 
b8dd af				XOR	A		;clear adder (random access?). 
b8de 4f			STNREC1:LD	C,A 
b8df 3a e3 c1			LD	A,(SAVNREC)	;get last record number. 
b8e2 81				ADD	A,C		;increment record count. 
b8e3 77				LD	(HL),A		;and set fcb's next record byte. 
b8e4 eb				EX	DE,HL 
b8e5 3a e1 c1			LD	A,(SAVNXT)	;get next record byte from storage. 
b8e8 77				LD	(HL),A		;and put this into fcb as number of records used. 
b8e9 c9				RET	 
b8ea			; 
b8ea			;   Shift (HL) right (C) bits. 
b8ea			; 
b8ea 0c			SHIFTR:	INC	C 
b8eb 0d			SHIFTR1:DEC	C 
b8ec c8				RET	Z 
b8ed 7c				LD	A,H 
b8ee b7				OR	A 
b8ef 1f				RRA	 
b8f0 67				LD	H,A 
b8f1 7d				LD	A,L 
b8f2 1f				RRA	 
b8f3 6f				LD	L,A 
b8f4 c3 eb b8			JP	SHIFTR1 
b8f7			; 
b8f7			;   Compute the check-sum for the directory buffer. Return 
b8f7			; integer sum in (A). 
b8f7			; 
b8f7 0e 80		CHECKSUM: LD	C,128		;length of buffer. 
b8f9 2a b9 c1			LD	HL,(DIRBUF)	;get its location. 
b8fc af				XOR	A		;clear summation byte. 
b8fd 86			CHKSUM1:ADD	A,(HL)		;and compute sum ignoring carries. 
b8fe 23				INC	HL 
b8ff 0d				DEC	C 
b900 c2 fd b8			JP	NZ,CHKSUM1 
b903 c9				RET	 
b904			; 
b904			;   Shift (HL) left (C) bits. 
b904			; 
b904 0c			SHIFTL:	INC	C 
b905 0d			SHIFTL1:DEC	C 
b906 c8				RET	Z 
b907 29				ADD	HL,HL		;shift left 1 bit. 
b908 c3 05 b9			JP	SHIFTL1 
b90b			; 
b90b			;   Routine to set a bit in a 16 bit value contained in (BC). 
b90b			; The bit set depends on the current drive selection. 
b90b			; 
b90b c5			SETBIT:	PUSH	BC		;save 16 bit word. 
b90c 3a 42 b7			LD	A,(ACTIVE)	;get active drive. 
b90f 4f				LD	C,A 
b910 21 01 00			LD	HL,1 
b913 cd 04 b9			CALL	SHIFTL		;shift bit 0 into place. 
b916 c1				POP	BC		;now 'or' this with the original word. 
b917 79				LD	A,C 
b918 b5				OR	L 
b919 6f				LD	L,A		;low byte done, do high byte. 
b91a 78				LD	A,B 
b91b b4				OR	H 
b91c 67				LD	H,A 
b91d c9				RET	 
b91e			; 
b91e			;   Extract the write protect status bit for the current drive. 
b91e			; The result is returned in (A), bit 0. 
b91e			; 
b91e 2a ad c1		GETWPRT:LD	HL,(WRTPRT)	;get status bytes. 
b921 3a 42 b7			LD	A,(ACTIVE)	;which drive is current? 
b924 4f				LD	C,A 
b925 cd ea b8			CALL	SHIFTR		;shift status such that bit 0 is the 
b928 7d				LD	A,L		;one of interest for this drive. 
b929 e6 01			AND	01H		;and isolate it. 
b92b c9				RET	 
b92c			; 
b92c			;   Function to write protect the current disk. 
b92c			; 
b92c 21 ad c1		WRTPRTD:LD	HL,WRTPRT	;point to status word. 
b92f 4e				LD	C,(HL)		;set (BC) equal to the status. 
b930 23				INC	HL 
b931 46				LD	B,(HL) 
b932 cd 0b b9			CALL	SETBIT		;and set this bit according to current drive. 
b935 22 ad c1			LD	(WRTPRT),HL	;then save. 
b938 2a c8 c1			LD	HL,(DIRSIZE)	;now save directory size limit. 
b93b 23				INC	HL		;remember the last one. 
b93c eb				EX	DE,HL 
b93d 2a b3 c1			LD	HL,(SCRATCH1)	;and store it here. 
b940 73				LD	(HL),E		;put low byte. 
b941 23				INC	HL 
b942 72				LD	(HL),D		;then high byte. 
b943 c9				RET	 
b944			; 
b944			;   Check for a read only file. 
b944			; 
b944 cd 5e b9		CHKROFL:CALL	FCB2HL		;set (HL) to file entry in directory buffer. 
b947 11 09 00		CKROF1:	LD	DE,9		;look at bit 7 of the ninth byte. 
b94a 19				ADD	HL,DE 
b94b 7e				LD	A,(HL) 
b94c 17				RLA	 
b94d d0				RET	NC		;return if ok. 
b94e 21 0f b4			LD	HL,ROFILE	;else, print error message and terminate. 
b951 c3 4a b7			JP	JUMPHL 
b954			; 
b954			;   Check the write protect status of the active disk. 
b954			; 
b954 cd 1e b9		CHKWPRT:CALL	GETWPRT 
b957 c8				RET	Z		;return if ok. 
b958 21 0d b4			LD	HL,RODISK	;else print message and terminate. 
b95b c3 4a b7			JP	JUMPHL 
b95e			; 
b95e			;   Routine to set (HL) pointing to the proper entry in the 
b95e			; directory buffer. 
b95e			; 
b95e 2a b9 c1		FCB2HL:	LD	HL,(DIRBUF)	;get address of buffer. 
b961 3a e9 c1			LD	A,(FCBPOS)	;relative position of file. 
b964			; 
b964			;   Routine to add (A) to (HL). 
b964			; 
b964 85			ADDA2HL:ADD	A,L 
b965 6f				LD	L,A 
b966 d0				RET	NC 
b967 24				INC	H		;take care of any carry. 
b968 c9				RET	 
b969			; 
b969			;   Routine to get the 's2' byte from the fcb supplied in 
b969			; the initial parameter specification. 
b969			; 
b969 2a 43 b7		GETS2:	LD	HL,(PARAMS)	;get address of fcb. 
b96c 11 0e 00			LD	DE,14		;relative position of 's2'. 
b96f 19				ADD	HL,DE 
b970 7e				LD	A,(HL)		;extract this byte. 
b971 c9				RET	 
b972			; 
b972			;   Clear the 's2' byte in the fcb. 
b972			; 
b972 cd 69 b9		CLEARS2:CALL	GETS2		;this sets (HL) pointing to it. 
b975 36 00			LD	(HL),0		;now clear it. 
b977 c9				RET	 
b978			; 
b978			;   Set bit 7 in the 's2' byte of the fcb. 
b978			; 
b978 cd 69 b9		SETS2B7:CALL	GETS2		;get the byte. 
b97b f6 80			OR	80H		;and set bit 7. 
b97d 77				LD	(HL),A		;then store. 
b97e c9				RET	 
b97f			; 
b97f			;   Compare (FILEPOS) with (SCRATCH1) and set flags based on 
b97f			; the difference. This checks to see if there are more file 
b97f			; names in the directory. We are at (FILEPOS) and there are 
b97f			; (SCRATCH1) of them to check. 
b97f			; 
b97f 2a ea c1		MOREFLS:LD	HL,(FILEPOS)	;we are here. 
b982 eb				EX	DE,HL 
b983 2a b3 c1			LD	HL,(SCRATCH1)	;and don't go past here. 
b986 7b				LD	A,E		;compute difference but don't keep. 
b987 96				SUB	(HL) 
b988 23				INC	HL 
b989 7a				LD	A,D 
b98a 9e				SBC	A,(HL)		;set carry if no more names. 
b98b c9				RET	 
b98c			; 
b98c			;   Call this routine to prevent (SCRATCH1) from being greater 
b98c			; than (FILEPOS). 
b98c			; 
b98c cd 7f b9		CHKNMBR:CALL	MOREFLS		;SCRATCH1 too big? 
b98f d8				RET	C 
b990 13				INC	DE		;yes, reset it to (FILEPOS). 
b991 72				LD	(HL),D 
b992 2b				DEC	HL 
b993 73				LD	(HL),E 
b994 c9				RET	 
b995			; 
b995			;   Compute (HL)=(DE)-(HL) 
b995			; 
b995 7b			SUBHL:	LD	A,E		;compute difference. 
b996 95				SUB	L 
b997 6f				LD	L,A		;store low byte. 
b998 7a				LD	A,D 
b999 9c				SBC	A,H 
b99a 67				LD	H,A		;and then high byte. 
b99b c9				RET	 
b99c			; 
b99c			;   Set the directory checksum byte. 
b99c			; 
b99c 0e ff		SETDIR:	LD	C,0FFH 
b99e			; 
b99e			;   Routine to set or compare the directory checksum byte. If 
b99e			; (C)=0ffh, then this will set the checksum byte. Else the byte 
b99e			; will be checked. If the check fails (the disk has been changed), 
b99e			; then this disk will be write protected. 
b99e			; 
b99e 2a ec c1		CHECKDIR: LD	HL,(CKSUMTBL) 
b9a1 eb				EX	DE,HL 
b9a2 2a cc c1			LD	HL,(ALLOC1) 
b9a5 cd 95 b9			CALL	SUBHL 
b9a8 d0				RET	NC		;ok if (CKSUMTBL) > (ALLOC1), so return. 
b9a9 c5				PUSH	BC 
b9aa cd f7 b8			CALL	CHECKSUM	;else compute checksum. 
b9ad 2a bd c1			LD	HL,(CHKVECT)	;get address of checksum table. 
b9b0 eb				EX	DE,HL 
b9b1 2a ec c1			LD	HL,(CKSUMTBL) 
b9b4 19				ADD	HL,DE		;set (HL) to point to byte for this drive. 
b9b5 c1				POP	BC 
b9b6 0c				INC	C		;set or check ? 
b9b7 ca c4 b9			JP	Z,CHKDIR1 
b9ba be				CP	(HL)		;check them. 
b9bb c8				RET	Z		;return if they are the same. 
b9bc cd 7f b9			CALL	MOREFLS		;not the same, do we care? 
b9bf d0				RET	NC 
b9c0 cd 2c b9			CALL	WRTPRTD		;yes, mark this as write protected. 
b9c3 c9				RET	 
b9c4 77			CHKDIR1:LD	(HL),A		;just set the byte. 
b9c5 c9				RET	 
b9c6			; 
b9c6			;   Do a write to the directory of the current disk. 
b9c6			; 
b9c6 cd 9c b9		DIRWRITE: CALL	SETDIR		;set checksum byte. 
b9c9 cd e0 b9			CALL	DIRDMA		;set directory dma address. 
b9cc 0e 01			LD	C,1		;tell the bios to actually write. 
b9ce cd b8 b7			CALL	DOWRITE		;then do the write. 
b9d1 c3 da b9			JP	DEFDMA 
b9d4			; 
b9d4			;   Read from the directory. 
b9d4			; 
b9d4 cd e0 b9		DIRREAD:CALL	DIRDMA		;set the directory dma address. 
b9d7 cd b2 b7			CALL	DOREAD		;and read it. 
b9da			; 
b9da			;   Routine to set the dma address to the users choice. 
b9da			; 
b9da 21 b1 c1		DEFDMA:	LD	HL,USERDMA	;reset the default dma address and return. 
b9dd c3 e3 b9			JP	DIRDMA1 
b9e0			; 
b9e0			;   Routine to set the dma address for directory work. 
b9e0			; 
b9e0 21 b9 c1		DIRDMA:	LD	HL,DIRBUF 
b9e3			; 
b9e3			;   Set the dma address. On entry, (HL) points to 
b9e3			; word containing the desired dma address. 
b9e3			; 
b9e3 4e			DIRDMA1:LD	C,(HL) 
b9e4 23				INC	HL 
b9e5 46				LD	B,(HL)		;setup (BC) and go to the bios to set it. 
b9e6 c3 bc c4			JP	SETDMA 
b9e9			; 
b9e9			;   Move the directory buffer into user's dma space. 
b9e9			; 
b9e9 2a b9 c1		MOVEDIR:LD	HL,(DIRBUF)	;buffer is located here, and 
b9ec eb				EX	DE,HL 
b9ed 2a b1 c1			LD	HL,(USERDMA)	; put it here. 
b9f0 0e 80			LD	C,128		;this is its length. 
b9f2 c3 4f b7			JP	DE2HL		;move it now and return. 
b9f5			; 
b9f5			;   Check (FILEPOS) and set the zero flag if it equals 0ffffh. 
b9f5			; 
b9f5 21 ea c1		CKFILPOS: LD	HL,FILEPOS 
b9f8 7e				LD	A,(HL) 
b9f9 23				INC	HL 
b9fa be				CP	(HL)		;are both bytes the same? 
b9fb c0				RET	NZ 
b9fc 3c				INC	A		;yes, but are they each 0ffh? 
b9fd c9				RET	 
b9fe			; 
b9fe			;   Set location (FILEPOS) to 0ffffh. 
b9fe			; 
b9fe 21 ff ff		STFILPOS: LD	HL,0FFFFH 
ba01 22 ea c1			LD	(FILEPOS),HL 
ba04 c9				RET	 
ba05			; 
ba05			;   Move on to the next file position within the current 
ba05			; directory buffer. If no more exist, set pointer to 0ffffh 
ba05			; and the calling routine will check for this. Enter with (C) 
ba05			; equal to 0ffh to cause the checksum byte to be set, else we 
ba05			; will check this disk and set write protect if checksums are 
ba05			; not the same (applies only if another directory sector must 
ba05			; be read). 
ba05			; 
ba05 2a c8 c1		NXENTRY:LD	HL,(DIRSIZE)	;get directory entry size limit. 
ba08 eb				EX	DE,HL 
ba09 2a ea c1			LD	HL,(FILEPOS)	;get current count. 
ba0c 23				INC	HL		;go on to the next one. 
ba0d 22 ea c1			LD	(FILEPOS),HL 
ba10 cd 95 b9			CALL	SUBHL		;(HL)=(DIRSIZE)-(FILEPOS) 
ba13 d2 19 ba			JP	NC,NXENT1	;is there more room left? 
ba16 c3 fe b9			JP	STFILPOS	;no. Set this flag and return. 
ba19 3a ea c1		NXENT1:	LD	A,(FILEPOS)	;get file position within directory. 
ba1c e6 03			AND	03H		;only look within this sector (only 4 entries fit). 
ba1e 06 05			LD	B,5		;convert to relative position (32 bytes each). 
ba20 87			NXENT2:	ADD	A,A		;note that this is not efficient code. 
ba21 05				DEC	B		;5 'ADD A's would be better. 
ba22 c2 20 ba			JP	NZ,NXENT2 
ba25 32 e9 c1			LD	(FCBPOS),A	;save it as position of fcb. 
ba28 b7				OR	A 
ba29 c0				RET	NZ		;return if we are within buffer. 
ba2a c5				PUSH	BC 
ba2b cd c3 b7			CALL	TRKSEC		;we need the next directory sector. 
ba2e cd d4 b9			CALL	DIRREAD 
ba31 c1				POP	BC 
ba32 c3 9e b9			JP	CHECKDIR 
ba35			; 
ba35			;   Routine to to get a bit from the disk space allocation 
ba35			; map. It is returned in (A), bit position 0. On entry to here, 
ba35			; set (BC) to the block number on the disk to check. 
ba35			; On return, (D) will contain the original bit position for 
ba35			; this block number and (HL) will point to the address for it. 
ba35			; 
ba35 79			CKBITMAP: LD	A,C		;determine bit number of interest. 
ba36 e6 07			AND	07H		;compute (D)=(E)=(C and 7)+1. 
ba38 3c				INC	A 
ba39 5f				LD	E,A		;save particular bit number. 
ba3a 57				LD	D,A 
ba3b			; 
ba3b			;   compute (BC)=(BC)/8. 
ba3b			; 
ba3b 79				LD	A,C 
ba3c 0f				RRCA			;now shift right 3 bits. 
ba3d 0f				RRCA	 
ba3e 0f				RRCA	 
ba3f e6 1f			AND	1FH		;and clear bits 7,6,5. 
ba41 4f				LD	C,A 
ba42 78				LD	A,B 
ba43 87				ADD	A,A		;now shift (B) into bits 7,6,5. 
ba44 87				ADD	A,A 
ba45 87				ADD	A,A 
ba46 87				ADD	A,A 
ba47 87				ADD	A,A 
ba48 b1				OR	C		;and add in (C). 
ba49 4f				LD	C,A		;ok, (C) ha been completed. 
ba4a 78				LD	A,B		;is there a better way of doing this? 
ba4b 0f				RRCA	 
ba4c 0f				RRCA	 
ba4d 0f				RRCA	 
ba4e e6 1f			AND	1FH 
ba50 47				LD	B,A		;and now (B) is completed. 
ba51			; 
ba51			;   use this as an offset into the disk space allocation 
ba51			; table. 
ba51			; 
ba51 2a bf c1			LD	HL,(ALOCVECT) 
ba54 09				ADD	HL,BC 
ba55 7e				LD	A,(HL)		;now get correct byte. 
ba56 07			CKBMAP1:RLCA			;get correct bit into position 0. 
ba57 1d				DEC	E 
ba58 c2 56 ba			JP	NZ,CKBMAP1 
ba5b c9				RET	 
ba5c			; 
ba5c			;   Set or clear the bit map such that block number (BC) will be marked 
ba5c			; as used. On entry, if (E)=0 then this bit will be cleared, if it equals 
ba5c			; 1 then it will be set (don't use anyother values). 
ba5c			; 
ba5c d5			STBITMAP: PUSH	DE 
ba5d cd 35 ba			CALL	CKBITMAP	;get the byte of interest. 
ba60 e6 fe			AND	0FEH		;clear the affected bit. 
ba62 c1				POP	BC 
ba63 b1				OR	C		;and now set it acording to (C). 
ba64			; 
ba64			;  entry to restore the original bit position and then store 
ba64			; in table. (A) contains the value, (D) contains the bit 
ba64			; position (1-8), and (HL) points to the address within the 
ba64			; space allocation table for this byte. 
ba64			; 
ba64 0f			STBMAP1:RRCA			;restore original bit position. 
ba65 15				DEC	D 
ba66 c2 64 ba			JP	NZ,STBMAP1 
ba69 77				LD	(HL),A		;and stor byte in table. 
ba6a c9				RET	 
ba6b			; 
ba6b			;   Set/clear space used bits in allocation map for this file. 
ba6b			; On entry, (C)=1 to set the map and (C)=0 to clear it. 
ba6b			; 
ba6b cd 5e b9		SETFILE:CALL	FCB2HL		;get address of fcb 
ba6e 11 10 00			LD	DE,16 
ba71 19				ADD	HL,DE		;get to block number bytes. 
ba72 c5				PUSH	BC 
ba73 0e 11			LD	C,17		;check all 17 bytes (max) of table. 
ba75 d1			SETFL1:	POP	DE 
ba76 0d				DEC	C		;done all bytes yet? 
ba77 c8				RET	Z 
ba78 d5				PUSH	DE 
ba79 3a dd c1			LD	A,(BIGDISK)	;check disk size for 16 bit block numbers. 
ba7c b7				OR	A 
ba7d ca 88 ba			JP	Z,SETFL2 
ba80 c5				PUSH	BC		;only 8 bit numbers. set (BC) to this one. 
ba81 e5				PUSH	HL 
ba82 4e				LD	C,(HL)		;get low byte from table, always 
ba83 06 00			LD	B,0		;set high byte to zero. 
ba85 c3 8e ba			JP	SETFL3 
ba88 0d			SETFL2:	DEC	C		;for 16 bit block numbers, adjust counter. 
ba89 c5				PUSH	BC 
ba8a 4e				LD	C,(HL)		;now get both the low and high bytes. 
ba8b 23				INC	HL 
ba8c 46				LD	B,(HL) 
ba8d e5				PUSH	HL 
ba8e 79			SETFL3:	LD	A,C		;block used? 
ba8f b0				OR	B 
ba90 ca 9d ba			JP	Z,SETFL4 
ba93 2a c6 c1			LD	HL,(DSKSIZE)	;is this block number within the 
ba96 7d				LD	A,L		;space on the disk? 
ba97 91				SUB	C 
ba98 7c				LD	A,H 
ba99 98				SBC	A,B 
ba9a d4 5c ba			CALL	NC,STBITMAP	;yes, set the proper bit. 
ba9d e1			SETFL4:	POP	HL		;point to next block number in fcb. 
ba9e 23				INC	HL 
ba9f c1				POP	BC 
baa0 c3 75 ba			JP	SETFL1 
baa3			; 
baa3			;   Construct the space used allocation bit map for the active 
baa3			; drive. If a file name starts with '$' and it is under the 
baa3			; current user number, then (STATUS) is set to minus 1. Otherwise 
baa3			; it is not set at all. 
baa3			; 
baa3 2a c6 c1		BITMAP:	LD	HL,(DSKSIZE)	;compute size of allocation table. 
baa6 0e 03			LD	C,3 
baa8 cd ea b8			CALL	SHIFTR		;(HL)=(HL)/8. 
baab 23				INC	HL		;at lease 1 byte. 
baac 44				LD	B,H 
baad 4d				LD	C,L		;set (BC) to the allocation table length. 
baae			; 
baae			;   Initialize the bitmap for this drive. Right now, the first 
baae			; two bytes are specified by the disk parameter block. However 
baae			; a patch could be entered here if it were necessary to setup 
baae			; this table in a special mannor. For example, the bios could 
baae			; determine locations of 'bad blocks' and set them as already 
baae			; 'used' in the map. 
baae			; 
baae 2a bf c1			LD	HL,(ALOCVECT)	;now zero out the table now. 
bab1 36 00		BITMAP1:LD	(HL),0 
bab3 23				INC	HL 
bab4 0b				DEC	BC 
bab5 78				LD	A,B 
bab6 b1				OR	C 
bab7 c2 b1 ba			JP	NZ,BITMAP1 
baba 2a ca c1			LD	HL,(ALLOC0)	;get initial space used by directory. 
babd eb				EX	DE,HL 
babe 2a bf c1			LD	HL,(ALOCVECT)	;and put this into map. 
bac1 73				LD	(HL),E 
bac2 23				INC	HL 
bac3 72				LD	(HL),D 
bac4			; 
bac4			;   End of initialization portion. 
bac4			; 
bac4 cd a1 b7			CALL	HOMEDRV		;now home the drive. 
bac7 2a b3 c1			LD	HL,(SCRATCH1) 
baca 36 03			LD	(HL),3		;force next directory request to read 
bacc 23				INC	HL		;in a sector. 
bacd 36 00			LD	(HL),0 
bacf cd fe b9			CALL	STFILPOS	;clear initial file position also. 
bad2 0e ff		BITMAP2:LD	C,0FFH		;read next file name in directory 
bad4 cd 05 ba			CALL	NXENTRY		;and set checksum byte. 
bad7 cd f5 b9			CALL	CKFILPOS	;is there another file? 
bada c8				RET	Z 
badb cd 5e b9			CALL	FCB2HL		;yes, get its address. 
bade 3e e5			LD	A,0E5H 
bae0 be				CP	(HL)		;empty file entry? 
bae1 ca d2 ba			JP	Z,BITMAP2 
bae4 3a 41 b7			LD	A,(USERNO)	;no, correct user number? 
bae7 be				CP	(HL) 
bae8 c2 f6 ba			JP	NZ,BITMAP3 
baeb 23				INC	HL 
baec 7e				LD	A,(HL)		;yes, does name start with a '$'? 
baed d6 24			SUB	'$' 
baef c2 f6 ba			JP	NZ,BITMAP3 
baf2 3d				DEC	A		;yes, set atatus to minus one. 
baf3 32 45 b7			LD	(STATUS),A 
baf6 0e 01		BITMAP3:LD	C,1		;now set this file's space as used in bit map. 
baf8 cd 6b ba			CALL	SETFILE 
bafb cd 8c b9			CALL	CHKNMBR		;keep (SCRATCH1) in bounds. 
bafe c3 d2 ba			JP	BITMAP2 
bb01			; 
bb01			;   Set the status (STATUS) and return. 
bb01			; 
bb01 3a d4 c1		STSTATUS: LD	A,(FNDSTAT) 
bb04 c3 01 b7			JP	SETSTAT 
bb07			; 
bb07			;   Check extents in (A) and (C). Set the zero flag if they 
bb07			; are the same. The number of 16k chunks of disk space that 
bb07			; the directory extent covers is expressad is (EXTMASK+1). 
bb07			; No registers are modified. 
bb07			; 
bb07 c5			SAMEXT:	PUSH	BC 
bb08 f5				PUSH	AF 
bb09 3a c5 c1			LD	A,(EXTMASK)	;get extent mask and use it to 
bb0c 2f				CPL			;to compare both extent numbers. 
bb0d 47				LD	B,A		;save resulting mask here. 
bb0e 79				LD	A,C		;mask first extent and save in (C). 
bb0f a0				AND	B 
bb10 4f				LD	C,A 
bb11 f1				POP	AF		;now mask second extent and compare 
bb12 a0				AND	B		;with the first one. 
bb13 91				SUB	C 
bb14 e6 1f			AND	1FH		;(* only check buts 0-4 *) 
bb16 c1				POP	BC		;the zero flag is set if they are the same. 
bb17 c9				RET			;restore (BC) and return. 
bb18			; 
bb18			;   Search for the first occurence of a file name. On entry, 
bb18			; register (C) should contain the number of bytes of the fcb 
bb18			; that must match. 
bb18			; 
bb18 3e ff		FINDFST:LD	A,0FFH 
bb1a 32 d4 c1			LD	(FNDSTAT),A 
bb1d 21 d8 c1			LD	HL,COUNTER	;save character count. 
bb20 71				LD	(HL),C 
bb21 2a 43 b7			LD	HL,(PARAMS)	;get filename to match. 
bb24 22 d9 c1			LD	(SAVEFCB),HL	;and save. 
bb27 cd fe b9			CALL	STFILPOS	;clear initial file position (set to 0ffffh). 
bb2a cd a1 b7			CALL	HOMEDRV		;home the drive. 
bb2d			; 
bb2d			;   Entry to locate the next occurence of a filename within the 
bb2d			; directory. The disk is not expected to have been changed. If 
bb2d			; it was, then it will be write protected. 
bb2d			; 
bb2d 0e 00		FINDNXT:LD	C,0		;write protect the disk if changed. 
bb2f cd 05 ba			CALL	NXENTRY		;get next filename entry in directory. 
bb32 cd f5 b9			CALL	CKFILPOS	;is file position = 0ffffh? 
bb35 ca 94 bb			JP	Z,FNDNXT6	;yes, exit now then. 
bb38 2a d9 c1			LD	HL,(SAVEFCB)	;set (DE) pointing to filename to match. 
bb3b eb				EX	DE,HL 
bb3c 1a				LD	A,(DE) 
bb3d fe e5			CP	0E5H		;empty directory entry? 
bb3f ca 4a bb			JP	Z,FNDNXT1	;(* are we trying to reserect erased entries? *) 
bb42 d5				PUSH	DE 
bb43 cd 7f b9			CALL	MOREFLS		;more files in directory? 
bb46 d1				POP	DE 
bb47 d2 94 bb			JP	NC,FNDNXT6	;no more. Exit now. 
bb4a cd 5e b9		FNDNXT1:CALL	FCB2HL		;get address of this fcb in directory. 
bb4d 3a d8 c1			LD	A,(COUNTER)	;get number of bytes (characters) to check. 
bb50 4f				LD	C,A 
bb51 06 00			LD	B,0		;initialize byte position counter. 
bb53 79			FNDNXT2:LD	A,C		;are we done with the compare? 
bb54 b7				OR	A 
bb55 ca 83 bb			JP	Z,FNDNXT5 
bb58 1a				LD	A,(DE)		;no, check next byte. 
bb59 fe 3f			CP	'?'		;don't care about this character? 
bb5b ca 7c bb			JP	Z,FNDNXT4 
bb5e 78				LD	A,B		;get bytes position in fcb. 
bb5f fe 0d			CP	13		;don't care about the thirteenth byte either. 
bb61 ca 7c bb			JP	Z,FNDNXT4 
bb64 fe 0c			CP	12		;extent byte? 
bb66 1a				LD	A,(DE) 
bb67 ca 73 bb			JP	Z,FNDNXT3 
bb6a 96				SUB	(HL)		;otherwise compare characters. 
bb6b e6 7f			AND	7FH 
bb6d c2 2d bb			JP	NZ,FINDNXT	;not the same, check next entry. 
bb70 c3 7c bb			JP	FNDNXT4		;so far so good, keep checking. 
bb73 c5			FNDNXT3:PUSH	BC		;check the extent byte here. 
bb74 4e				LD	C,(HL) 
bb75 cd 07 bb			CALL	SAMEXT 
bb78 c1				POP	BC 
bb79 c2 2d bb			JP	NZ,FINDNXT	;not the same, look some more. 
bb7c			; 
bb7c			;   So far the names compare. Bump pointers to the next byte 
bb7c			; and continue until all (C) characters have been checked. 
bb7c			; 
bb7c 13			FNDNXT4:INC	DE		;bump pointers. 
bb7d 23				INC	HL 
bb7e 04				INC	B 
bb7f 0d				DEC	C		;adjust character counter. 
bb80 c3 53 bb			JP	FNDNXT2 
bb83 3a ea c1		FNDNXT5:LD	A,(FILEPOS)	;return the position of this entry. 
bb86 e6 03			AND	03H 
bb88 32 45 b7			LD	(STATUS),A 
bb8b 21 d4 c1			LD	HL,FNDSTAT 
bb8e 7e				LD	A,(HL) 
bb8f 17				RLA	 
bb90 d0				RET	NC 
bb91 af				XOR	A 
bb92 77				LD	(HL),A 
bb93 c9				RET	 
bb94			; 
bb94			;   Filename was not found. Set appropriate status. 
bb94			; 
bb94 cd fe b9		FNDNXT6:CALL	STFILPOS	;set (FILEPOS) to 0ffffh. 
bb97 3e ff			LD	A,0FFH		;say not located. 
bb99 c3 01 b7			JP	SETSTAT 
bb9c			; 
bb9c			;   Erase files from the directory. Only the first byte of the 
bb9c			; fcb will be affected. It is set to (E5). 
bb9c			; 
bb9c cd 54 b9		ERAFILE:CALL	CHKWPRT		;is disk write protected? 
bb9f 0e 0c			LD	C,12		;only compare file names. 
bba1 cd 18 bb			CALL	FINDFST		;get first file name. 
bba4 cd f5 b9		ERAFIL1:CALL	CKFILPOS	;any found? 
bba7 c8				RET	Z		;nope, we must be done. 
bba8 cd 44 b9			CALL	CHKROFL		;is file read only? 
bbab cd 5e b9			CALL	FCB2HL		;nope, get address of fcb and 
bbae 36 e5			LD	(HL),0E5H	;set first byte to 'empty'. 
bbb0 0e 00			LD	C,0		;clear the space from the bit map. 
bbb2 cd 6b ba			CALL	SETFILE 
bbb5 cd c6 b9			CALL	DIRWRITE	;now write the directory sector back out. 
bbb8 cd 2d bb			CALL	FINDNXT		;find the next file name. 
bbbb c3 a4 bb			JP	ERAFIL1		;and repeat process. 
bbbe			; 
bbbe			;   Look through the space allocation map (bit map) for the 
bbbe			; next available block. Start searching at block number (BC-1). 
bbbe			; The search procedure is to look for an empty block that is 
bbbe			; before the starting block. If not empty, look at a later 
bbbe			; block number. In this way, we return the closest empty block 
bbbe			; on either side of the 'target' block number. This will speed 
bbbe			; access on random devices. For serial devices, this should be 
bbbe			; changed to look in the forward direction first and then start 
bbbe			; at the front and search some more. 
bbbe			; 
bbbe			;   On return, (DE)= block number that is empty and (HL) =0 
bbbe			; if no empry block was found. 
bbbe			; 
bbbe 50			FNDSPACE: LD	D,B		;set (DE) as the block that is checked. 
bbbf 59				LD	E,C 
bbc0			; 
bbc0			;   Look before target block. Registers (BC) are used as the lower 
bbc0			; pointer and (DE) as the upper pointer. 
bbc0			; 
bbc0 79			FNDSPA1:LD	A,C		;is block 0 specified? 
bbc1 b0				OR	B 
bbc2 ca d1 bb			JP	Z,FNDSPA2 
bbc5 0b				DEC	BC		;nope, check previous block. 
bbc6 d5				PUSH	DE 
bbc7 c5				PUSH	BC 
bbc8 cd 35 ba			CALL	CKBITMAP 
bbcb 1f				RRA			;is this block empty? 
bbcc d2 ec bb			JP	NC,FNDSPA3	;yes. use this. 
bbcf			; 
bbcf			;   Note that the above logic gets the first block that it finds 
bbcf			; that is empty. Thus a file could be written 'backward' making 
bbcf			; it very slow to access. This could be changed to look for the 
bbcf			; first empty block and then continue until the start of this 
bbcf			; empty space is located and then used that starting block. 
bbcf			; This should help speed up access to some files especially on 
bbcf			; a well used disk with lots of fairly small 'holes'. 
bbcf			; 
bbcf c1				POP	BC		;nope, check some more. 
bbd0 d1				POP	DE 
bbd1			; 
bbd1			;   Now look after target block. 
bbd1			; 
bbd1 2a c6 c1		FNDSPA2:LD	HL,(DSKSIZE)	;is block (DE) within disk limits? 
bbd4 7b				LD	A,E 
bbd5 95				SUB	L 
bbd6 7a				LD	A,D 
bbd7 9c				SBC	A,H 
bbd8 d2 f4 bb			JP	NC,FNDSPA4 
bbdb 13				INC	DE		;yes, move on to next one. 
bbdc c5				PUSH	BC 
bbdd d5				PUSH	DE 
bbde 42				LD	B,D 
bbdf 4b				LD	C,E 
bbe0 cd 35 ba			CALL	CKBITMAP	;check it. 
bbe3 1f				RRA			;empty? 
bbe4 d2 ec bb			JP	NC,FNDSPA3 
bbe7 d1				POP	DE		;nope, continue searching. 
bbe8 c1				POP	BC 
bbe9 c3 c0 bb			JP	FNDSPA1 
bbec			; 
bbec			;   Empty block found. Set it as used and return with (HL) 
bbec			; pointing to it (true?). 
bbec			; 
bbec 17			FNDSPA3:RLA			;reset byte. 
bbed 3c				INC	A		;and set bit 0. 
bbee cd 64 ba			CALL	STBMAP1		;update bit map. 
bbf1 e1				POP	HL		;set return registers. 
bbf2 d1				POP	DE 
bbf3 c9				RET	 
bbf4			; 
bbf4			;   Free block was not found. If (BC) is not zero, then we have 
bbf4			; not checked all of the disk space. 
bbf4			; 
bbf4 79			FNDSPA4:LD	A,C 
bbf5 b0				OR	B 
bbf6 c2 c0 bb			JP	NZ,FNDSPA1 
bbf9 21 00 00			LD	HL,0		;set 'not found' status. 
bbfc c9				RET	 
bbfd			; 
bbfd			;   Move a complete fcb entry into the directory and write it. 
bbfd			; 
bbfd 0e 00		FCBSET:	LD	C,0 
bbff 1e 20			LD	E,32		;length of each entry. 
bc01			; 
bc01			;   Move (E) bytes from the fcb pointed to by (PARAMS) into 
bc01			; fcb in directory starting at relative byte (C). This updated 
bc01			; directory buffer is then written to the disk. 
bc01			; 
bc01 d5			UPDATE:	PUSH	DE 
bc02 06 00			LD	B,0		;set (BC) to relative byte position. 
bc04 2a 43 b7			LD	HL,(PARAMS)	;get address of fcb. 
bc07 09				ADD	HL,BC		;compute starting byte. 
bc08 eb				EX	DE,HL 
bc09 cd 5e b9			CALL	FCB2HL		;get address of fcb to update in directory. 
bc0c c1				POP	BC		;set (C) to number of bytes to change. 
bc0d cd 4f b7			CALL	DE2HL 
bc10 cd c3 b7		UPDATE1:CALL	TRKSEC		;determine the track and sector affected. 
bc13 c3 c6 b9			JP	DIRWRITE	;then write this sector out. 
bc16			; 
bc16			;   Routine to change the name of all files on the disk with a 
bc16			; specified name. The fcb contains the current name as the 
bc16			; first 12 characters and the new name 16 bytes into the fcb. 
bc16			; 
bc16 cd 54 b9		CHGNAMES: CALL	CHKWPRT		;check for a write protected disk. 
bc19 0e 0c			LD	C,12		;match first 12 bytes of fcb only. 
bc1b cd 18 bb			CALL	FINDFST		;get first name. 
bc1e 2a 43 b7			LD	HL,(PARAMS)	;get address of fcb. 
bc21 7e				LD	A,(HL)		;get user number. 
bc22 11 10 00			LD	DE,16		;move over to desired name. 
bc25 19				ADD	HL,DE 
bc26 77				LD	(HL),A		;keep same user number. 
bc27 cd f5 b9		CHGNAM1:CALL	CKFILPOS	;any matching file found? 
bc2a c8				RET	Z		;no, we must be done. 
bc2b cd 44 b9			CALL	CHKROFL		;check for read only file. 
bc2e 0e 10			LD	C,16		;start 16 bytes into fcb. 
bc30 1e 0c			LD	E,12		;and update the first 12 bytes of directory. 
bc32 cd 01 bc			CALL	UPDATE 
bc35 cd 2d bb			CALL	FINDNXT		;get te next file name. 
bc38 c3 27 bc			JP	CHGNAM1		;and continue. 
bc3b			; 
bc3b			;   Update a files attributes. The procedure is to search for 
bc3b			; every file with the same name as shown in fcb (ignoring bit 7) 
bc3b			; and then to update it (which includes bit 7). No other changes 
bc3b			; are made. 
bc3b			; 
bc3b 0e 0c		SAVEATTR: LD	C,12		;match first 12 bytes. 
bc3d cd 18 bb			CALL	FINDFST		;look for first filename. 
bc40 cd f5 b9		SAVATR1:CALL	CKFILPOS	;was one found? 
bc43 c8				RET	Z		;nope, we must be done. 
bc44 0e 00			LD	C,0		;yes, update the first 12 bytes now. 
bc46 1e 0c			LD	E,12 
bc48 cd 01 bc			CALL	UPDATE		;update filename and write directory. 
bc4b cd 2d bb			CALL	FINDNXT		;and get the next file. 
bc4e c3 40 bc			JP	SAVATR1		;then continue until done. 
bc51			; 
bc51			;  Open a file (name specified in fcb). 
bc51			; 
bc51 0e 0f		OPENIT:	LD	C,15		;compare the first 15 bytes. 
bc53 cd 18 bb			CALL	FINDFST		;get the first one in directory. 
bc56 cd f5 b9			CALL	CKFILPOS	;any at all? 
bc59 c8				RET	Z 
bc5a cd a6 b8		OPENIT1:CALL	SETEXT		;point to extent byte within users fcb. 
bc5d 7e				LD	A,(HL)		;and get it. 
bc5e f5				PUSH	AF		;save it and address. 
bc5f e5				PUSH	HL 
bc60 cd 5e b9			CALL	FCB2HL		;point to fcb in directory. 
bc63 eb				EX	DE,HL 
bc64 2a 43 b7			LD	HL,(PARAMS)	;this is the users copy. 
bc67 0e 20			LD	C,32		;move it into users space. 
bc69 d5				PUSH	DE 
bc6a cd 4f b7			CALL	DE2HL 
bc6d cd 78 b9			CALL	SETS2B7		;set bit 7 in 's2' byte (unmodified). 
bc70 d1				POP	DE		;now get the extent byte from this fcb. 
bc71 21 0c 00			LD	HL,12 
bc74 19				ADD	HL,DE 
bc75 4e				LD	C,(HL)		;into (C). 
bc76 21 0f 00			LD	HL,15		;now get the record count byte into (B). 
bc79 19				ADD	HL,DE 
bc7a 46				LD	B,(HL) 
bc7b e1				POP	HL		;keep the same extent as the user had originally. 
bc7c f1				POP	AF 
bc7d 77				LD	(HL),A 
bc7e 79				LD	A,C		;is it the same as in the directory fcb? 
bc7f be				CP	(HL) 
bc80 78				LD	A,B		;if yes, then use the same record count. 
bc81 ca 8b bc			JP	Z,OPENIT2 
bc84 3e 00			LD	A,0		;if the user specified an extent greater than 
bc86 da 8b bc			JP	C,OPENIT2	;the one in the directory, then set record count to 0. 
bc89 3e 80			LD	A,128		;otherwise set to maximum. 
bc8b 2a 43 b7		OPENIT2:LD	HL,(PARAMS)	;set record count in users fcb to (A). 
bc8e 11 0f 00			LD	DE,15 
bc91 19				ADD	HL,DE		;compute relative position. 
bc92 77				LD	(HL),A		;and set the record count. 
bc93 c9				RET	 
bc94			; 
bc94			;   Move two bytes from (DE) to (HL) if (and only if) (HL) 
bc94			; point to a zero value (16 bit). 
bc94			;   Return with zero flag set it (DE) was moved. Registers (DE) 
bc94			; and (HL) are not changed. However (A) is. 
bc94			; 
bc94 7e			MOVEWORD: LD	A,(HL)		;check for a zero word. 
bc95 23				INC	HL 
bc96 b6				OR	(HL)		;both bytes zero? 
bc97 2b				DEC	HL 
bc98 c0				RET	NZ		;nope, just return. 
bc99 1a				LD	A,(DE)		;yes, move two bytes from (DE) into 
bc9a 77				LD	(HL),A		;this zero space. 
bc9b 13				INC	DE 
bc9c 23				INC	HL 
bc9d 1a				LD	A,(DE) 
bc9e 77				LD	(HL),A 
bc9f 1b				DEC	DE		;don't disturb these registers. 
bca0 2b				DEC	HL 
bca1 c9				RET	 
bca2			; 
bca2			;   Get here to close a file specified by (fcb). 
bca2			; 
bca2 af			CLOSEIT:XOR	A		;clear status and file position bytes. 
bca3 32 45 b7			LD	(STATUS),A 
bca6 32 ea c1			LD	(FILEPOS),A 
bca9 32 eb c1			LD	(FILEPOS+1),A 
bcac cd 1e b9			CALL	GETWPRT		;get write protect bit for this drive. 
bcaf c0				RET	NZ		;just return if it is set. 
bcb0 cd 69 b9			CALL	GETS2		;else get the 's2' byte. 
bcb3 e6 80			AND	80H		;and look at bit 7 (file unmodified?). 
bcb5 c0				RET	NZ		;just return if set. 
bcb6 0e 0f			LD	C,15		;else look up this file in directory. 
bcb8 cd 18 bb			CALL	FINDFST 
bcbb cd f5 b9			CALL	CKFILPOS	;was it found? 
bcbe c8				RET	Z		;just return if not. 
bcbf 01 10 00			LD	BC,16		;set (HL) pointing to records used section. 
bcc2 cd 5e b9			CALL	FCB2HL 
bcc5 09				ADD	HL,BC 
bcc6 eb				EX	DE,HL 
bcc7 2a 43 b7			LD	HL,(PARAMS)	;do the same for users specified fcb. 
bcca 09				ADD	HL,BC 
bccb 0e 10			LD	C,16		;this many bytes are present in this extent. 
bccd 3a dd c1		CLOSEIT1: LD	A,(BIGDISK)	;8 or 16 bit record numbers? 
bcd0 b7				OR	A 
bcd1 ca e8 bc			JP	Z,CLOSEIT4 
bcd4 7e				LD	A,(HL)		;just 8 bit. Get one from users fcb. 
bcd5 b7				OR	A 
bcd6 1a				LD	A,(DE)		;now get one from directory fcb. 
bcd7 c2 db bc			JP	NZ,CLOSEIT2 
bcda 77				LD	(HL),A		;users byte was zero. Update from directory. 
bcdb b7			CLOSEIT2: OR	A 
bcdc c2 e1 bc			JP	NZ,CLOSEIT3 
bcdf 7e				LD	A,(HL)		;directories byte was zero, update from users fcb. 
bce0 12				LD	(DE),A 
bce1 be			CLOSEIT3: CP	(HL)		;if neither one of these bytes were zero, 
bce2 c2 1f bd			JP	NZ,CLOSEIT7	;then close error if they are not the same. 
bce5 c3 fd bc			JP	CLOSEIT5	;ok so far, get to next byte in fcbs. 
bce8 cd 94 bc		CLOSEIT4: CALL	MOVEWORD	;update users fcb if it is zero. 
bceb eb				EX	DE,HL 
bcec cd 94 bc			CALL	MOVEWORD	;update directories fcb if it is zero. 
bcef eb				EX	DE,HL 
bcf0 1a				LD	A,(DE)		;if these two values are no different, 
bcf1 be				CP	(HL)		;then a close error occured. 
bcf2 c2 1f bd			JP	NZ,CLOSEIT7 
bcf5 13				INC	DE		;check second byte. 
bcf6 23				INC	HL 
bcf7 1a				LD	A,(DE) 
bcf8 be				CP	(HL) 
bcf9 c2 1f bd			JP	NZ,CLOSEIT7 
bcfc 0d				DEC	C		;remember 16 bit values. 
bcfd 13			CLOSEIT5: INC	DE		;bump to next item in table. 
bcfe 23				INC	HL 
bcff 0d				DEC	C		;there are 16 entries only. 
bd00 c2 cd bc			JP	NZ,CLOSEIT1	;continue if more to do. 
bd03 01 ec ff			LD	BC,0FFECH	;backup 20 places (extent byte). 
bd06 09				ADD	HL,BC 
bd07 eb				EX	DE,HL 
bd08 09				ADD	HL,BC 
bd09 1a				LD	A,(DE) 
bd0a be				CP	(HL)		;directory's extent already greater than the 
bd0b da 17 bd			JP	C,CLOSEIT6	;users extent? 
bd0e 77				LD	(HL),A		;no, update directory extent. 
bd0f 01 03 00			LD	BC,3		;and update the record count byte in 
bd12 09				ADD	HL,BC		;directories fcb. 
bd13 eb				EX	DE,HL 
bd14 09				ADD	HL,BC 
bd15 7e				LD	A,(HL)		;get from user. 
bd16 12				LD	(DE),A		;and put in directory. 
bd17 3e ff		CLOSEIT6: LD	A,0FFH		;set 'was open and is now closed' byte. 
bd19 32 d2 c1			LD	(CLOSEFLG),A 
bd1c c3 10 bc			JP	UPDATE1		;update the directory now. 
bd1f 21 45 b7		CLOSEIT7: LD	HL,STATUS	;set return status and then return. 
bd22 35				DEC	(HL) 
bd23 c9				RET	 
bd24			; 
bd24			;   Routine to get the next empty space in the directory. It 
bd24			; will then be cleared for use. 
bd24			; 
bd24 cd 54 b9		GETEMPTY: CALL	CHKWPRT		;make sure disk is not write protected. 
bd27 2a 43 b7			LD	HL,(PARAMS)	;save current parameters (fcb). 
bd2a e5				PUSH	HL 
bd2b 21 ac c1			LD	HL,EMPTYFCB	;use special one for empty space. 
bd2e 22 43 b7			LD	(PARAMS),HL 
bd31 0e 01			LD	C,1		;search for first empty spot in directory. 
bd33 cd 18 bb			CALL	FINDFST		;(* only check first byte *) 
bd36 cd f5 b9			CALL	CKFILPOS	;none? 
bd39 e1				POP	HL 
bd3a 22 43 b7			LD	(PARAMS),HL	;restore original fcb address. 
bd3d c8				RET	Z		;return if no more space. 
bd3e eb				EX	DE,HL 
bd3f 21 0f 00			LD	HL,15		;point to number of records for this file. 
bd42 19				ADD	HL,DE 
bd43 0e 11			LD	C,17		;and clear all of this space. 
bd45 af				XOR	A 
bd46 77			GETMT1:	LD	(HL),A 
bd47 23				INC	HL 
bd48 0d				DEC	C 
bd49 c2 46 bd			JP	NZ,GETMT1 
bd4c 21 0d 00			LD	HL,13		;clear the 's1' byte also. 
bd4f 19				ADD	HL,DE 
bd50 77				LD	(HL),A 
bd51 cd 8c b9			CALL	CHKNMBR		;keep (SCRATCH1) within bounds. 
bd54 cd fd bb			CALL	FCBSET		;write out this fcb entry to directory. 
bd57 c3 78 b9			JP	SETS2B7		;set 's2' byte bit 7 (unmodified at present). 
bd5a			; 
bd5a			;   Routine to close the current extent and open the next one 
bd5a			; for reading. 
bd5a			; 
bd5a af			GETNEXT:XOR	A 
bd5b 32 d2 c1			LD	(CLOSEFLG),A	;clear close flag. 
bd5e cd a2 bc			CALL	CLOSEIT		;close this extent. 
bd61 cd f5 b9			CALL	CKFILPOS 
bd64 c8				RET	Z		;not there??? 
bd65 2a 43 b7			LD	HL,(PARAMS)	;get extent byte. 
bd68 01 0c 00			LD	BC,12 
bd6b 09				ADD	HL,BC 
bd6c 7e				LD	A,(HL)		;and increment it. 
bd6d 3c				INC	A 
bd6e e6 1f			AND	1FH		;keep within range 0-31. 
bd70 77				LD	(HL),A 
bd71 ca 83 bd			JP	Z,GTNEXT1	;overflow? 
bd74 47				LD	B,A		;mask extent byte. 
bd75 3a c5 c1			LD	A,(EXTMASK) 
bd78 a0				AND	B 
bd79 21 d2 c1			LD	HL,CLOSEFLG	;check close flag (0ffh is ok). 
bd7c a6				AND	(HL) 
bd7d ca 8e bd			JP	Z,GTNEXT2	;if zero, we must read in next extent. 
bd80 c3 ac bd			JP	GTNEXT3		;else, it is already in memory. 
bd83 01 02 00		GTNEXT1:LD	BC,2		;Point to the 's2' byte. 
bd86 09				ADD	HL,BC 
bd87 34				INC	(HL)		;and bump it. 
bd88 7e				LD	A,(HL)		;too many extents? 
bd89 e6 0f			AND	0FH 
bd8b ca b6 bd			JP	Z,GTNEXT5	;yes, set error code. 
bd8e			; 
bd8e			;   Get here to open the next extent. 
bd8e			; 
bd8e 0e 0f		GTNEXT2:LD	C,15		;set to check first 15 bytes of fcb. 
bd90 cd 18 bb			CALL	FINDFST		;find the first one. 
bd93 cd f5 b9			CALL	CKFILPOS	;none available? 
bd96 c2 ac bd			JP	NZ,GTNEXT3 
bd99 3a d3 c1			LD	A,(RDWRTFLG)	;no extent present. Can we open an empty one? 
bd9c 3c				INC	A		;0ffh means reading (so not possible). 
bd9d ca b6 bd			JP	Z,GTNEXT5	;or an error. 
bda0 cd 24 bd			CALL	GETEMPTY	;we are writing, get an empty entry. 
bda3 cd f5 b9			CALL	CKFILPOS	;none? 
bda6 ca b6 bd			JP	Z,GTNEXT5	;error if true. 
bda9 c3 af bd			JP	GTNEXT4		;else we are almost done. 
bdac cd 5a bc		GTNEXT3:CALL	OPENIT1		;open this extent. 
bdaf cd bb b8		GTNEXT4:CALL	STRDATA		;move in updated data (rec #, extent #, etc.) 
bdb2 af				XOR	A		;clear status and return. 
bdb3 c3 01 b7			JP	SETSTAT 
bdb6			; 
bdb6			;   Error in extending the file. Too many extents were needed 
bdb6			; or not enough space on the disk. 
bdb6			; 
bdb6 cd 05 b7		GTNEXT5:CALL	IOERR1		;set error code, clear bit 7 of 's2' 
bdb9 c3 78 b9			JP	SETS2B7		;so this is not written on a close. 
bdbc			; 
bdbc			;   Read a sequential file. 
bdbc			; 
bdbc 3e 01		RDSEQ:	LD	A,1		;set sequential access mode. 
bdbe 32 d5 c1			LD	(MODE),A 
bdc1 3e ff		RDSEQ1:	LD	A,0FFH		;don't allow reading unwritten space. 
bdc3 32 d3 c1			LD	(RDWRTFLG),A 
bdc6 cd bb b8			CALL	STRDATA		;put rec# and ext# into fcb. 
bdc9 3a e3 c1			LD	A,(SAVNREC)	;get next record to read. 
bdcc 21 e1 c1			LD	HL,SAVNXT	;get number of records in extent. 
bdcf be				CP	(HL)		;within this extent? 
bdd0 da e6 bd			JP	C,RDSEQ2 
bdd3 fe 80			CP	128		;no. Is this extent fully used? 
bdd5 c2 fb bd			JP	NZ,RDSEQ3	;no. End-of-file. 
bdd8 cd 5a bd			CALL	GETNEXT		;yes, open the next one. 
bddb af				XOR	A		;reset next record to read. 
bddc 32 e3 c1			LD	(SAVNREC),A 
bddf 3a 45 b7			LD	A,(STATUS)	;check on open, successful? 
bde2 b7				OR	A 
bde3 c2 fb bd			JP	NZ,RDSEQ3	;no, error. 
bde6 cd 77 b8		RDSEQ2:	CALL	COMBLK		;ok. compute block number to read. 
bde9 cd 84 b8			CALL	CHKBLK		;check it. Within bounds? 
bdec ca fb bd			JP	Z,RDSEQ3	;no, error. 
bdef cd 8a b8			CALL	LOGICAL		;convert (BLKNMBR) to logical sector (128 byte). 
bdf2 cd d1 b7			CALL	TRKSEC1		;set the track and sector for this block #. 
bdf5 cd b2 b7			CALL	DOREAD		;and read it. 
bdf8 c3 d2 b8			JP	SETNREC		;and set the next record to be accessed. 
bdfb			; 
bdfb			;   Read error occured. Set status and return. 
bdfb			; 
bdfb c3 05 b7		RDSEQ3:	JP	IOERR1 
bdfe			; 
bdfe			;   Write the next sequential record. 
bdfe			; 
bdfe 3e 01		WTSEQ:	LD	A,1		;set sequential access mode. 
be00 32 d5 c1			LD	(MODE),A 
be03 3e 00		WTSEQ1:	LD	A,0		;allow an addition empty extent to be opened. 
be05 32 d3 c1			LD	(RDWRTFLG),A 
be08 cd 54 b9			CALL	CHKWPRT		;check write protect status. 
be0b 2a 43 b7			LD	HL,(PARAMS) 
be0e cd 47 b9			CALL	CKROF1		;check for read only file, (HL) already set to fcb. 
be11 cd bb b8			CALL	STRDATA		;put updated data into fcb. 
be14 3a e3 c1			LD	A,(SAVNREC)	;get record number to write. 
be17 fe 80			CP	128		;within range? 
be19 d2 05 b7			JP	NC,IOERR1	;no, error(?). 
be1c cd 77 b8			CALL	COMBLK		;compute block number. 
be1f cd 84 b8			CALL	CHKBLK		;check number. 
be22 0e 00			LD	C,0		;is there one to write to? 
be24 c2 6e be			JP	NZ,WTSEQ6	;yes, go do it. 
be27 cd 3e b8			CALL	GETBLOCK	;get next block number within fcb to use. 
be2a 32 d7 c1			LD	(RELBLOCK),A	;and save. 
be2d 01 00 00			LD	BC,0		;start looking for space from the start 
be30 b7				OR	A		;if none allocated as yet. 
be31 ca 3b be			JP	Z,WTSEQ2 
be34 4f				LD	C,A		;extract previous block number from fcb 
be35 0b				DEC	BC		;so we can be closest to it. 
be36 cd 5e b8			CALL	EXTBLK 
be39 44				LD	B,H 
be3a 4d				LD	C,L 
be3b cd be bb		WTSEQ2:	CALL	FNDSPACE	;find the next empty block nearest number (BC). 
be3e 7d				LD	A,L		;check for a zero number. 
be3f b4				OR	H 
be40 c2 48 be			JP	NZ,WTSEQ3 
be43 3e 02			LD	A,2		;no more space? 
be45 c3 01 b7			JP	SETSTAT 
be48 22 e5 c1		WTSEQ3:	LD	(BLKNMBR),HL	;save block number to access. 
be4b eb				EX	DE,HL		;put block number into (DE). 
be4c 2a 43 b7			LD	HL,(PARAMS)	;now we must update the fcb for this 
be4f 01 10 00			LD	BC,16		;newly allocated block. 
be52 09				ADD	HL,BC 
be53 3a dd c1			LD	A,(BIGDISK)	;8 or 16 bit block numbers? 
be56 b7				OR	A 
be57 3a d7 c1			LD	A,(RELBLOCK)	;(* update this entry *) 
be5a ca 64 be			JP	Z,WTSEQ4	;zero means 16 bit ones. 
be5d cd 64 b9			CALL	ADDA2HL		;(HL)=(HL)+(A) 
be60 73				LD	(HL),E		;store new block number. 
be61 c3 6c be			JP	WTSEQ5 
be64 4f			WTSEQ4:	LD	C,A		;compute spot in this 16 bit table. 
be65 06 00			LD	B,0 
be67 09				ADD	HL,BC 
be68 09				ADD	HL,BC 
be69 73				LD	(HL),E		;stuff block number (DE) there. 
be6a 23				INC	HL 
be6b 72				LD	(HL),D 
be6c 0e 02		WTSEQ5:	LD	C,2		;set (C) to indicate writing to un-used disk space. 
be6e 3a 45 b7		WTSEQ6:	LD	A,(STATUS)	;are we ok so far? 
be71 b7				OR	A 
be72 c0				RET	NZ 
be73 c5				PUSH	BC		;yes, save write flag for bios (register C). 
be74 cd 8a b8			CALL	LOGICAL		;convert (BLKNMBR) over to loical sectors. 
be77 3a d5 c1			LD	A,(MODE)	;get access mode flag (1=sequential, 
be7a 3d				DEC	A		;0=random, 2=special?). 
be7b 3d				DEC	A 
be7c c2 bb be			JP	NZ,WTSEQ9 
be7f			; 
be7f			;   Special random i/o from function #40. Maybe for M/PM, but the 
be7f			; current block, if it has not been written to, will be zeroed 
be7f			; out and then written (reason?). 
be7f			; 
be7f c1				POP	BC 
be80 c5				PUSH	BC 
be81 79				LD	A,C		;get write status flag (2=writing unused space). 
be82 3d				DEC	A 
be83 3d				DEC	A 
be84 c2 bb be			JP	NZ,WTSEQ9 
be87 e5				PUSH	HL 
be88 2a b9 c1			LD	HL,(DIRBUF)	;zero out the directory buffer. 
be8b 57				LD	D,A		;note that (A) is zero here. 
be8c 77			WTSEQ7:	LD	(HL),A 
be8d 23				INC	HL 
be8e 14				INC	D		;do 128 bytes. 
be8f f2 8c be			JP	P,WTSEQ7 
be92 cd e0 b9			CALL	DIRDMA		;tell the bios the dma address for directory access. 
be95 2a e7 c1			LD	HL,(LOGSECT)	;get sector that starts current block. 
be98 0e 02			LD	C,2		;set 'writing to unused space' flag. 
be9a 22 e5 c1		WTSEQ8:	LD	(BLKNMBR),HL	;save sector to write. 
be9d c5				PUSH	BC 
be9e cd d1 b7			CALL	TRKSEC1		;determine its track and sector numbers. 
bea1 c1				POP	BC 
bea2 cd b8 b7			CALL	DOWRITE		;now write out 128 bytes of zeros. 
bea5 2a e5 c1			LD	HL,(BLKNMBR)	;get sector number. 
bea8 0e 00			LD	C,0		;set normal write flag. 
beaa 3a c4 c1			LD	A,(BLKMASK)	;determine if we have written the entire 
bead 47				LD	B,A		;physical block. 
beae a5				AND	L 
beaf b8				CP	B 
beb0 23				INC	HL		;prepare for the next one. 
beb1 c2 9a be			JP	NZ,WTSEQ8	;continue until (BLKMASK+1) sectors written. 
beb4 e1				POP	HL		;reset next sector number. 
beb5 22 e5 c1			LD	(BLKNMBR),HL 
beb8 cd da b9			CALL	DEFDMA		;and reset dma address. 
bebb			; 
bebb			;   Normal disk write. Set the desired track and sector then 
bebb			; do the actual write. 
bebb			; 
bebb cd d1 b7		WTSEQ9:	CALL	TRKSEC1		;determine track and sector for this write. 
bebe c1				POP	BC		;get write status flag. 
bebf c5				PUSH	BC 
bec0 cd b8 b7			CALL	DOWRITE		;and write this out. 
bec3 c1				POP	BC 
bec4 3a e3 c1			LD	A,(SAVNREC)	;get number of records in file. 
bec7 21 e1 c1			LD	HL,SAVNXT	;get last record written. 
beca be				CP	(HL) 
becb da d2 be			JP	C,WTSEQ10 
bece 77				LD	(HL),A		;we have to update record count. 
becf 34				INC	(HL) 
bed0 0e 02			LD	C,2 
bed2			; 
bed2			;*   This area has been patched to correct disk update problem 
bed2			;* when using blocking and de-blocking in the BIOS. 
bed2			; 
bed2 00			WTSEQ10:NOP			;was 'dcr c' 
bed3 00				NOP			;was 'dcr c' 
bed4 21 00 00			LD	HL,0		;was 'jnz wtseq99' 
bed7			; 
bed7			; *   End of patch. 
bed7			; 
bed7 f5				PUSH	AF 
bed8 cd 69 b9			CALL	GETS2		;set 'extent written to' flag. 
bedb e6 7f			AND	7FH		;(* clear bit 7 *) 
bedd 77				LD	(HL),A 
bede f1				POP	AF		;get record count for this extent. 
bedf fe 7f		WTSEQ99:CP	127		;is it full? 
bee1 c2 00 bf			JP	NZ,WTSEQ12 
bee4 3a d5 c1			LD	A,(MODE)	;yes, are we in sequential mode? 
bee7 fe 01			CP	1 
bee9 c2 00 bf			JP	NZ,WTSEQ12 
beec cd d2 b8			CALL	SETNREC		;yes, set next record number. 
beef cd 5a bd			CALL	GETNEXT		;and get next empty space in directory. 
bef2 21 45 b7			LD	HL,STATUS	;ok? 
bef5 7e				LD	A,(HL) 
bef6 b7				OR	A 
bef7 c2 fe be			JP	NZ,WTSEQ11 
befa 3d				DEC	A		;yes, set record count to -1. 
befb 32 e3 c1			LD	(SAVNREC),A 
befe 36 00		WTSEQ11:LD	(HL),0		;clear status. 
bf00 c3 d2 b8		WTSEQ12:JP	SETNREC		;set next record to access. 
bf03			; 
bf03			;   For random i/o, set the fcb for the desired record number 
bf03			; based on the 'r0,r1,r2' bytes. These bytes in the fcb are 
bf03			; used as follows: 
bf03			; 
bf03			;       fcb+35            fcb+34            fcb+33 
bf03			;  |     'r-2'      |      'r-1'      |      'r-0'     | 
bf03			;  |7             0 | 7             0 | 7             0| 
bf03			;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0| 
bf03			;  |    overflow   | | extra |  extent   |   record #  | 
bf03			;  | ______________| |_extent|__number___|_____________| 
bf03			;                     also 's2' 
bf03			; 
bf03			;   On entry, register (C) contains 0ffh if this is a read 
bf03			; and thus we can not access unwritten disk space. Otherwise, 
bf03			; another extent will be opened (for writing) if required. 
bf03			; 
bf03 af			POSITION: XOR	A		;set random i/o flag. 
bf04 32 d5 c1			LD	(MODE),A 
bf07			; 
bf07			;   Special entry (function #40). M/PM ? 
bf07			; 
bf07 c5			POSITN1:PUSH	BC		;save read/write flag. 
bf08 2a 43 b7			LD	HL,(PARAMS)	;get address of fcb. 
bf0b eb				EX	DE,HL 
bf0c 21 21 00			LD	HL,33		;now get byte 'r0'. 
bf0f 19				ADD	HL,DE 
bf10 7e				LD	A,(HL) 
bf11 e6 7f			AND	7FH		;keep bits 0-6 for the record number to access. 
bf13 f5				PUSH	AF 
bf14 7e				LD	A,(HL)		;now get bit 7 of 'r0' and bits 0-3 of 'r1'. 
bf15 17				RLA	 
bf16 23				INC	HL 
bf17 7e				LD	A,(HL) 
bf18 17				RLA	 
bf19 e6 1f			AND	1FH		;and save this in bits 0-4 of (C). 
bf1b 4f				LD	C,A		;this is the extent byte. 
bf1c 7e				LD	A,(HL)		;now get the extra extent byte. 
bf1d 1f				RRA	 
bf1e 1f				RRA	 
bf1f 1f				RRA	 
bf20 1f				RRA	 
bf21 e6 0f			AND	0FH 
bf23 47				LD	B,A		;and save it in (B). 
bf24 f1				POP	AF		;get record number back to (A). 
bf25 23				INC	HL		;check overflow byte 'r2'. 
bf26 6e				LD	L,(HL) 
bf27 2c				INC	L 
bf28 2d				DEC	L 
bf29 2e 06			LD	L,6		;prepare for error. 
bf2b c2 8b bf			JP	NZ,POSITN5	;out of disk space error. 
bf2e 21 20 00			LD	HL,32		;store record number into fcb. 
bf31 19				ADD	HL,DE 
bf32 77				LD	(HL),A 
bf33 21 0c 00			LD	HL,12		;and now check the extent byte. 
bf36 19				ADD	HL,DE 
bf37 79				LD	A,C 
bf38 96				SUB	(HL)		;same extent as before? 
bf39 c2 47 bf			JP	NZ,POSITN2 
bf3c 21 0e 00			LD	HL,14		;yes, check extra extent byte 's2' also. 
bf3f 19				ADD	HL,DE 
bf40 78				LD	A,B 
bf41 96				SUB	(HL) 
bf42 e6 7f			AND	7FH 
bf44 ca 7f bf			JP	Z,POSITN3	;same, we are almost done then. 
bf47			; 
bf47			;  Get here when another extent is required. 
bf47			; 
bf47 c5			POSITN2:PUSH	BC 
bf48 d5				PUSH	DE 
bf49 cd a2 bc			CALL	CLOSEIT		;close current extent. 
bf4c d1				POP	DE 
bf4d c1				POP	BC 
bf4e 2e 03			LD	L,3		;prepare for error. 
bf50 3a 45 b7			LD	A,(STATUS) 
bf53 3c				INC	A 
bf54 ca 84 bf			JP	Z,POSITN4	;close error. 
bf57 21 0c 00			LD	HL,12		;put desired extent into fcb now. 
bf5a 19				ADD	HL,DE 
bf5b 71				LD	(HL),C 
bf5c 21 0e 00			LD	HL,14		;and store extra extent byte 's2'. 
bf5f 19				ADD	HL,DE 
bf60 70				LD	(HL),B 
bf61 cd 51 bc			CALL	OPENIT		;try and get this extent. 
bf64 3a 45 b7			LD	A,(STATUS)	;was it there? 
bf67 3c				INC	A 
bf68 c2 7f bf			JP	NZ,POSITN3 
bf6b c1				POP	BC		;no. can we create a new one (writing?). 
bf6c c5				PUSH	BC 
bf6d 2e 04			LD	L,4		;prepare for error. 
bf6f 0c				INC	C 
bf70 ca 84 bf			JP	Z,POSITN4	;nope, reading unwritten space error. 
bf73 cd 24 bd			CALL	GETEMPTY	;yes we can, try to find space. 
bf76 2e 05			LD	L,5		;prepare for error. 
bf78 3a 45 b7			LD	A,(STATUS) 
bf7b 3c				INC	A 
bf7c ca 84 bf			JP	Z,POSITN4	;out of space? 
bf7f			; 
bf7f			;   Normal return location. Clear error code and return. 
bf7f			; 
bf7f c1			POSITN3:POP	BC		;restore stack. 
bf80 af				XOR	A		;and clear error code byte. 
bf81 c3 01 b7			JP	SETSTAT 
bf84			; 
bf84			;   Error. Set the 's2' byte to indicate this (why?). 
bf84			; 
bf84 e5			POSITN4:PUSH	HL 
bf85 cd 69 b9			CALL	GETS2 
bf88 36 c0			LD	(HL),0C0H 
bf8a e1				POP	HL 
bf8b			; 
bf8b			;   Return with error code (presently in L). 
bf8b			; 
bf8b c1			POSITN5:POP	BC 
bf8c 7d				LD	A,L		;get error code. 
bf8d 32 45 b7			LD	(STATUS),A 
bf90 c3 78 b9			JP	SETS2B7 
bf93			; 
bf93			;   Read a random record. 
bf93			; 
bf93 0e ff		READRAN:LD	C,0FFH		;set 'read' status. 
bf95 cd 03 bf			CALL	POSITION	;position the file to proper record. 
bf98 cc c1 bd			CALL	Z,RDSEQ1	;and read it as usual (if no errors). 
bf9b c9				RET	 
bf9c			; 
bf9c			;   Write to a random record. 
bf9c			; 
bf9c 0e 00		WRITERAN: LD	C,0		;set 'writing' flag. 
bf9e cd 03 bf			CALL	POSITION	;position the file to proper record. 
bfa1 cc 03 be			CALL	Z,WTSEQ1	;and write as usual (if no errors). 
bfa4 c9				RET	 
bfa5			; 
bfa5			;   Compute the random record number. Enter with (HL) pointing 
bfa5			; to a fcb an (DE) contains a relative location of a record 
bfa5			; number. On exit, (C) contains the 'r0' byte, (B) the 'r1' 
bfa5			; byte, and (A) the 'r2' byte. 
bfa5			; 
bfa5			;   On return, the zero flag is set if the record is within 
bfa5			; bounds. Otherwise, an overflow occured. 
bfa5			; 
bfa5 eb			COMPRAND: EX	DE,HL		;save fcb pointer in (DE). 
bfa6 19				ADD	HL,DE		;compute relative position of record #. 
bfa7 4e				LD	C,(HL)		;get record number into (BC). 
bfa8 06 00			LD	B,0 
bfaa 21 0c 00			LD	HL,12		;now get extent. 
bfad 19				ADD	HL,DE 
bfae 7e				LD	A,(HL)		;compute (BC)=(record #)+(extent)*128. 
bfaf 0f				RRCA			;move lower bit into bit 7. 
bfb0 e6 80			AND	80H		;and ignore all other bits. 
bfb2 81				ADD	A,C		;add to our record number. 
bfb3 4f				LD	C,A 
bfb4 3e 00			LD	A,0		;take care of any carry. 
bfb6 88				ADC	A,B 
bfb7 47				LD	B,A 
bfb8 7e				LD	A,(HL)		;now get the upper bits of extent into 
bfb9 0f				RRCA			;bit positions 0-3. 
bfba e6 0f			AND	0FH		;and ignore all others. 
bfbc 80				ADD	A,B		;add this in to 'r1' byte. 
bfbd 47				LD	B,A 
bfbe 21 0e 00			LD	HL,14		;get the 's2' byte (extra extent). 
bfc1 19				ADD	HL,DE 
bfc2 7e				LD	A,(HL) 
bfc3 87				ADD	A,A		;and shift it left 4 bits (bits 4-7). 
bfc4 87				ADD	A,A 
bfc5 87				ADD	A,A 
bfc6 87				ADD	A,A 
bfc7 f5				PUSH	AF		;save carry flag (bit 0 of flag byte). 
bfc8 80				ADD	A,B		;now add extra extent into 'r1'. 
bfc9 47				LD	B,A 
bfca f5				PUSH	AF		;and save carry (overflow byte 'r2'). 
bfcb e1				POP	HL		;bit 0 of (L) is the overflow indicator. 
bfcc 7d				LD	A,L 
bfcd e1				POP	HL		;and same for first carry flag. 
bfce b5				OR	L		;either one of these set? 
bfcf e6 01			AND	01H		;only check the carry flags. 
bfd1 c9				RET	 
bfd2			; 
bfd2			;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to 
bfd2			; reflect the last record used for a random (or other) file. 
bfd2			; This reads the directory and looks at all extents computing 
bfd2			; the largerst record number for each and keeping the maximum 
bfd2			; value only. Then 'r0', 'r1', and 'r2' will reflect this 
bfd2			; maximum record number. This is used to compute the space used 
bfd2			; by a random file. 
bfd2			; 
bfd2 0e 0c		RANSIZE:LD	C,12		;look thru directory for first entry with 
bfd4 cd 18 bb			CALL	FINDFST		;this name. 
bfd7 2a 43 b7			LD	HL,(PARAMS)	;zero out the 'r0, r1, r2' bytes. 
bfda 11 21 00			LD	DE,33 
bfdd 19				ADD	HL,DE 
bfde e5				PUSH	HL 
bfdf 72				LD	(HL),D		;note that (D)=0. 
bfe0 23				INC	HL 
bfe1 72				LD	(HL),D 
bfe2 23				INC	HL 
bfe3 72				LD	(HL),D 
bfe4 cd f5 b9		RANSIZ1:CALL	CKFILPOS	;is there an extent to process? 
bfe7 ca 0c c0			JP	Z,RANSIZ3	;no, we are done. 
bfea cd 5e b9			CALL	FCB2HL		;set (HL) pointing to proper fcb in dir. 
bfed 11 0f 00			LD	DE,15		;point to last record in extent. 
bff0 cd a5 bf			CALL	COMPRAND	;and compute random parameters. 
bff3 e1				POP	HL 
bff4 e5				PUSH	HL		;now check these values against those 
bff5 5f				LD	E,A		;already in fcb. 
bff6 79				LD	A,C		;the carry flag will be set if those 
bff7 96				SUB	(HL)		;in the fcb represent a larger size than 
bff8 23				INC	HL		;this extent does. 
bff9 78				LD	A,B 
bffa 9e				SBC	A,(HL) 
bffb 23				INC	HL 
bffc 7b				LD	A,E 
bffd 9e				SBC	A,(HL) 
bffe da 06 c0			JP	C,RANSIZ2 
c001 73				LD	(HL),E		;we found a larger (in size) extent. 
c002 2b				DEC	HL		;stuff these values into fcb. 
c003 70				LD	(HL),B 
c004 2b				DEC	HL 
c005 71				LD	(HL),C 
c006 cd 2d bb		RANSIZ2:CALL	FINDNXT		;now get the next extent. 
c009 c3 e4 bf			JP	RANSIZ1		;continue til all done. 
c00c e1			RANSIZ3:POP	HL		;we are done, restore the stack and 
c00d c9				RET			;return. 
c00e			; 
c00e			;   Function to return the random record position of a given 
c00e			; file which has been read in sequential mode up to now. 
c00e			; 
c00e 2a 43 b7		SETRAN:	LD	HL,(PARAMS)	;point to fcb. 
c011 11 20 00			LD	DE,32		;and to last used record. 
c014 cd a5 bf			CALL	COMPRAND	;compute random position. 
c017 21 21 00			LD	HL,33		;now stuff these values into fcb. 
c01a 19				ADD	HL,DE 
c01b 71				LD	(HL),C		;move 'r0'. 
c01c 23				INC	HL 
c01d 70				LD	(HL),B		;and 'r1'. 
c01e 23				INC	HL 
c01f 77				LD	(HL),A		;and lastly 'r2'. 
c020 c9				RET	 
c021			; 
c021			;   This routine select the drive specified in (ACTIVE) and 
c021			; update the login vector and bitmap table if this drive was 
c021			; not already active. 
c021			; 
c021 2a af c1		LOGINDRV: LD	HL,(LOGIN)	;get the login vector. 
c024 3a 42 b7			LD	A,(ACTIVE)	;get the default drive. 
c027 4f				LD	C,A 
c028 cd ea b8			CALL	SHIFTR		;position active bit for this drive 
c02b e5				PUSH	HL		;into bit 0. 
c02c eb				EX	DE,HL 
c02d cd 59 b7			CALL	SELECT		;select this drive. 
c030 e1				POP	HL 
c031 cc 47 b7			CALL	Z,SLCTERR	;valid drive? 
c034 7d				LD	A,L		;is this a newly activated drive? 
c035 1f				RRA	 
c036 d8				RET	C 
c037 2a af c1			LD	HL,(LOGIN)	;yes, update the login vector. 
c03a 4d				LD	C,L 
c03b 44				LD	B,H 
c03c cd 0b b9			CALL	SETBIT 
c03f 22 af c1			LD	(LOGIN),HL	;and save. 
c042 c3 a3 ba			JP	BITMAP		;now update the bitmap. 
c045			; 
c045			;   Function to set the active disk number. 
c045			; 
c045 3a d6 c1		SETDSK:	LD	A,(EPARAM)	;get parameter passed and see if this 
c048 21 42 b7			LD	HL,ACTIVE	;represents a change in drives. 
c04b be				CP	(HL) 
c04c c8				RET	Z 
c04d 77				LD	(HL),A		;yes it does, log it in. 
c04e c3 21 c0			JP	LOGINDRV 
c051			; 
c051			;   This is the 'auto disk select' routine. The firsst byte 
c051			; of the fcb is examined for a drive specification. If non 
c051			; zero then the drive will be selected and loged in. 
c051			; 
c051 3e ff		AUTOSEL:LD	A,0FFH		;say 'auto-select activated'. 
c053 32 de c1			LD	(AUTO),A 
c056 2a 43 b7			LD	HL,(PARAMS)	;get drive specified. 
c059 7e				LD	A,(HL) 
c05a e6 1f			AND	1FH		;look at lower 5 bits. 
c05c 3d				DEC	A		;adjust for (1=A, 2=B) etc. 
c05d 32 d6 c1			LD	(EPARAM),A	;and save for the select routine. 
c060 fe 1e			CP	1EH		;check for 'no change' condition. 
c062 d2 75 c0			JP	NC,AUTOSL1	;yes, don't change. 
c065 3a 42 b7			LD	A,(ACTIVE)	;we must change, save currently active 
c068 32 df c1			LD	(OLDDRV),A	;drive. 
c06b 7e				LD	A,(HL)		;and save first byte of fcb also. 
c06c 32 e0 c1			LD	(AUTOFLAG),A	;this must be non-zero. 
c06f e6 e0			AND	0E0H		;whats this for (bits 6,7 are used for 
c071 77				LD	(HL),A		;something)? 
c072 cd 45 c0			CALL	SETDSK		;select and log in this drive. 
c075 3a 41 b7		AUTOSL1:LD	A,(USERNO)	;move user number into fcb. 
c078 2a 43 b7			LD	HL,(PARAMS)	;(* upper half of first byte *) 
c07b b6				OR	(HL) 
c07c 77				LD	(HL),A 
c07d c9				RET			;and return (all done). 
c07e			; 
c07e			;   Function to return the current cp/m version number. 
c07e			; 
c07e 3e 22		GETVER:	LD	A,022H		;version 2.2 
c080 c3 01 b7			JP	SETSTAT 
c083			; 
c083			;   Function to reset the disk system. 
c083			; 
c083 21 00 00		RSTDSK:	LD	HL,0		;clear write protect status and log 
c086 22 ad c1			LD	(WRTPRT),HL	;in vector. 
c089 22 af c1			LD	(LOGIN),HL 
c08c af				XOR	A		;select drive 'A'. 
c08d 32 42 b7			LD	(ACTIVE),A 
c090 21 80 00			LD	HL,TBUFF	;setup default dma address. 
c093 22 b1 c1			LD	(USERDMA),HL 
c096 cd da b9			CALL	DEFDMA 
c099 c3 21 c0			JP	LOGINDRV	;now log in drive 'A'. 
c09c			; 
c09c			;   Function to open a specified file. 
c09c			; 
c09c cd 72 b9		OPENFIL:CALL	CLEARS2		;clear 's2' byte. 
c09f cd 51 c0			CALL	AUTOSEL		;select proper disk. 
c0a2 c3 51 bc			JP	OPENIT		;and open the file. 
c0a5			; 
c0a5			;   Function to close a specified file. 
c0a5			; 
c0a5 cd 51 c0		CLOSEFIL: CALL	AUTOSEL		;select proper disk. 
c0a8 c3 a2 bc			JP	CLOSEIT		;and close the file. 
c0ab			; 
c0ab			;   Function to return the first occurence of a specified file 
c0ab			; name. If the first byte of the fcb is '?' then the name will 
c0ab			; not be checked (get the first entry no matter what). 
c0ab			; 
c0ab 0e 00		GETFST:	LD	C,0		;prepare for special search. 
c0ad eb				EX	DE,HL 
c0ae 7e				LD	A,(HL)		;is first byte a '?'? 
c0af fe 3f			CP	'?' 
c0b1 ca c2 c0			JP	Z,GETFST1	;yes, just get very first entry (zero length match). 
c0b4 cd a6 b8			CALL	SETEXT		;get the extension byte from fcb. 
c0b7 7e				LD	A,(HL)		;is it '?'? if yes, then we want 
c0b8 fe 3f			CP	'?'		;an entry with a specific 's2' byte. 
c0ba c4 72 b9			CALL	NZ,CLEARS2	;otherwise, look for a zero 's2' byte. 
c0bd cd 51 c0			CALL	AUTOSEL		;select proper drive. 
c0c0 0e 0f			LD	C,15		;compare bytes 0-14 in fcb (12&13 excluded). 
c0c2 cd 18 bb		GETFST1:CALL	FINDFST		;find an entry and then move it into 
c0c5 c3 e9 b9			JP	MOVEDIR		;the users dma space. 
c0c8			; 
c0c8			;   Function to return the next occurence of a file name. 
c0c8			; 
c0c8 2a d9 c1		GETNXT:	LD	HL,(SAVEFCB)	;restore pointers. note that no 
c0cb 22 43 b7			LD	(PARAMS),HL	;other dbos calls are allowed. 
c0ce cd 51 c0			CALL	AUTOSEL		;no error will be returned, but the 
c0d1 cd 2d bb			CALL	FINDNXT		;results will be wrong. 
c0d4 c3 e9 b9			JP	MOVEDIR 
c0d7			; 
c0d7			;   Function to delete a file by name. 
c0d7			; 
c0d7 cd 51 c0		DELFILE:CALL	AUTOSEL		;select proper drive. 
c0da cd 9c bb			CALL	ERAFILE		;erase the file. 
c0dd c3 01 bb			JP	STSTATUS	;set status and return. 
c0e0			; 
c0e0			;   Function to execute a sequential read of the specified 
c0e0			; record number. 
c0e0			; 
c0e0 cd 51 c0		READSEQ:CALL	AUTOSEL		;select proper drive then read. 
c0e3 c3 bc bd			JP	RDSEQ 
c0e6			; 
c0e6			;   Function to write the net sequential record. 
c0e6			; 
c0e6 cd 51 c0		WRTSEQ:	CALL	AUTOSEL		;select proper drive then write. 
c0e9 c3 fe bd			JP	WTSEQ 
c0ec			; 
c0ec			;   Create a file function. 
c0ec			; 
c0ec cd 72 b9		FCREATE:CALL	CLEARS2		;clear the 's2' byte on all creates. 
c0ef cd 51 c0			CALL	AUTOSEL		;select proper drive and get the next 
c0f2 c3 24 bd			JP	GETEMPTY	;empty directory space. 
c0f5			; 
c0f5			;   Function to rename a file. 
c0f5			; 
c0f5 cd 51 c0		RENFILE:CALL	AUTOSEL		;select proper drive and then switch 
c0f8 cd 16 bc			CALL	CHGNAMES	;file names. 
c0fb c3 01 bb			JP	STSTATUS 
c0fe			; 
c0fe			;   Function to return the login vector. 
c0fe			; 
c0fe 2a af c1		GETLOG:	LD	HL,(LOGIN) 
c101 c3 29 c1			JP	GETPRM1 
c104			; 
c104			;   Function to return the current disk assignment. 
c104			; 
c104 3a 42 b7		GETCRNT:LD	A,(ACTIVE) 
c107 c3 01 b7			JP	SETSTAT 
c10a			; 
c10a			;   Function to set the dma address. 
c10a			; 
c10a eb			PUTDMA:	EX	DE,HL 
c10b 22 b1 c1			LD	(USERDMA),HL	;save in our space and then get to 
c10e c3 da b9			JP	DEFDMA		;the bios with this also. 
c111			; 
c111			;   Function to return the allocation vector. 
c111			; 
c111 2a bf c1		GETALOC:LD	HL,(ALOCVECT) 
c114 c3 29 c1			JP	GETPRM1 
c117			; 
c117			;   Function to return the read-only status vector. 
c117			; 
c117 2a ad c1		GETROV:	LD	HL,(WRTPRT) 
c11a c3 29 c1			JP	GETPRM1 
c11d			; 
c11d			;   Function to set the file attributes (read-only, system). 
c11d			; 
c11d cd 51 c0		SETATTR:CALL	AUTOSEL		;select proper drive then save attributes. 
c120 cd 3b bc			CALL	SAVEATTR 
c123 c3 01 bb			JP	STSTATUS 
c126			; 
c126			;   Function to return the address of the disk parameter block 
c126			; for the current drive. 
c126			; 
c126 2a bb c1		GETPARM:LD	HL,(DISKPB) 
c129 22 45 b7		GETPRM1:LD	(STATUS),HL 
c12c c9				RET	 
c12d			; 
c12d			;   Function to get or set the user number. If (E) was (FF) 
c12d			; then this is a request to return the current user number. 
c12d			; Else set the user number from (E). 
c12d			; 
c12d 3a d6 c1		GETUSER:LD	A,(EPARAM)	;get parameter. 
c130 fe ff			CP	0FFH		;get user number? 
c132 c2 3b c1			JP	NZ,SETUSER 
c135 3a 41 b7			LD	A,(USERNO)	;yes, just do it. 
c138 c3 01 b7			JP	SETSTAT 
c13b e6 1f		SETUSER:AND	1FH		;no, we should set it instead. keep low 
c13d 32 41 b7			LD	(USERNO),A	;bits (0-4) only. 
c140 c9				RET	 
c141			; 
c141			;   Function to read a random record from a file. 
c141			; 
c141 cd 51 c0		RDRANDOM: CALL	AUTOSEL		;select proper drive and read. 
c144 c3 93 bf			JP	READRAN 
c147			; 
c147			;   Function to compute the file size for random files. 
c147			; 
c147 cd 51 c0		WTRANDOM: CALL	AUTOSEL		;select proper drive and write. 
c14a c3 9c bf			JP	WRITERAN 
c14d			; 
c14d			;   Function to compute the size of a random file. 
c14d			; 
c14d cd 51 c0		FILESIZE: CALL	AUTOSEL		;select proper drive and check file length 
c150 c3 d2 bf			JP	RANSIZE 
c153			; 
c153			;   Function #37. This allows a program to log off any drives. 
c153			; On entry, set (DE) to contain a word with bits set for those 
c153			; drives that are to be logged off. The log-in vector and the 
c153			; write protect vector will be updated. This must be a M/PM 
c153			; special function. 
c153			; 
c153 2a 43 b7		LOGOFF:	LD	HL,(PARAMS)	;get drives to log off. 
c156 7d				LD	A,L		;for each bit that is set, we want 
c157 2f				CPL			;to clear that bit in (LOGIN) 
c158 5f				LD	E,A		;and (WRTPRT). 
c159 7c				LD	A,H 
c15a 2f				CPL	 
c15b 2a af c1			LD	HL,(LOGIN)	;reset the login vector. 
c15e a4				AND	H 
c15f 57				LD	D,A 
c160 7d				LD	A,L 
c161 a3				AND	E 
c162 5f				LD	E,A 
c163 2a ad c1			LD	HL,(WRTPRT) 
c166 eb				EX	DE,HL 
c167 22 af c1			LD	(LOGIN),HL	;and save. 
c16a 7d				LD	A,L		;now do the write protect vector. 
c16b a3				AND	E 
c16c 6f				LD	L,A 
c16d 7c				LD	A,H 
c16e a2				AND	D 
c16f 67				LD	H,A 
c170 22 ad c1			LD	(WRTPRT),HL	;and save. all done. 
c173 c9				RET	 
c174			; 
c174			;   Get here to return to the user. 
c174			; 
c174 3a de c1		GOBACK:	LD	A,(AUTO)	;was auto select activated? 
c177 b7				OR	A 
c178 ca 91 c1			JP	Z,GOBACK1 
c17b 2a 43 b7			LD	HL,(PARAMS)	;yes, but was a change made? 
c17e 36 00			LD	(HL),0		;(* reset first byte of fcb *) 
c180 3a e0 c1			LD	A,(AUTOFLAG) 
c183 b7				OR	A 
c184 ca 91 c1			JP	Z,GOBACK1 
c187 77				LD	(HL),A		;yes, reset first byte properly. 
c188 3a df c1			LD	A,(OLDDRV)	;and get the old drive and select it. 
c18b 32 d6 c1			LD	(EPARAM),A 
c18e cd 45 c0			CALL	SETDSK 
c191 2a 0f b7		GOBACK1:LD	HL,(USRSTACK)	;reset the users stack pointer. 
c194 f9				LD	SP,HL 
c195 2a 45 b7			LD	HL,(STATUS)	;get return status. 
c198 7d				LD	A,L		;force version 1.4 compatability. 
c199 44				LD	B,H 
c19a c9				RET			;and go back to user. 
c19b			; 
c19b			;   Function #40. This is a special entry to do random i/o. 
c19b			; For the case where we are writing to unused disk space, this 
c19b			; space will be zeroed out first. This must be a M/PM special 
c19b			; purpose function, because why would any normal program even 
c19b			; care about the previous contents of a sector about to be 
c19b			; written over. 
c19b			; 
c19b cd 51 c0		WTSPECL:CALL	AUTOSEL		;select proper drive. 
c19e 3e 02			LD	A,2		;use special write mode. 
c1a0 32 d5 c1			LD	(MODE),A 
c1a3 0e 00			LD	C,0		;set write indicator. 
c1a5 cd 07 bf			CALL	POSITN1		;position the file. 
c1a8 cc 03 be			CALL	Z,WTSEQ1	;and write (if no errors). 
c1ab c9				RET	 
c1ac			; 
c1ac			;************************************************************** 
c1ac			;* 
c1ac			;*     BDOS data storage pool. 
c1ac			;* 
c1ac			;************************************************************** 
c1ac			; 
c1ac e5			EMPTYFCB: DEFB	0E5H		;empty directory segment indicator. 
c1ad 00 00		WRTPRT:	DEFW	0		;write protect status for all 16 drives. 
c1af 00 00		LOGIN:	DEFW	0		;drive active word (1 bit per drive). 
c1b1 80 00		USERDMA:DEFW	080H		;user's dma address (defaults to 80h). 
c1b3			; 
c1b3			;   Scratch areas from parameter block. 
c1b3			; 
c1b3 00 00		SCRATCH1: DEFW	0		;relative position within dir segment for file (0-3). 
c1b5 00 00		SCRATCH2: DEFW	0		;last selected track number. 
c1b7 00 00		SCRATCH3: DEFW	0		;last selected sector number. 
c1b9			; 
c1b9			;   Disk storage areas from parameter block. 
c1b9			; 
c1b9 00 00		DIRBUF:	DEFW	0		;address of directory buffer to use. 
c1bb 00 00		DISKPB:	DEFW	0		;contains address of disk parameter block. 
c1bd 00 00		CHKVECT:DEFW	0		;address of check vector. 
c1bf 00 00		ALOCVECT: DEFW	0		;address of allocation vector (bit map). 
c1c1			; 
c1c1			;   Parameter block returned from the bios. 
c1c1			; 
c1c1 00 00		SECTORS:DEFW	0		;sectors per track from bios. 
c1c3 00			BLKSHFT:DEFB	0		;block shift. 
c1c4 00			BLKMASK:DEFB	0		;block mask. 
c1c5 00			EXTMASK:DEFB	0		;extent mask. 
c1c6 00 00		DSKSIZE:DEFW	0		;disk size from bios (number of blocks-1). 
c1c8 00 00		DIRSIZE:DEFW	0		;directory size. 
c1ca 00 00		ALLOC0:	DEFW	0		;storage for first bytes of bit map (dir space used). 
c1cc 00 00		ALLOC1:	DEFW	0 
c1ce 00 00		OFFSET:	DEFW	0		;first usable track number. 
c1d0 00 00		XLATE:	DEFW	0		;sector translation table address. 
c1d2			; 
c1d2			; 
c1d2 00			CLOSEFLG: DEFB	0		;close flag (=0ffh is extent written ok). 
c1d3 00			RDWRTFLG: DEFB	0		;read/write flag (0ffh=read, 0=write). 
c1d4 00			FNDSTAT:DEFB	0		;filename found status (0=found first entry). 
c1d5 00			MODE:	DEFB	0		;I/o mode select (0=random, 1=sequential, 2=special random). 
c1d6 00			EPARAM:	DEFB	0		;storage for register (E) on entry to bdos. 
c1d7 00			RELBLOCK: DEFB	0		;relative position within fcb of block number written. 
c1d8 00			COUNTER:DEFB	0		;byte counter for directory name searches. 
c1d9 00 00 00 00	SAVEFCB:DEFW	0,0		;save space for address of fcb (for directory searches). 
c1dd 00			BIGDISK:DEFB	0		;if =0 then disk is > 256 blocks long. 
c1de 00			AUTO:	DEFB	0		;if non-zero, then auto select activated. 
c1df 00			OLDDRV:	DEFB	0		;on auto select, storage for previous drive. 
c1e0 00			AUTOFLAG: DEFB	0		;if non-zero, then auto select changed drives. 
c1e1 00			SAVNXT:	DEFB	0		;storage for next record number to access. 
c1e2 00			SAVEXT:	DEFB	0		;storage for extent number of file. 
c1e3 00 00		SAVNREC:DEFW	0		;storage for number of records in file. 
c1e5 00 00		BLKNMBR:DEFW	0		;block number (physical sector) used within a file or logical sect 
c1e7 00 00		LOGSECT:DEFW	0		;starting logical (128 byte) sector of block (physical sector). 
c1e9 00			FCBPOS:	DEFB	0		;relative position within buffer for fcb of file of interest. 
c1ea 00 00		FILEPOS:DEFW	0		;files position within directory (0 to max entries -1). 
c1ec			; 
c1ec			;   Disk directory buffer checksum bytes. One for each of the 
c1ec			; 16 possible drives. 
c1ec			; 
c1ec 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00	CKSUMTBL: DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 
c1fc			; 
c1fc			;   Extra space ? 
c1fc			; 
c1fc 00 00 00 00		DEFB	0,0,0,0 
c200			; 
c200			;************************************************************** 
c200			;* 
c200			;*        B I O S 
c200			;* 
c200			;************************************************************** 
c200			; 
c200			;	customized cbios for STM32ZXCPM CP/M 2.2 alteration 
c200			; 
c200			ccp:	equ	(MEM-7)*1024;base of ccp 
c200			bdos:	equ	ccp+0806h	;bdos entry 
c200			bios:	equ	ccp+01600h	;base of bios 
c200			cdisk:	equ	0004h		;address of current disk number 0=a,... 15=p 
c200			iobyte:	equ	0003h		;intel i/o byte 
c200			disks:	equ	08h		;number of disks in the system 
c200			; 
c200			;	I/O ports 
c200			; 
c200			cstp:	equ	0		;console status port 
c200			ciop:	equ	1		;console input/output port 
c200			sstp:	equ	2		;serial status port 
c200			siop:	equ	3		;serial input/output port 
c200			ddskp:	equ	8		;disk selct disk port 
c200			dtrkp:	equ	9		;disk select track  low/high byte port 
c200			dsecp:	equ	10		;disk select sector  low/high byte port 
c200			ddmalp:	equ	11		;disk set dma addr low byte port 
c200			ddmahp:	equ	12		;disk set dma addr high byte port 
c200			dcmdp:	equ	13		;disk command port 
c200			 
c200			; 
c200			nsects:	equ	($-ccp)/128	;warm start sector count 
c200			; 
c200			;	jump vector for individual subroutines 
c200			; 
c200			 
c200 c3 c2 c3			JP	BOOT	;cold start 
c203 c3 cf c3		WBOOTE:	JP	WBOOT	;warm start 
c206 c3 5c c4			JP	CONST	;console status 
c209 c3 5f c4			JP	CONIN	;console character in 
c20c c3 6b c4			JP	CONOUT	;console character out 
c20f c3 6f c4			JP	LIST	;LIST character out 
c212 c3 73 c4			JP	PUNCH	;PUNCH character out 
c215 c3 7e c4			JP	READER	;READER character out 
c218 c3 8a c4			JP	HOME	;move head to HOME position 
c21b c3 91 c4			JP	SELDSK	;select disk 
c21e c3 aa c4			JP	SETTRK	;set track number 
c221 c3 b1 c4			JP	SETSEC	;set sector number 
c224 c3 bc c4			JP	SETDMA	;set dma address 
c227 c3 dd c4			JP	READ	;READ disk 
c22a c3 e9 c4			JP	WRITE	;WRITE disk 
c22d c3 71 c4			JP	LISTST	;return LIST status 
c230 c3 b8 c4			JP	SECTRN	;sector translate 
c233			; 
c233			;	fixed data tables for four-drive standard 
c233			;	ibm-compatible 8" disks 
c233			;	no translations 
c233			; 
c233			;	disk Parameter header for disk 00 
c233 00 00 00 00	dpbase:	defw	0000h, 0000h 
c237 00 00 00 00	    defw	0000h, 0000h 
c23b 27 c5 b3 c3	    defw	dirbf, dpblk 
c23f 9f c6 a7 c5	    defw	chk00, all00 
c243			;	disk parameter header for disk 01 
c243 00 00 00 00	    defw	0000h, 0000h 
c247 00 00 00 00	    defw	0000h, 0000h 
c24b 27 c5 b3 c3	    defw	dirbf, dpblk 
c24f af c6 c6 c5	    defw	chk01, all01 
c253			;	disk parameter header for disk 02 
c253 00 00 00 00	    defw	0000h, 0000h 
c257 00 00 00 00	    defw	0000h, 0000h 
c25b 27 c5 b3 c3	    defw	dirbf, dpblk 
c25f bf c6 e5 c5	    defw	chk02, all02 
c263			;	disk parameter header for disk 03 
c263 00 00 00 00	    defw	0000h, 0000h 
c267 00 00 00 00	    defw	0000h, 0000h 
c26b 27 c5 b3 c3	    defw	dirbf, dpblk 
c26f cf c6 04 c6	    defw	chk03, all03 
c273			;	disk parameter header for disk 04 
c273 00 00 00 00	    defw	0000h, 0000h 
c277 00 00 00 00	    defw	0000h, 0000h 
c27b 27 c5 b3 c3	    defw	dirbf, dpblk 
c27f df c6 23 c6	    defw	chk04, all04 
c283			;	disk parameter header for disk 05 
c283 00 00 00 00	    defw	0000h, 0000h 
c287 00 00 00 00	    defw	0000h, 0000h 
c28b 27 c5 b3 c3	    defw	dirbf, dpblk 
c28f ef c6 42 c6	    defw	chk05, all05 
c293			;	disk parameter header for disk 06 
c293 00 00 00 00	    defw	0000h, 0000h 
c297 00 00 00 00	    defw	0000h, 0000h 
c29b 27 c5 b3 c3	    defw	dirbf, dpblk 
c29f ff c6 61 c6	    defw	chk06, all06 
c2a3			;	disk parameter header for disk 07 
c2a3 00 00 00 00	    defw	0000h, 0000h 
c2a7 00 00 00 00	    defw	0000h, 0000h 
c2ab 27 c5 b3 c3	    defw	dirbf, dpblk 
c2af 0f c7 80 c6	    defw	chk07, all07 
c2b3			; 
c2b3			;	sector translate vector 
c2b3			trans: 
c2b3 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f		defm	  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15 
c2c3 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f		defm	 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31 
c2d3 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f		defm	 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47 
c2e3 30 31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f		defm	 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63 
c2f3 40 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f		defm	 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79 
c303 50 51 52 53 54 55 56 57 58 59 5a 5b 5c 5d 5e 5f		defm	 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95 
c313 60 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f		defm	 96, 97, 98, 99,100,101,102,103,104,105,106,107,108,109,110,111 
c323 70 71 72 73 74 75 76 77 78 79 7a 7b 7c 7d 7e 7f		defm	112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127 
c333 80 81 82 83 84 85 86 87 88 89 8a 8b 8c 8d 8e 8f		defm	128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143 
c343 90 91 92 93 94 95 96 97 98 99 9a 9b 9c 9d 9e 9f		defm	144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159 
c353 a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 aa ab ac ad ae af		defm	160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175 
c363 b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 ba bb bc bd be bf		defm	176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191 
c373 c0 c1 c2 c3 c4 c5 c6 c7 c8 c9 ca cb cc cd ce cf		defm	192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207 
c383 d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 da db dc dd de df		defm	208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223 
c393 e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 ea eb ec ed ee ef		defm	224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239 
c3a3 f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 fa fb fc fd fe ff		defm	240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255 
c3b3			; 
c3b3			dpblk:	;disk parameter block for all disks. 
c3b3 00 01		    defw	256		;sectors per track 
c3b5 04			    defm	4		;block shift factor 
c3b6 0f			    defm	15		;block mask 
c3b7 00			    defm	0		;extent mask 
c3b8 ef 0f		    defw	4079		;disk size-1 
c3ba ff 00		    defw	255		;directory max 
c3bc f0			    defm	240		;alloc 0 
c3bd 00			    defm	0		;alloc 1 
c3be 00 00		    defw	0		;check size 
c3c0 01 00		    defw	1		;track offset 
c3c2			; 
c3c2			;	end of fixed tables 
c3c2			; 
c3c2			;	individual subroutines to perform each function 
c3c2			BOOT:	;simplest case is to just perform parameter initialization 
c3c2 af			    XOR	a		;zero in the accum 
c3c3 32 03 00		    LD	(iobyte),A	;clear the iobyte 
c3c6 32 04 00		    LD	(cdisk),A	;select disk zero 
c3c9 31 80 00		    LD	sp, 80h		;use end of memory for stack 
c3cc c3 03 c4		    JP	gocpm		;initialize and go to cp/m 
c3cf			; 
c3cf			WBOOT:	;simplest case is to READ the disk until all sectors loaded 
c3cf 31 80 00		    LD	sp, 80h		;use space below buffer for stack 
c3d2 0e 00		    LD 	c, 0		;select disk 0 
c3d4 cd 91 c4		    call	SELDSK 
c3d7 cd 8a c4		    call	HOME		;go to track 00 
c3da			; 
c3da 06 2c		    LD 	b, nsects	;b counts * of sectors to load 
c3dc 0e 00		    LD 	c, 0		;c has the current track number 
c3de 16 01		    LD 	d, 1		;d has the next sector to READ 
c3e0			;	note that we begin by READing track 0, sector 2 since sector 1 
c3e0			;	contains the cold start loader, which is skipped in a warm start 
c3e0 21 00 ac		    LD	HL, ccp		;base of cp/m (initial load point) 
c3e3			load1:	;load	one more sector 
c3e3 c5			    PUSH	BC		;save sector count, current track 
c3e4 d5			    PUSH	DE		;save next sector to READ 
c3e5 e5			    PUSH	HL		;save dma address 
c3e6 4a			    LD 		c, d		;get sector address to register C 
c3e7 cd b1 c4		    call	SETSEC		;set sector address from register C 
c3ea c1			    pop		BC		;recall dma address to b, C 
c3eb c5			    PUSH	BC		;replace on stack for later recall 
c3ec cd bc c4		    call	SETDMA		;set dma address from b, C 
c3ef			; 
c3ef			;	drive set to 0, track set, sector set, dma address set 
c3ef cd dd c4		    call	READ 
c3f2 fe 00		    CP	00h		;any errors? 
c3f4 c2 cf c3		    JP	NZ,WBOOT	;retry the entire BOOT if an error occurs 
c3f7			; 
c3f7			;	no error, move to next sector 
c3f7 e1			    pop	HL		;recall dma address 
c3f8 11 80 00		    LD	DE, 128		;dma=dma+128 
c3fb 19			    ADD	HL,DE		;new dma address is in h, l 
c3fc d1			    pop	DE		;recall sector address 
c3fd c1			    pop	BC		;recall number of sectors remaining, and current trk 
c3fe 14			    INC D		;next sector to READ 
c3ff 05			    DEC	b		;sectors=sectors-1 
c400 c2 e3 c3		    JP	NZ,load1	;loop for READ next sector 
c403			; 
c403			; 
c403			;	end of	load operation, set parameters and go to cp/m 
c403			gocpm: 
c403 3e c3		    LD 	a, 0c3h		;c3 is a jmp instruction 
c405 32 00 00		    LD	(0),A		;for jmp to WBOOT 
c408 21 03 c2		    LD	HL, WBOOTE	;WBOOT entry point 
c40b 22 01 00		    LD	(1),HL		;set address field for jmp at 0 
c40e			; 
c40e 32 05 00		    LD	(5),A		;for jmp to bdos 
c411 21 06 b4		    LD	HL, bdos	;bdos entry point 
c414 22 06 00		    LD	(6),HL		;address field of Jump at 5 to bdos 
c417			; 
c417 01 80 00		    LD	BC, 80h		;default dma address is 80h 
c41a cd bc c4		    call	SETDMA 
c41d			; 
c41d			;out boot message 
c41d			; 
c41d 21 2d c4				ld	hl, bmsg 
c420			msgloop:		 
c420 7e					ld	a,(hl) 
c421 b7					OR	A 
c422 ca 4d c4				jp	z, gocpm1 
c425 4f					ld	c,a 
c426 cd 6b c4				call CONOUT 
c429 23					inc HL 
c42a c3 20 c4				JP	msgloop 
c42d 0d 0a		bmsg:	defb 0dh, 0ah 
c42f .. 0d 0a 00		defb '50k CP/M 2.2 for STM32ZXCPM', 0dh, 0ah, 0 
c44d			; 
c44d			gocpm1: 
c44d fb			    ei			;enable the interrupt system 
c44e 3a 04 00		    LD	A,(cdisk)	;get current disk number 
c451 fe 08		    cp	disks		;see if valid disk number 
c453 da 58 c4		    jp	c,diskok	;disk valid, go to ccp 
c456 3e 00		    ld	a,0		;invalid disk, change to disk 0 
c458 4f			diskok:	LD 	c, a		;send to the ccp 
c459 c3 00 ac				JP	ccp		;go to cp/m for further processing 
c45c			; 
c45c			; 
c45c			;	simple i/o handlers (must be filled in by user) 
c45c			;	in each case, the entry point is provided, with space reserved 
c45c			;	to insert your own code 
c45c			; 
c45c			CONST:	;console status, return 0ffh if character READy, 00h if not 
c45c db 00		    in 	a,(cstp)		;get status 
c45e c9			    ret 
c45f			; 
c45f			CONIN:	;console character into register a 
c45f db 00		    in 	a,(cstp)		;get status 
c461 e6 ff		    and	0ffh		;check RxRDY 
c463 ca 5f c4		    jp 	z,CONIN		;loop until char READy 
c466 db 01		    in 	a,(ciop)		;get char 
c468 e6 7f		    AND	7fh		;strip parity bit 
c46a c9			    ret 
c46b			; 
c46b			CONOUT:	;console character output from register c 
c46b 79			    ld	a, c 
c46c d3 01		    out	(ciop),a		;out to port 
c46e c9			    ret 
c46f			; 
c46f			LIST:	;LIST character from register c 
c46f 79			    LD 	a, c	  	;character to register a 
c470 c9			    ret		  	;null subroutine 
c471			; 
c471			LISTST:	;return LIST status (0 if not READy, 1 if READy) 
c471 af			    XOR	a	 	;0 is always ok to return 
c472 c9			    ret 
c473			; 
c473			PUNCH:	;PUNCH	character from	register C 
c473 db 02		    in 	a,(sstp)	;get status 
c475 e6 01		    and	001h		;check TxRDY bit 
c477 ca 73 c4		    jp 	z,PUNCH		;loop until char READy 
c47a 79			    LD 	a, c		;character to register a 
c47b d3 03		    out (siop), a 
c47d c9			    ret			;null subroutine 
c47e			; 
c47e			; 
c47e			READER:	;READER character into register a from READER device 
c47e db 02		    in 	a,(sstp)	;get status 
c480 e6 02		    and	002h		;check RxRDY bit 
c482 ca 7e c4		    jp 	z,READER	;loop until char READy 
c485 db 03		    in	a, (siop) 
c487 e6 7f		    AND    7fh		;remember to strip parity bit 
c489 c9			    ret 
c48a			; 
c48a			; 
c48a			;	i/o drivers for the disk follow 
c48a			;	for now, we will simply store the parameters away for use 
c48a			;	in the READ and WRITE	subroutines 
c48a			; 
c48a			HOME:	;move to the track 00	position of current drive 
c48a			;	translate this call into a SETTRK call with Parameter 00 
c48a 01 00 00		    LD     bc, 0		;select track 0 
c48d cd aa c4		    call   SETTRK 
c490 c9			    ret			;we will move to 00 on first READ/WRITE 
c491			; 
c491			SELDSK:	;select disk given by register c 
c491 21 00 00		    LD	HL, 0000h	;error return code 
c494 79			    LD 	a, c 
c495 32 26 c5		    LD	(diskno),A 
c498 fe 08		    CP	disks		;must be between 0 and 3 
c49a d0			    RET	NC		;no carry if 4, 5,... 
c49b			;	disk number is in the proper range 
c49b			;	defs	10		;space for disk select 
c49b			;	compute proper disk Parameter header address 
c49b 3a 26 c5		    LD	A,(diskno) 
c49e 6f			    LD 	l, a		;l=disk number 0, 1, 2, 3 
c49f 26 00		    LD 	h, 0		;high order zero 
c4a1 29			    ADD	HL,HL		;*2 
c4a2 29			    ADD	HL,HL		;*4 
c4a3 29			    ADD	HL,HL		;*8 
c4a4 29			    ADD	HL,HL		;*16 (size of each header) 
c4a5 11 33 c2		    LD	DE, dpbase 
c4a8 19			    ADD	HL,DE		;hl=,dpbase (diskno*16) Note typo here in original source. 
c4a9 c9			    ret 
c4aa			; 
c4aa			SETTRK:	;set track given by register c 
c4aa 69			    LD 	l, c 
c4ab 26 00		    LD 	h, 0 
c4ad 22 20 c5		    LD	(track),HL 
c4b0 c9			    ret 
c4b1			; 
c4b1			SETSEC:	;set sector given by register c 
c4b1 69			    LD 	l, c 
c4b2 26 00		    LD 	h, 0 
c4b4 22 22 c5		    LD	(sector),HL 
c4b7 c9			    ret 
c4b8			; 
c4b8			; 
c4b8			SECTRN: 
c4b8			    ;translate the sector given by bc using the 
c4b8			    ;translate table given by de 
c4b8			;    EX	DE,HL		;hl=.trans 
c4b8			;    ADD	HL,BC		;hl=.trans (sector) 
c4b8			;    LD 	l, (hl)		;l=trans (sector) 
c4b8 69			    LD	l, c 
c4b9 26 00		    LD 	h, 0		;hl=trans (sector) 
c4bb c9			    ret			;with value in hl 
c4bc			; 
c4bc			SETDMA:	;set	dma address given by registers b and c 
c4bc 69			    LD 	l, c		;low order address 
c4bd 60			    LD 	h, b		;high order address 
c4be 22 24 c5		    LD	(dmaad),HL	;save the address 
c4c1 c9			    ret 
c4c2			; 
c4c2			SETDOP:	;set disk operation parameters 
c4c2 3a 26 c5			ld	a,(diskno)		;disk 
c4c5 d3 08			out	(ddskp),a			; 
c4c7 2a 20 c5			ld	HL,(track)		;track 
c4ca 7d				ld	a,l 
c4cb d3 09			out	(dtrkp),a			;lba bits 0 - 7 
c4cd 2a 22 c5			ld	HL,(sector)		;sector 
c4d0 7d				ld	a,l 
c4d1 d3 0a			out	(dsecp),a			;lba bits 0 - 7 
c4d3 2a 24 c5			ld	HL,(dmaad)		;dma addres 
c4d6 7d				ld	a,l 
c4d7 d3 0b			out	(ddmalp),a			;lba bits 0 - 7 
c4d9 7c				ld	a,h 
c4da d3 0c			out	(ddmahp),a			;lba bits 8 - 15 
c4dc c9				ret 
c4dd			READ: 
c4dd			;Read one CP/M sector from disk. 
c4dd			;Return a 00h in register a if the operation completes properly, and 0lh if an error occurs during the READ. 
c4dd			;Disk number in 'diskno' 
c4dd			;Track number in 'track' 
c4dd			;Sector number in 'sector' 
c4dd			;Dma address in 'dmaad' (0-65535) 
c4dd			; 
c4dd cd c2 c4			CALL SETDOP 
c4e0 3e 00			ld	a,00h			;Read sector command 
c4e2 d3 0d			out	(dcmdp),a 
c4e4 db 0d			in	a,(dcmdp)			;get status 
c4e6 e6 01			and	01h			;error bit 
c4e8 c9				ret 
c4e9			 
c4e9			WRITE: 
c4e9			;Write one CP/M sector to disk. 
c4e9			;Return a 00h in register a if the operation completes properly, and 0lh if an error occurs during the READ or WRITE 
c4e9			;Disk number in 'diskno' 
c4e9			;Track number in 'track' 
c4e9			;Sector number in 'sector' 
c4e9			;Dma address in 'dmaad' (0-65535) 
c4e9 cd c2 c4			CALL SETDOP 
c4ec 3e 01			ld	a,01h			;Write sector command 
c4ee d3 0d			out	(dcmdp),a 
c4f0 db 0d			in	a,(dcmdp)			;get status 
c4f2 e6 01			and	01h			;error bit 
c4f4 c9				ret 
c4f5			 
c4f5			; 
c4f5			;patch CCP for user 0 and drive A COM search 
c4f5			; 
c4f5			ptchda: 
c4f5 21 f5 b3			ld	hl,CHGDRV 
c4f8 b6				or	(hl) 
c4f9 c2 03 c5			jp	NZ,ptchu0 
c4fc 34				inc	(hl) 
c4fd 11 db b3			ld	de,FCB+9 
c500 c3 d2 b2			jp	UNKWN2 
c503			ptchu0: 
c503 cd 13 ad			call	GETUSR 
c506 b7				or	a 
c507 ca 70 b3			jp	Z,UNKWN9	;error 
c50a 5f				ld	e,a 
c50b d5				push	de 
c50c 1e 00			ld	e,0 
c50e cd 15 ad			call	GETSETUC 
c511 cd d0 ac			call	OPENFCB 
c514 d1				pop	de 
c515 f5				push	AF 
c516 cd 15 ad			call	GETSETUC 
c519 f1				pop	AF 
c51a c2 e3 b2			jp	NZ,UNKWN25	;continue 
c51d c3 70 b3			jp	UNKWN9	;error 
c520			 
c520			; 
c520			;	the remainder of the cbios is reserved uninitialized 
c520			;	data area, and does not need to be a Part of the 
c520			;	system	memory image (the space must be available, 
c520			;	however, between"begdat" and"enddat"). 
c520			; 
c520 00...		track:	defs	2		;two bytes for expansion 
c522 00...		sector:	defs	2		;two bytes for expansion 
c524 00...		dmaad:	defs	2		;direct memory address 
c526 00...		diskno:	defs	1		;disk number 0-15 
c527			; 
c527			;	scratch ram area for bdos use 
c527			begdat:	equ	$	 	;beginning of data area 
c527 00...		dirbf:	defs	128	 	;scratch directory area 
c5a7 00...		all00:	defs	31	 	;allocation vector 0 
c5c6 00...		all01:	defs	31	 	;allocation vector 1 
c5e5 00...		all02:	defs	31	 	;allocation vector 2 
c604 00...		all03:	defs	31	 	;allocation vector 3 
c623 00...		all04:	defs	31	 	;allocation vector 4 
c642 00...		all05:	defs	31	 	;allocation vector 5 
c661 00...		all06:	defs	31	 	;allocation vector 6 
c680 00...		all07:	defs	31	 	;allocation vector 7 
c69f 00...		chk00:	defs	16		;check vector 0 
c6af 00...		chk01:	defs	16		;check vector 1 
c6bf 00...		chk02:	defs	16	 	;check vector 2 
c6cf 00...		chk03:	defs	16	 	;check vector 3 
c6df 00...		chk04:	defs	16		;check vector 4 
c6ef 00...		chk05:	defs	16		;check vector 5 
c6ff 00...		chk06:	defs	16	 	;check vector 6 
c70f 00...		chk07:	defs	16	 	;check vector 7 
c71f			; 
c71f			enddat:	equ	$	 	;end of data area 
c71f			datsiz:	equ	$-begdat;	;size of data area 
c71f			 
c71f			; 
c71f			;* 
c71f			;******************   E N D   O F   C P / M   ***************** 
c71f			;* 
c71f			 
# End of file CPM22.Z80
c71f
